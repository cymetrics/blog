<!DOCTYPE html><html domain=tech-blog.cymetrics.io ga-id=G-3VBVCXV9Z0 lang=zh-TW><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="index, follow" name=robots><meta content=CYBER,Cymetrics,Security name=keywords><link href="/img/favicon/favicon-192x192.png?hash=42b087227d" rel=icon type=image/png><meta content=#5789d3 name=theme-color><title>在做跳轉功能時應該注意的問題：Open Redirect</title><meta content="在做跳轉功能時應該注意的問題：Open Redirect" property=og:title><meta content="在做跳轉功能時應該注意的問題：Open Redirect" name=twitter:title><meta content=summary name=twitter:card><meta content=重新導向在網站中是個很常見的功能，但你有思考過這背後存在什麼樣的風險嗎？ name=description><meta content=重新導向在網站中是個很常見的功能，但你有思考過這背後存在什麼樣的風險嗎？ name=twitter:description><meta content=重新導向在網站中是個很常見的功能，但你有思考過這背後存在什麼樣的風險嗎？ property=og:description><meta content=article property=og:type><meta content=https://tech-blog.cymetrics.io/posts/huli/open-redirect/ property=og:url><meta content="Cymetrics Tech Blog" property=og:site_name><meta content=https://tech-blog.cymetrics.io/img/favicon/favicon-512x512.png property=og:image><meta content=https://tech-blog.cymetrics.io/img/favicon/favicon-512x512.png name=twitter:image><meta content=hsZQwAip9iIbys-i4PJp_MfpNiA6w6RB0hYdWLiLUuk name=google-site-verification><link href=https://tech-blog.cymetrics.io/posts/huli/open-redirect/ rel=canonical><meta content=always name=referrer><link href=/feed/feed.xml rel=alternate type=application/atom+xml title="Cymetrics Tech Blog"><link href=/ rel=preconnect crossorigin=""><script async src="/js/min.js?hash=4aa09e9651" defer></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-3VBVCXV9Z0"></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-3VBVCXV9Z0');</script><script csp-hash="">if (/Mac OS X/.test(navigator.userAgent))document.documentElement.classList.add('apple')</script><style>:root{--primary-color: #5789d3;--primary-dark-color: #ffd349;--fgColor: #2f2f2f;--bgColor: linear-gradient(to top, #efefef, #ffffff);--primary: var(--primary-color);--primary-dark: var(--primary-dark-color);--fg: var(--fgColor);--bg: var(--bgColor);--progressColor: #ffd349;--main-width: calc(100vw - 3em)}main img{content-visibility:auto}article *{scroll-margin-top:50px}header nav{z-index:1;position:fixed;top:0;left:0;width:100vw;background:#fff;font-weight:200;text-align:right;padding:0}@media (min-width:37.5em){:root{--main-width: calc(37.5em - 3em)}}dialog,share-widget{position:fixed;opacity:.9}share-widget{right:20px;bottom:20px;width:50px;height:50px;border-radius:50%;overflow:hidden;box-shadow:2px 3px 5px 2px rgba(0,0,0,.2)}@media screen and (max-width:376px){share-widget{display:none}}share-widget div{margin-left:50%;transform:translateX(-50%);width:20px;height:20px;background-image:url(/img/share.svg);background-repeat:no-repeat;background-position:center;background-size:contain}.apple share-widget div{background-image:url(/img/share-apple.svg)}share-widget button{margin:0;padding:0;width:100%;height:100%;transition:.3s}share-widget button:active{transform:scale(1.2)}dialog{background-color:var(--primary-dark);z-index:1000;font-size:14px}#reading-progress{z-index:1;background-color:var(--progressColor);width:100vw;position:absolute;left:0;bottom:0;height:2px;transform:translate(-100vw,0);will-change:transform;pointer-events:none}#posts li{margin-bottom:.5em}html{line-height:1.15;-webkit-text-size-adjust:100%;font-family:"Open Sans",-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans","Helvetica Neue",Helvetica,Arial,"Noto Sans TC","PingFang TC","Hiragino Sans GB","Heiti TC","Microsoft YaHei","Microsoft Jhenghei",sans-serif;--font-family: "Open Sans", -apple-system, system-ui, BlinkMacSystemFont,
    "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Helvetica, Arial,
    "Noto Sans TC", "PingFang TC", "Hiragino Sans GB", "Heiti TC",
    "Microsoft YaHei", "Microsoft Jhenghei", sans-serif}body{margin:0}body.lock{overflow:hidden}a{background-color:transparent;text-underline-offset:2px;text-decoration:none;color:var(--primary)}b{font-weight:700}img{border-style:none;max-width:100%;height:auto;margin:0 auto}button,input{font-family:inherit;font-size:100%;line-height:1.15;overflow:visible}button{text-transform:none}input{margin:0}[type=button],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}summary{display:list-item}h2{font-size:2.5em;line-height:1.2;margin-bottom:.6em;line-height:2.4rem;margin-bottom:1.36rem;font-size:1.728rem}body,ol,p,pre{font-size:1em}ol,p,pre{margin-bottom:1.5em}body,ol,p,pre{font-size:1rem;line-height:1.6}ol,p,pre{margin-bottom:1.36rem}@media (min-width:600px){h2{font-size:2.0097rem;line-height:2.52rem}body,ol,p,pre{font-size:1.1rem;line-height:1.6}h2,ol,p,pre{margin-bottom:1.496rem}}@media (min-width:1200px){h2{font-size:2.05rem}body,ol,p,pre{font-size:1.2rem;line-height:1.6}h2,ol,p,pre{margin-bottom:1.632rem}}code,pre{overflow-x:auto}pre{font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace}pre code:not([class]){overflow-x:scroll}code{border-radius:.3em;color:#e33671;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:90%}h1,h2{font-family:var(--font-family)}a:hover{text-decoration:underline}button,input{border-radius:.3em;max-width:100%}input{padding:.75em;margin-bottom:1.5em;display:inline}button+label,input+label,label+*{page-break-before:always}button,label{display:inline-block}button{background:#f2f2f2;color:#191919;cursor:pointer;padding:.75em 1.5em;text-align:center;margin:0 .75em 1.5em 0}button:hover{background:#d9d9d9;color:#000}button:not([disabled]){background:#f9c412;color:#181818;background:var(--primary)}button:not([disabled]):hover{background:#ba9005;color:#000;background:var(--primary-dark)}input[type=number],input[type=search],input[type=url]{border:1px solid #595959;padding:.75em}*,.utterances{box-sizing:border-box}*{border:0}body{font-family:var(--font-family);background:var(--bg);color:var(--fg)}header label{display:block}article,header{max-width:100%;width:42.5em;margin:0 auto}header{padding:4.5em 24px 0;text-align:center;flex-direction:column}header p,ol{margin-top:0}header nav .nav-title{float:left;font-size:inherit;line-height:inherit;margin:0;text-align:left}header nav label{color:#000;cursor:pointer;margin:0;font-style:normal;text-align:right}main{max-width:70rem;margin:0 auto;min-height:60vh}article{padding:1.5em;word-break:break-word}li ol{margin-bottom:0}code[class*=language-],pre[class*=language-]{color:#ccc;background:0 0;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;background:#2d2d2d}.token.comment{color:#999}.token.punctuation{color:#ccc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.property{color:#f8c555}.token.keyword{color:#cc99cd}.token.regex,.token.string{color:#7ec699}.token.operator,.token.url{color:#67cdcc}.nav__links a,.token.bold{font-weight:700}.token.inserted{color:green}.utterances{position:relative;width:100%;max-width:760px;margin-left:auto;margin-right:auto}.w-full{width:100%}body.dark{--fg: var(--bgColor);--bg: var(--fgColor);--primary: var(--primary-dark-color);--paginationCurrentColor: #666356}@media (prefers-color-scheme:dark){body.dark{--fg: var(--bgColor);--bg: var(--fgColor);--primary: var(--primary-dark-color);--paginationCurrentColor: #666356}}h1{font-size:32px;line-height:1.25;margin:.67em 0;text-align:left}header aside{font-size:16px;color:#4b4b4b}.post,footer{border-top:1px solid #ccc}.post{padding-top:35px;margin-top:35px}.menu__btn{display:inline-block;width:24px;height:24px;position:relative}.menu__btn span{opacity:0;width:1px;height:1px;overflow:hidden;display:block}.menu__btn::after,.menu__btn::before{content:"";position:absolute;top:51%;left:50%;height:2px;width:17px;background-color:#2d2d2d;border-radius:.1rem}.menu__btn::before{transform:translate(-50%,-50%);box-shadow:0 .3rem 0 #2d2d2d,0 -.3rem 0 #2d2d2d}.menu__btn::after{display:none;transform:translate(-50%,-50%) rotate(90deg)}.menu__btn.menu__btn--close{z-index:9;transform:rotate(45deg)}.menu__btn.menu__btn--close::before{box-shadow:none}.menu__btn.menu__btn--close::after{display:block}#nav,#nav .nav-title,header{display:flex;align-items:center}#nav{position:relative;height:68px;z-index:2}#nav .nav-title{padding:.375rem 1.5rem;width:100%;justify-content:space-between}#nav .nav-title *,.article-footer img{margin:0}.nav__links{display:none;flex-direction:column;position:fixed;z-index:3;top:0;left:0;right:0;bottom:0;padding:86px 48px 0;background-image:linear-gradient(to top,#efefef,#fff),linear-gradient(to bottom,#f9f9f9,#f9f9f9)}.nav__links--open{display:flex}.nav__links a{text-align:left;width:100%;padding:.5rem 0;transition:all .3s ease-out;text-decoration:none;color:var(--fg)}.nav__links a:hover{color:var(--primary-color)}.nav-logo{width:260px;height:40px;background:url(/img/logo1.png) no-repeat center center;background-size:contain}footer{margin-top:48px;font-size:14px;padding:24px;text-align:center}.copyright{display:inline-block}footer>*{margin:.5em}.footer-logos{display:flex;align-items:center;justify-content:center}.footer-logos a:not(:first-child){margin-left:32px}.post-tags{display:flex;gap:0 16px;flex-wrap:wrap}.direct-link{display:none}.post-avatar{margin-top:27px;display:flex;align-items:center;height:36px}.post-avatar__img{width:36px;height:36px;overflow:hidden;margin:0;border-radius:50%}.post-avatar__time{font-size:13px}.post-avatar__info{margin-left:8px;color:#747474;text-align:left}.post-avatar__author{font-size:14px;font-weight:700}.article-footer{margin-top:40px;border-bottom:1px solid #ccc;padding-bottom:52px}.article-footer a{float:right;display:flex;align-items:center;color:var(--fg);font-weight:700;margin-left:4px}.article-author{margin-top:34px;display:flex;align-items:flex-start;margin-bottom:48px}.article-author__img{width:80px;height:80px;overflow:hidden;margin:0;border-radius:50%;flex-shrink:0}.article-author__info{margin-left:16px;text-align:left}.article-author__title{color:#747474;font-size:16px}.article-author__author{font-size:22px;font-weight:700;line-height:1em}.article-author__intro{color:#2f2f2f;margin-top:8px}@media (min-width:768px){h1{font-size:48px}header aside{font-size:20px}header nav a:first-of-type{margin-left:auto}header nav a:last-of-type{margin-right:1.5em}.menu__btn{display:none}#nav,footer{max-width:1168px}#nav{height:80px;margin:0 auto}.nav-logo{width:313px}.nav__links{display:flex;flex-direction:row;position:static;padding:0;background-image:none}.nav__links a{text-align:center;margin-left:56px}footer{display:flex;flex-direction:row-reverse;justify-content:space-between;align-items:center;margin-left:auto;margin-right:auto}}.notice-block{text-align:left;background:rgba(87,137,211,.2);padding:16px;margin-top:24px;border-radius:8px}</style></head><body><header><nav><div id=nav><div class=nav-title><a href=/ class=nav-logo title=Homepage></a> <label class=menu__btn for=menu__control><span>Menu</span></label></div><div class=nav__links><a href=/archive/ >Archive</a> <a href=/tags/ >Tags</a> <a href=/about/ >About</a></div></div><div id=reading-progress aria-hidden=true></div></nav><h1 class=w-full>在做跳轉功能時應該注意的問題：Open Redirect</h1><aside class=w-full><div class=post-tags><a href=/tags/security/ class=post-tag>#Security</a> <a href=/tags/front-end/ class=post-tag>#Front-end</a> <a href=/tags/back-end/ class=post-tag>#Back-end</a></div><div class=post-avatar><img alt=huli src=/img/authors/huli_logo.jpg class=post-avatar__img data-deopt=true><div class=post-avatar__info><div class=post-avatar__author><a href=/posts/huli>huli</a></div><div class=post-avatar__time>07 Sep 2021</div></div></div><div class=notice-block data-nosnippet="">我們正在尋找一位 Senior Security Engineer 加入我們的團隊，詳情請參考<a href=https://github.com/cymetrics/blog/issues/6 rel="noopener noreferrer" target=_blank>職缺資訊</a></div></aside><dialog id=message></dialog></header><main><article><div id=post-page></div><h2 id=%E5%89%8D%E8%A8%80><a href=#%E5%89%8D%E8%A8%80 class=direct-link>#</a> 前言</h2><p>在許多網站中都有個很常見的功能，就是重新導向。</p><p>舉例來說，如果要觀看的頁面需要權限但是使用者還沒登入，就會先把使用者導去登入頁面，登入完之後再導回原本要去的頁面。</p><p>例如說今天有個社群網站，想要看個人檔案的話需要登入，而小明的個人檔案網址是：<code>https://example.com/profile/ming</code>，那我身為一個訪客，點進去之後就會跳轉到登入頁面，並且帶上我原本要去的網址當作參數：<br><code>https://example.com/login?redirect=https://example.com/profile/ming</code></p><p>登入成功之後，網站就會根據 <code>redirect</code> 的值，把我導去原本要前往的頁面。</p><p>雖然看起來是個小功能，但其實背後有不少安全性的問題要考慮。</p><h2 id=%E4%BB%80%E9%BA%BC%E6%98%AF-open-redirect%EF%BC%9F><a href=#%E4%BB%80%E9%BA%BC%E6%98%AF-open-redirect%EF%BC%9F class=direct-link>#</a> 什麼是 open redirect？</h2><p>Open redirect，中文通常翻作開放式重定向或是公開重定向之類的，但我自己喜歡翻成：「任意重新導向」，覺得比較貼近原意，就是可以重新導向到任意目的地。</p><p>以文章開頭的例子來說，攻擊者其實可以在 URL 上面帶任何值，例如說：<code>https://attacker.com</code>，這樣使用者在登入之後，就會跳轉到這個頁面。</p><p>像這個就是需要使用者操作（登入）才能觸發重新導向，但有些功能無需使用者操作，可能就有著重新導向的功能。以登入的這個例子來說，假設使用者已經登入了，那 <code>https://example.com/login?redirect=https://attacker.com</code> 這個連結點下去之後，系統偵測到已經登入，就會直接把使用者轉到 <code>https://attacker.com</code>。</p><p>這造成的結果是什麼呢？</p><p>使用者點了一個 <a href=http://example.com rel="noopener noreferrer" target=_blank>example.com</a> 的連結，卻在無意間被轉到 <a href=http://attacker.com rel="noopener noreferrer" target=_blank>attacker.com</a> 去。這種可以直接把使用者導到任意地方去的漏洞，就叫做 open redirect。</p><h2 id=open-redirect-%E8%83%BD%E9%80%A0%E6%88%90%E4%BB%80%E9%BA%BC%E5%95%8F%E9%A1%8C%EF%BC%9F><a href=#open-redirect-%E8%83%BD%E9%80%A0%E6%88%90%E4%BB%80%E9%BA%BC%E5%95%8F%E9%A1%8C%EF%BC%9F class=direct-link>#</a> Open redirect 能造成什麼問題？</h2><p>一個最直覺能想到的攻擊方式，大概就是釣魚網站了。在講攻擊手法的時候，我覺得「情境」是一個滿重要的因素，有些看似沒什麼的攻擊，在搭配適當的情境之後，你會覺得「哇，好像滿容易成功的」。</p><p>在看得到網址的狀況下，你看到陌生的網址就會比較小心翼翼，因為你知道可能會是詐騙或是釣魚網站；但若是看到熟悉的網址，會放鬆一些戒心：</p><p><picture><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/open-redirect/chat-1920w.webp 1920w, /img/posts/huli/open-redirect/chat-1280w.webp 1280w, /img/posts/huli/open-redirect/chat-840w.webp 840w, /img/posts/huli/open-redirect/chat-320w.webp 320w" type=image/webp><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/open-redirect/chat-1920w.jpg 1920w, /img/posts/huli/open-redirect/chat-1280w.jpg 1280w, /img/posts/huli/open-redirect/chat-840w.jpg 840w, /img/posts/huli/open-redirect/chat-320w.jpg 320w" type=image/jpeg><img alt="" src=/img/posts/huli/open-redirect/chat-1920w.jpg height=663 width=360 decoding=async loading=lazy style="background-size:cover;background-image:url(&#34;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 360 663'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' preserveAspectRatio='none' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAALCAYAAABcUvyWAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA6UlEQVQY0yWNy0rDUBRF7+8JjgTxGxwKDgTxA/wA8UHpSJwrBcEPMIi12mpMbm6a3Jw8mg6U2pc6Wt7EwebAXvvsrbYOztk9vmJz/5SNvRN2jrpsH3ZQnd4Dt57P5V2fbs/j4uaes2sPNYoEYwySjklMSCYFQVKhHv2UxGZoHTlpEqkYhIIaBJaiqhERMmvJypqhKVBPDrzGJaGt0TLl3dW8jct/8KyFkcmdUeAnLpROUK0ZF20qtBN08+mueonyNt1UNGaU1RgnNXSg2WhAkFYYqYnzKepjtuBzNme5/mH1/ct8ueZrseIPZKjkpQ6DPU8AAAAASUVORK5CYII='%3E%3C/image%3E%3C/svg%3E&#34;)"></picture></p><p>圖上的網址最後那段其實是 <a href=https://attacker.com rel="noopener noreferrer" target=_blank>https://attacker.com</a> url encode 過的結果，所以使用者根本不會注意到後面那串，只會看到前面是由 <a href=http://facebookb.com rel="noopener noreferrer" target=_blank>facebookb.com</a> 開頭，這邊我想強調的事情是「看到熟悉的網址，使用者會比較沒有戒心」。</p><p>但這樣子的情境，其實很類似的網址也可以達成差不多的事情（只是效力比較低），例如說 <a href=http://facebo0k.com rel="noopener noreferrer" target=_blank>facebo0k.com</a> 或是 <a href=http://myfacebook.com rel="noopener noreferrer" target=_blank>myfacebook.com</a> 之類的。</p><p>這時候可以再設想另外一個情境，就是有些網站當你點擊外部連結的時候，會提醒你說：「你要連到外部網站了喔，要小心喔」，這時候如果利用 open redirect 的話，網站可能就不會跳出提示（因為是同一個網域），使用者或許就在無意之間跳到了別的網站而不自知。</p><p>例如說今天有個論壇好了，有個地方有 open redirect 的漏洞，然後我在文章裡面放了一個連結，利用 open redirect 讓跳去外部網站的提示失效，而使用者點了連結之後會到「精心設計的釣魚網站」，介面長得一模一樣，但是跳出個要輸入帳號密碼的 popup 跟你說你的連線階段已過期，請重新登入。這時使用者就有比較高的機率會去輸入帳號密碼，因為沒有想到自己被跳轉到釣魚網站。</p><p>以上這些問題，都只是在討論 open redirect 「不跟其他漏洞結合」的狀況下，可以造成哪些危害，聽起來好像還好對吧？跟其他攻擊比起來似乎沒什麼，但是 open redirect 被低估的地方，其實是在它與其他漏洞的結合之後，可以發揮出的威力。</p><p>在繼續往下之前，我們必須先了解一下重新導向的實作，主要分為兩種：</p><ol><li>後端重新導向，透過 response header <code>Location</code></li><li>前端重新導向，可能透過 history.push 或是 window.open 以及 location 等等</li></ol><p>第一種透過後端來做 redirect，是靠 server 回傳 <code>Location</code> 這個 header，瀏覽器就會把使用者導到相對應的地方去。實作上可能會像是這樣：</p><pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  res<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">302</span><span class="token punctuation">)</span><br>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Location: '</span> <span class="token operator">+</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>redirect<span class="token punctuation">)</span><br>  <span class="token keyword">return</span><br><span class="token punctuation">}</span></code></pre><p>而第二種由前端實作的就不太一樣了，一個常見的範例是直接把要去的地方 assign 給 <code>window.location</code> 做頁面跳轉：</p><pre class=language-js><code class=language-js><span class="token keyword">const</span> searchParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span><br>window<span class="token punctuation">.</span>location <span class="token operator">=</span> searchParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'redirect'</span><span class="token punctuation">)</span></code></pre><p>或如果是 SPA 不想換頁的話，可能會直接用 <code>history.push</code> 或是框架內建的 router.push。</p><p>而無論是前端還是後端來做重新導向，光是實作方式都有各自的問題需要處理。</p><h2 id=%E5%BE%8C%E7%AB%AF%EF%BC%9Acrlf-injection><a href=#%E5%BE%8C%E7%AB%AF%EF%BC%9Acrlf-injection class=direct-link>#</a> 後端：CRLF injection</h2><p>後端的重新導向中，會把傳過來的值塞到 <code>Location</code> 這個 response header 裡面。有些 server 或是 framework 如果沒有處理好的話，可以塞入換行字元，例如說把重新導向的網址設定為 <code>abc\ntest:123</code>，有可能 response 就變成：</p><pre><code>HTTP/2 302 Found
Location: abc
test:123
</code></pre><p>那若是改成：<code>abc\n\n&lt;script>alert(1)&lt;/script></code>，response 就會變成：</p><pre><code>HTTP/2 302 Found
Location: abc

&lt;script>alert(1)&lt;/script>
....
</code></pre><p>藉由 CRLF injection 去改變 response body 的內容，但很遺憾似乎無法直接達成 XSS，因為瀏覽器看到 status code 是 301/302 時會忽略 response body，直接把使用者導去目標頁面。</p><p>我找到可以運作的資料都已經是四五年前的了：</p><ol><li><a href=https://hackerone.com/reports/192667 rel="noopener noreferrer" target=_blank>[stagecafrstore.starbucks.com] CRLF Injection, XSS</a></li><li><a href=https://hackerone.com/reports/260744 rel="noopener noreferrer" target=_blank>[dev.twitter.com] XSS and Open Redirect</a></li></ol><p>我記得我好像看過有篇文章在講這種情況應該怎麼辦，但我找很久都找不到，如果知道該怎麼繞過的請告訴我。</p><p>不過就算改變 response body 沒什麼用，改變其他的 header 也可能串聯其他攻擊，例如說 Set-Cookie，可以幫使用者設置任意 cookie，就有機會再串接 session fixation 或是 CSRF 之類的攻擊。</p><h2 id=%E5%89%8D%E7%AB%AF%EF%BC%9Axss><a href=#%E5%89%8D%E7%AB%AF%EF%BC%9Axss class=direct-link>#</a> 前端：XSS</h2><p>如果是前端實作的重新導向，要特別注意的一個問題就是 XSS。</p><p>你可能會疑惑重新導向跟 XSS 有什麼關係，我們先來回顧一下前端重新導向的程式碼：</p><pre class=language-js><code class=language-js><span class="token keyword">const</span> searchParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLSearchParams</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span><br>window<span class="token punctuation">.</span>location <span class="token operator">=</span> searchParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'redirect'</span><span class="token punctuation">)</span></code></pre><p>這樣會有什麼問題呢？</p><p>在 JS 裡面有個應該不少人看過，但可能比較少用的東西，叫做 JavaScript pseudo protocol，像是這樣：</p><pre><code>&lt;a href="javascript:alert(1)">click me&lt;/a>
</code></pre><p>點了那個 a 之後，會執行 JS 跳出一個 alert。而這招除了可以用在 href 以外，其實也可以用在 location 上面：</p><pre class=language-js><code class=language-js>window<span class="token punctuation">.</span>location <span class="token operator">=</span> <span class="token string">'javascript:alert(1)'</span></code></pre><p>打開你的瀏覽器開新分頁，然後在 devtool console 直接執行上面那一段，會發現 alert 真的跳出來了，而且以下幾種方式都會觸發：</p><pre class=language-js><code class=language-js>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'javascript:alert(1)'</span><br>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token string">'javascript:alert(1)'</span><span class="token punctuation">)</span><br>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'javascript:alert(1)'</span><span class="token punctuation">)</span></code></pre><p>因此攻擊者只要把 redirect 的位置設置成 <code>javascript:xxx</code>，就可以執行任意程式碼，觸發 XSS。這個案例前端的朋友們一定要特別注意，因為直接把值 assign 給 location 是個很常見的實作方式。</p><p>底下直接帶大家看一個真實世界的案例，對象是之前在另一篇文章：<a href=https://tech-blog.cymetrics.io/posts/huli/prevent-xss-might-be-harder-than-you-thought/ >防止 XSS 可能比想像中困難</a>出現過的網站：<a href=https://matters.news/ rel="noopener noreferrer" target=_blank>Matters News</a>。</p><p>這是他們的登入頁面：</p><p><picture><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/open-redirect/matters-1920w.webp 1920w, /img/posts/huli/open-redirect/matters-1280w.webp 1280w, /img/posts/huli/open-redirect/matters-840w.webp 840w, /img/posts/huli/open-redirect/matters-320w.webp 320w" type=image/webp><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/open-redirect/matters-1920w.jpg 1920w, /img/posts/huli/open-redirect/matters-1280w.jpg 1280w, /img/posts/huli/open-redirect/matters-840w.jpg 840w, /img/posts/huli/open-redirect/matters-320w.jpg 320w" type=image/jpeg><img alt="" src=/img/posts/huli/open-redirect/matters-1920w.jpg height=574 width=1152 decoding=async loading=lazy style="background-size:cover;background-image:url(&#34;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 1152 574'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' preserveAspectRatio='none' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAFCAYAAACTphZWAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAe0lEQVQI11VOSQ4DIQzj/y/sD3pAKoVCCKvrcBjNRLJiWbYT571Hzhk2UivWnNh7PzCpffIPLsaI1toRhSHjYwz03i8MYq8FF0JAZSPdaNzWcodd6gwnEZrfL2gJ5kX6Mqh62u9QasrtzGSzeCbxJWGDXSqlHK7ktgvxB4051udEOXj5AAAAAElFTkSuQmCC'%3E%3C/image%3E%3C/svg%3E&#34;)"></picture></p><p>在點下登入之後，會呼叫一個叫做 <code>redirectToTarget</code> 的 function，而這個函式的程式碼是這樣：</p><pre class=language-js><code class=language-js><span class="token comment">/**<br> * Redirect to "?target=" or fallback URL with page reload.<br> *<br> * (works on CSR)<br> */</span><br><span class="token keyword">export</span> <span class="token keyword">const</span> redirectToTarget <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><br>  fallback <span class="token operator">=</span> <span class="token string">'current'</span><span class="token punctuation">,</span><br><span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>  fallback<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'homepage'</span> <span class="token operator">|</span> <span class="token string">'current'</span><br><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> fallbackTarget <span class="token operator">=</span><br>    fallback <span class="token operator">===</span> <span class="token string">'homepage'</span><br>      <span class="token operator">?</span> <span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">/</span><span class="token string template-punctuation">`</span></span> <span class="token comment">// FIXME: to purge cache</span><br>      <span class="token operator">:</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<br>  <span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> fallbackTarget<br><br>  window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>在拿到 target 之後直接使用了：<code>window.location.href = decodeURIComponent(target)</code> 來做重新導向。而 <code>getTarget</code> 其實就是去 url query string 把 target 的值拿出來。所以如果登入的網址是：<code>https://matters.news/login?target=javascript:alert(1)</code>，在使用者按下登入並且成功之後，就會跳出一個 alert，觸發 XSS！</p><p>不僅如此，這個 XSS 一旦被觸發了，影響力非同小可，因為這是登入頁面，所以在這個頁面上執行的 XSS，可以直接抓取 input 的值，也就是偷到使用者的帳號密碼。如果要執行實際的攻擊，可以針對網站的使用者寄發釣魚信，在信中放入這個惡意連結讓使用者點擊，由於網址是正常的網址，點擊之後到的頁面也是真的網站的頁面，因此可信程度應該滿高的。</p><p>在使用者輸入帳號密碼並且登入之後，用 XSS 把帳號密碼偷走並把使用者導回首頁，就可以不留痕跡地偷走使用者帳號，達成帳號奪取。</p><p>修復方式是只允許 http/https 開頭的網址：</p><pre class=language-js><code class=language-js><span class="token keyword">const</span> fallbackTarget <span class="token operator">=</span><br>  fallback <span class="token operator">===</span> <span class="token string">'homepage'</span><br>    <span class="token operator">?</span> <span class="token template-string"><span class="token string template-punctuation">`</span><span class="token string">/</span><span class="token string template-punctuation">`</span></span> <span class="token comment">// FIXME: to purge cache</span><br>    <span class="token operator">:</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<br><span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token keyword">const</span> isValidTarget <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token language-regex regex-source">^((http|https):\/\/)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><br><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isValidTarget<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  target <span class="token operator">=</span> fallbackTarget<br><span class="token punctuation">}</span><br><br>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> target <span class="token operator">||</span> fallbackTarget</code></pre><p>不過這樣其實是先把重新導向功能的 XSS 修掉而已，open redirect 的部分依舊存在，需要進一步對 domain 做檢查才能排除 open redirect。</p><p>再次提醒，這個漏洞滿多工程師都不會發現，因為不知道 <code>window.location.href</code> 可以放 <code>javascript:alert(1)</code> 這樣的網址來執行程式碼，如果大家有實作到重新導向的功能，記得注意一下這個問題。</p><h2 id=open-redirect-%E8%88%87%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%90%AD%E9%85%8D><a href=#open-redirect-%E8%88%87%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E6%90%AD%E9%85%8D class=direct-link>#</a> Open redirect 與其他漏洞的搭配</h2><p>從上面兩個問題可以看出光是「實作重新導向」就可能會寫出有漏洞的程式碼，而接下來要談的是「重新導向」這個功能與其他漏洞的結合。有至少兩個類型的漏洞都有機會與 open redirect 結合，一個是 SSRF，另一個是 OAuth 的漏洞。</p><p>SSRF，全名為 Server-Side Request Forgery，通常翻作伺服器請求偽造，關於這個漏洞詳細的介紹跟攻擊未來可能再寫一篇跟大家介紹，我這邊先簡單講一下。</p><p>通常在內部的 Server，都不會讓外部直接存取到，對外可能只會有一台 proxy 把 request forward 到對應的主機。假設有一個服務的伺服器架構如下圖所示，背後有一台 Back-end Server 會去呼叫隱藏在內網中的 PDF service 產生 PDF 檔案：</p><p><picture><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/open-redirect/ssrf-1920w.webp 1920w, /img/posts/huli/open-redirect/ssrf-1280w.webp 1280w, /img/posts/huli/open-redirect/ssrf-840w.webp 840w, /img/posts/huli/open-redirect/ssrf-320w.webp 320w" type=image/webp><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/huli/open-redirect/ssrf-1920w.jpg 1920w, /img/posts/huli/open-redirect/ssrf-1280w.jpg 1280w, /img/posts/huli/open-redirect/ssrf-840w.jpg 840w, /img/posts/huli/open-redirect/ssrf-320w.jpg 320w" type=image/jpeg><img alt="" src=/img/posts/huli/open-redirect/ssrf-1920w.jpg height=618 width=1097 decoding=async loading=lazy style="background-size:cover;background-image:url(&#34;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 1097 618'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' preserveAspectRatio='none' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAGCAYAAAD68A/GAAAACXBIWXMAAAsTAAALEwEAmpwYAAAArUlEQVQI102OSwrCYAyEk/wP2mrxiaKtj4Xoyo24E8RDiFdw7QEED+GZBE/1WauCizCQSb4ZERH+R1VppA1aoUOe5yxXy49nZnjvKWdzkjTFxNEsMhbnIeYNFUVNkbIYU0xn2O1Jtj4Qq28/MdrXN6VKkAoUPKJ1nCHbI6FffisoSUyIIeKcqxPlv5/XtwZGXeFxF/a7DYPh+Od/D819VB29duByCnRaWUWL9f4FDgBF+/WfhocAAAAASUVORK5CYII='%3E%3C/image%3E%3C/svg%3E&#34;)"></picture></p><p>而這個 PDF service 限制網址只能是 <a href=https://example.com rel="noopener noreferrer" target=_blank>https://example.com</a> 開頭，避免有人傳入其他網址進來。這時如果某個 URL 有 open redirect 的漏洞，攻擊者就可以傳入：<code>https://example.com?redirect=http://127.0.0.1</code>，讓 PDF service 去造訪這個網址，而被轉址到 127.0.0.1，並且回傳它的內容。</p><p>這樣就叫做 SSRF，你透過內部的服務，成功發了一個 request 到外網進不去的 service，如此一來你就可以去看看內網還有什麼其他服務存在，例如說 Redis 或是 MySQL 等等，這些直接從外網都進不去，但透過 SSRF 就可以。或更簡單的方式是去看一些 cloud 相關的檔案，有些 cloud 服務只要存取 <a href=http://169.254.169.254 rel="noopener noreferrer" target=_blank>http://169.254.169.254</a> 就會看到一些 metadata，有興趣可以看這邊：<a href=https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery#exploitation-in-cloud rel="noopener noreferrer" target=_blank>Abusing SSRF in AWS EC2 environment</a>。</p><p>所以透過 open redirect，可以繞過原本有做網址檢查的地方。</p><p>第二個會碰到的問題則是跟 OAuth 有關，在 OAuth 的流程中通常都會有一個 redirect_uri，接收授權完畢之後的一個 code，以 Facebook 為例的話是長這樣：</p><pre><code>https://www.facebook.com/v11.0/dialog/oauth?
  client_id={app-id}
  &redirect_uri={"https://example.com/login"}
  &state={"{st=state123abc,ds=123456789}"}
</code></pre><p>使用者點擊網址後會跳到 Facebook，按下授權就會被導到 <a href=https://example.com/login rel="noopener noreferrer" target=_blank>https://example.com/login</a> 並且可以在網址中拿到 code 或是 token，接著就可以用這個搭配 client id 跟 client secret，拿到 auth token，並且用這個 auth token 代表使用者去跟 Facebook 拿取資料。</p><p>如果 redirect_uri 的保護沒有做好，攻擊者就可以把它換成其他值，例如說：<code>redirect_uri=https://huli.tw</code>，這樣使用者點擊授權以後，就會把驗證用的 code 傳到我的網站，而不是預期中的網站。</p><p>但一般來說 redirect_uri 都會限制 domain，所以沒那麼簡單就可以繞過。這時候就要請出 open redirect 登場了，如果網站有這個漏洞的話，就可以這樣：<code>redirect_uri=https://example.com?redirect=https://huli.tw</code>，如此一來就算符合 domain 限制，最後導向的地方依然是個外部網站，攻擊者一樣可以偷到驗證用的 code。</p><p>所以為了避免這類型的攻擊，Facebook 或 Google 這種大型服務在設置 App 的時候都會加強限制，redirect_uri 通常都會要求寫死，不讓你設置 wildcard，例如說我填 <code>https://example.com/auth</code>，就是真的只有這個網址可以過，其他不同 path 的網址都會失敗。但有些小公司沒有注意到這麼細，對於 redirect_uri 就沒有這麼多規範。</p><p>像是這種 OAuth 結合 open redirect 達成 account takeover（帳號奪取）的例子其實不少，例如說這個：<a href=https://hackerone.com/reports/905607 rel="noopener noreferrer" target=_blank>[cs.money] Open Redirect Leads to Account Takeover</a>，或是 GitHub 其實也有過這類型的漏洞：<a href=https://devcraft.io/2020/10/19/github-gist-account-takeover.html rel="noopener noreferrer" target=_blank>GitHub Gist - Account takeover via open redirect - $10,000 Bounty</a>，而這個 Airbnb 的漏洞也很精彩：<a href=https://www.arneswinnen.net/2017/06/authentication-bypass-on-airbnb-via-oauth-tokens-theft/ rel="noopener noreferrer" target=_blank>Authentication bypass on Airbnb via OAuth tokens theft</a>。</p><p>總結一下，open redirect 的用處除了讓使用者放鬆戒心來進行釣魚以外，另一個就是繞過有針對 domain 進行檢查的地方。上面講的 SSRF 跟 OAuth 這兩個漏洞之所以能跟它結合，就是因為可以用 open redirect 來繞過對 domain 的檢查。</p><h2 id=%E9%82%A3%E8%A9%B2%E6%80%8E%E9%BA%BC%E9%98%B2%E7%A6%A6-open-redirect%EF%BC%9F><a href=#%E9%82%A3%E8%A9%B2%E6%80%8E%E9%BA%BC%E9%98%B2%E7%A6%A6-open-redirect%EF%BC%9F class=direct-link>#</a> 那該怎麼防禦 open redirect？</h2><p>如果想防止 open redirect，可想而知就是要對重新導向的網址進行檢查。這聽起來簡單，實作起來卻容易出現漏洞，例如說底下的例子是一段檢查 domain 的程式碼，根據取出的 hostname 比對是否含有 <code>cymetrics.io</code>，有的話就通過，目的是只有 <a href=http://cymetrics.io rel="noopener noreferrer" target=_blank>cymetrics.io</a> 跟它的 subdomain 可以通過：</p><pre class=language-js><code class=language-js><span class="token keyword">const</span> validDomain <span class="token operator">=</span> <span class="token string">'cymetrics.io'</span><br><span class="token keyword">function</span> <span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> host <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>hostname <span class="token comment">// 取出 hostname</span><br>  <span class="token keyword">return</span> host<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>validDomain<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token string">'https://example.com'</span><span class="token punctuation">)</span> <span class="token comment">// false</span><br><span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token string">'https://cymetrics.io'</span><span class="token punctuation">)</span> <span class="token comment">// true</span><br><span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token string">'https://dev.cymetrics.io'</span><span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre><p>感覺好像沒什麼問題？除了 <code>cymetrics.io</code> 或是它的 subdomain 以外，應該不會有其他網域可以通過這檢查吧？</p><p>雖然看似如此，但其實有兩個方式可以繞過。這邊先假設 URL parsing 的方式不會有問題，一定會拿到 hostname，所以 <code>attacker.com?q=cymetrics.io</code> 這種方式是沒用的，hostname 會拿到 <code>attacker.com</code> 而已。</p><p>大家可以想一下有哪兩種可以繞過，在公佈答案之前，先來看下一個段落。</p><h2 id=google-%E5%B0%8D%E6%96%BC-open-redirect-%E7%9A%84%E7%9C%8B%E6%B3%95><a href=#google-%E5%B0%8D%E6%96%BC-open-redirect-%E7%9A%84%E7%9C%8B%E6%B3%95 class=direct-link>#</a> Google 對於 open redirect 的看法</h2><p>Google 在官方網站 <a href=https://sites.google.com/site/bughunteruniversity/nonvuln/open-redirect rel="noopener noreferrer" target=_blank>Bughunter University</a> 當中有明確提到一般的 open redirect 不會被視為安全性上的漏洞，除非能證明它可以跟其他漏洞結合在一起使用。</p><p>那是不是有人成功過呢？當然，底下我舉兩個例子。</p><p>第一個例子來自這篇文章：<a href=https://blog.bentkowski.info/2018/07/vulnerability-in-hangouts-chat-aka-how.html rel="noopener noreferrer" target=_blank>Vulnerability in Hangouts Chat: from open redirect to code execution</a>，對象是 Google Hangouts Chat 的 Electron App。</p><p>在那個 App 裡面如果網址是 <code>https://chat.google.com</code> 開頭的話，點擊網址就會直接在 Electron 裡面開啟網頁，而不是用瀏覽器去開。因此只要找到 <code>https://chat.google.com</code> 的 open redirect，就可以把使用者導去釣魚網站。而 Electron App 跟瀏覽器的差異之一就在於 Electron App 預設是不會有網址列的，所以使用者根本無從辨別這是不是釣魚網站。詳細的流程跟最後的 payload 可以參考原文，這個漏洞還可以進一步提升成 RCE（不過我不知道是怎麼做的就是了），價值 7500 USD。</p><p>第二個例子來自官方的文章：<a href=https://sites.google.com/site/bughunteruniversity/best-reports/openredirectsthatmatter rel="noopener noreferrer" target=_blank>Open redirects that matter</a>，這個案例也是超帥。</p><p>在 Google I/O 2015 的網站中有個功能是去抓 Picasa 的資料回來並 render 成 JSON，但因為有跨網域的問題，因此後端寫了一個簡單的 proxy 去拿資料，像這樣：<code>/api/v1/photoproxy?url=to</code>，而這個 proxy 會檢查 url 的開頭是否為 <code>https://picasaweb.google.com/data/feed/api</code>，如果不是的話就回傳錯誤。</p><p>所以作者的第一個目標就是找到 picasa 上的 open redirect，他最後找到的是這個網址：<code>https://picasaweb.google.com/bye?continue=</code>，只要把這個網址改成：<code>https://picasaweb.google.com/data/feed/api/../../bye</code>，就可以成功通過路徑的檢查，讓 server 認為這是一個合法的 URL。</p><p>但這還沒結束，因為 bye?continue= 這個 redirect 也會檢查參數，continue 必須是 <code>https://google.com</code> 開頭才可以。因此我們需要找到第二個 open redirect，這次是存在於 <a href=http://google.com rel="noopener noreferrer" target=_blank>google.com</a> 上面。而 <a href=http://google.com rel="noopener noreferrer" target=_blank>google.com</a> 有一個知名的 open redirect 是 AMP 用的，例如說 <code>https://www.google.com/amp/tech-blog.cymetrics.io</code>，就會連到 <a href=https://tech-blog.cymetrics.io>https://tech-blog.cymetrics.io</a> （不過我剛嘗試了一下會先跳到中間頁，點擊確認後才會導向，應該是這功能有修正過了）。</p><p>結合這兩個 open redirect，就可以讓 proxy 去抓取我們指定的 url 的內容：</p><pre><code>https://picasaweb.google.com/data/feed/api/../../../bye/?
continue=https%3A%2F%2Fwww.google.com%2Famp/
your-domain.example.com/path?querystring
</code></pre><p>可是抓了之後只會輸出成 JSON，有什麼用呢？後端的程式碼如下：</p><pre class=language-go><code class=language-go><span class="token keyword">func</span> <span class="token function">servePhotosProxy</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    c <span class="token operator">:=</span> <span class="token function">newContext</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><br>    <span class="token keyword">if</span> r<span class="token punctuation">.</span>Method <span class="token operator">!=</span> <span class="token string">"GET"</span> <span class="token punctuation">{</span><br>        <span class="token function">writeJSONError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> w<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> <span class="token string">"invalid request method"</span><span class="token punctuation">)</span><br>        <span class="token keyword">return</span><br>    <span class="token punctuation">}</span><br>    url <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">FormValue</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><br>    <span class="token keyword">if</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">"https://picasaweb.google.com/data/feed/api"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token function">writeJSONError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> w<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> <span class="token string">"url parameter is missing or is an invalid endpoint"</span><span class="token punctuation">)</span><br>        <span class="token keyword">return</span><br>    <span class="token punctuation">}</span><br>    req<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewRequest</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><br>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        <span class="token function">writeJSONError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> w<span class="token punctuation">,</span> <span class="token function">errStatus</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><br>        <span class="token keyword">return</span><br>    <span class="token punctuation">}</span><br><br><br>    res<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">httpClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><br>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        <span class="token function">writeJSONError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> w<span class="token punctuation">,</span> <span class="token function">errStatus</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><br>        <span class="token keyword">return</span><br>    <span class="token punctuation">}</span><br><br><br>    <span class="token keyword">defer</span> res<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json;charset=utf-8"</span><span class="token punctuation">)</span><br>    w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>StatusCode<span class="token punctuation">)</span><br>    io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> res<span class="token punctuation">.</span>Body<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>因為有設置 content type，所以沒辦法用 MIME sniffing 去攻擊。簡單解釋一下 MIME sniffing，當你的 response 沒有設置 content type 的時候，瀏覽器就會自動去猜這是什麼內容，如果裡面含有 HTML 的話，那就會被當成是 HTML 網站來解析並且渲染。</p><p>而作者發現了另一個 bug，就是如果是 error 的話，並不會設置 content type，只有成功的時候會，所以可以故意回傳一個含有 HTML 的錯誤訊息，這樣被印在畫面時瀏覽器就會把這整份當成是 HTML，進而達成 XSS！詳細的流程跟介紹原文都寫得很清楚，很推薦大家去看一下原文。</p><p>以上就是兩個在 Google 中曾經被發現的 open redirect 串聯其他漏洞引起的攻擊，兩個都很有趣！</p><p>看完上面這些之後，我突然很好奇有哪些 Google 的 open redirect 是大家都知道的，於是我就 google 了：<code>known google open redirect</code>，找到底下幾個網站：</p><ol><li><a href=https://nakedsecurity.sophos.com/2020/05/15/how-scammers-abuse-google-searchs-open-redirect-feature/ rel="noopener noreferrer" target=_blank>How scammers abuse Google Search’s open redirect feature</a></li><li><a href=https://blog.sean-wright.com/google-open-redirect/ rel="noopener noreferrer" target=_blank>Google - Open Redirect</a></li><li><a href=https://www.threatmark.com/google-bug-that-makes-your-bank-more-vulnerable-to-phishing/ rel="noopener noreferrer" target=_blank>Google Bug that Makes Your Bank More Vulnerable to Phishing</a></li></ol><p>如果只是一般的 <a href="https://www.google.com/url?q=http://tech-blog.cymetrics.io" rel="noopener noreferrer" target=_blank>https://www.google.com/url?q=http://tech-blog.cymetrics.io</a> 的話，點進去只會跳到確認頁面，但如果後面加一個參數 usg 的話，就可以不經過確認直接重新導向，不信你點點看這個，會去 <a href=http://example.org rel="noopener noreferrer" target=_blank>example.org</a>：<a href="https://www.google.com/url?sa=t&url=http://example.org/&usg=AOvVaw1YigBkNF7L7D2x2Fl532mA" rel="noopener noreferrer" target=_blank>https://www.google.com/url?sa=t&url=http://example.org/&usg=AOvVaw1YigBkNF7L7D2x2Fl532mA</a></p><p>那這個 usg 是什麼呢？應該是網址經過某種 hash 過後的結果，但你不會知道怎麼算出來的。而要獲得這個 usg 其實也不難，你用 gmail 寄信給自己，信裡面要有你想導向的連結，接著再用 HTML basic view 來看，就會看到信中的連結變成了上面格式的重新導向！</p><p>像是這個，就是我們部落格的重新導向連結：<a href="https://www.google.com/url?q=https%3A%2F%2Ftech-blog.cymetrics.io&sa=D&sntz=1&usg=AFQjCNHyq6urHn6HLwj8RP09GANAlymZug" rel="noopener noreferrer" target=_blank>https://www.google.com/url?q=https%3A%2F%2Ftech-blog.cymetrics.io&sa=D&sntz=1&usg=AFQjCNHyq6urHn6HLwj8RP09GANAlymZug</a></p><p>實測之後發現真的能不經過確認就跳轉，這個功能好像已經存在滿久了，未來如果有需要 <a href=http://google.com rel="noopener noreferrer" target=_blank>google.com</a> 的 open redirect 可以參考看看。</p><h2 id=%E6%AA%A2%E6%9F%A5-redirect-%E7%9A%84-domain><a href=#%E6%AA%A2%E6%9F%A5-redirect-%E7%9A%84-domain class=direct-link>#</a> 檢查 redirect 的 domain</h2><p>好，接著講回剛剛問大家的兩種繞過方式，我再貼一次檢查 domain 的程式碼，讓大家回憶一下，接著就直接公布答案：</p><pre class=language-js><code class=language-js><span class="token keyword">const</span> validDomain <span class="token operator">=</span> <span class="token string">'cymetrics.io'</span><br><span class="token keyword">function</span> <span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> host <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>hostname <span class="token comment">// 取出 hostname</span><br>  <span class="token keyword">return</span> host<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>validDomain<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token string">'https://example.com'</span><span class="token punctuation">)</span> <span class="token comment">// false</span><br><span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token string">'https://cymetrics.io'</span><span class="token punctuation">)</span> <span class="token comment">// true</span><br><span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token string">'https://dev.cymetrics.io'</span><span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre><p>這是在檢查 domain 時滿常會犯的錯誤，因為沒有考慮到以下兩種情形：</p><ol><li><a href=http://cymetrics.io.huli.tw rel="noopener noreferrer" target=_blank>cymetrics.io.huli.tw</a></li><li><a href=http://fakecymetrics.io rel="noopener noreferrer" target=_blank>fakecymetrics.io</a></li></ol><p>上面這兩種情形都符合條件，但卻不是我們想要的結果。</p><p>其實不只是檢查 domain，在做任何檢查的時候用 <code>includes</code> 或是 <code>contains</code> 直接去看整體是否包含某個字串都是一件比較危險的事情。最好的方式其實是設一個 allow list 並且要完全一致才通過，這樣是最嚴格的。但如果想要允許所有 subdomain 的話，可以這樣檢查：</p><pre class=language-js><code class=language-js><span class="token keyword">const</span> validDomain <span class="token operator">=</span> <span class="token string">'cymetrics.io'</span><br><span class="token keyword">function</span> <span class="token function">validateDomain</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> host <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>hostname <span class="token comment">// 取出 hostname</span><br>  <span class="token keyword">return</span> host <span class="token operator">===</span> validDomain <span class="token operator">||</span> host<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'.'</span> <span class="token operator">+</span> validDomain<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>subdomain 的部分結尾要是 <code>.cymetrics.io</code>，所以一定會是 <a href=http://cymetrics.io rel="noopener noreferrer" target=_blank>cymetrics.io</a> 的 subdomain，而主要的 domain 也要完全符合才可以。不過這樣寫的話，如果某一個不相干的 subdomain 有 open redirect 的漏洞，這段就破功了。因此還是建議大家只把確定會 redirect 的 domain 放進去並且直接用 <code>===</code> 做檢查，避免這種狀況發生。</p><h2 id=%E7%B5%90%E8%AA%9E><a href=#%E7%B5%90%E8%AA%9E class=direct-link>#</a> 結語</h2><p>重新導向是個很常見的功能，最常見的就是登入前點了某個連結之後轉到登入頁面，登入成功就會自動跳轉回去。在做這個功能時，如果是前端重新導向，再次提醒大家，要考慮到 <code>window.location = 'javascript:alert(1)'</code> 這樣會出事，請確認重新導向的 URL 是合法的 URL 再做動作。另外，也要確認檢查 domain 時有考慮到可能會被繞過的狀況，盡可能用最嚴謹的方式去處理。</p><p>以上就是對 open redirect 的介紹，希望對大家有幫助，有什麼疑問或是寫錯的地方都可以在下面留言跟我討論。</p><p>參考資料：</p><ol><li><a href=https://blog.detectify.com/2019/05/16/the-real-impact-of-an-open-redirect/ rel="noopener noreferrer" target=_blank>The real impact of an Open Redirect vulnerability</a></li><li><a href=https://blog.intigriti.com/hackademy/open-redirect/ rel="noopener noreferrer" target=_blank>Intigriti: Open Redirect</a></li><li><a href=https://gauravnarwani.com/misconfigured-oauth-to-account-takeover/ rel="noopener noreferrer" target=_blank>Misconfigured OAuth leading to Account Takeover</a></li><li><a href=https://s0cket7.com/open-redirect-vulnerability/ rel="noopener noreferrer" target=_blank>Open Redirect Vulnerability</a></li><li><a href=https://devcraft.io/2020/10/19/github-gist-account-takeover.html rel="noopener noreferrer" target=_blank>GitHub Gist - Account takeover via open redirect - $10,000 Bounty</a></li><li><a href=https://book.hacktricks.xyz/pentesting-web/oauth-to-account-takeover rel="noopener noreferrer" target=_blank>OAuth to Account takeover</a></li></ol><div class=article-footer><a href=https://tech-blog.cymetrics.io/posts/huli/open-redirect/ on-click=share><img alt=Share src="/img/icons/icon_external link hyperlink.svg" height=24 width=24>Share this post</a></div><div><p style="font-weight: bold;">更多同分類文章</p><div class=post-tags><a href=/tags/security/ class=post-tag>#Security</a> <a href=/tags/front-end/ class=post-tag>#Front-end</a> <a href=/tags/back-end/ class=post-tag>#Back-end</a></div><p style="font-weight: bold;">隨機推薦</p><ol><li><a href=/posts/huli/xss-history/ >XSS 從頭談起：歷史與由來</a></li><li><a href=/posts/nick/directory/ >秒懂 Directory Traversal(目錄遍歷)</a></li><li><a href=/posts/nick/owasp-cwe/ >資安規範實戰篇 : OWASP + CWE</a></li><li><a href=/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable-zh/ >比較 Java 和 Golang 在撰寫併發時處理共享變數的差異</a></li><li><a href=/posts/maxchiu/indexing/ >從Indexing的角度切入MySQL-Innodb與PostgreSQL的效能比較</a></li></ol></div><div class=article-author><img alt=huli src=/img/authors/huli_logo.jpg class=article-author__img data-deopt=true><div class=article-author__info><div class=article-author__title>Author</div><div class=article-author__author><a href=/posts/huli>huli</a></div><div class=article-author__intro>遊走在前端與資安間，以開發者身份學習資安，也從資安重新學習前端</div></div></div><script async src=https://utteranc.es/client.js crossorigin=anonymous id=utterance-script issue-term=title label=utterance repo=cymetrics/blog theme=github-light></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"在做跳轉功能時應該注意的問題：Open Redirect","image":["https://tech-blog.cymetrics.io/img/posts/huli/open-redirect/chat-1920w.jpg","https://tech-blog.cymetrics.io/img/posts/huli/open-redirect/matters-1920w.jpg","https://tech-blog.cymetrics.io/img/posts/huli/open-redirect/ssrf-1920w.jpg","https://tech-blog.cymetrics.io/img/icons/icon_external link hyperlink.svg","https://tech-blog.cymetrics.io/img/authors/huli_logo.jpg"],"author":{"@type":"Person","name":"huli"},"publisher":{"@type":"Organization","name":"Cymetrics Tech Blog","url":"https://tech-blog.cymetrics.io","logo":{"@type":"ImageObject","url":"https://tech-blog.cymetrics.io/img/favicon/favicon-512x512.png","width":512,"height":512}},"url":"https://tech-blog.cymetrics.io/posts/huli/open-redirect/","mainEntityOfPage":"https://tech-blog.cymetrics.io/posts/huli/open-redirect/","datePublished":"2021-09-07","dateModified":"2021-09-09","description":"# 前言 在許多網站中都有個很常見的功能，就是重新導向。 舉例來說，如果要觀看的頁面需要權限但是使用者還沒登入，就會先把使用者導去登入頁面，登入完之後再導回原本要去的頁面。..."}</script><script type=application/ld+json>{   
  "@context":"http://schema.org",
  "@type":"BreadcrumbList",
  "itemListElement":[
    {
      "@type": "ListItem",
      "position": 1,
      "name": "Cymetrics Tech Blog",
      "item": "https://tech-blog.cymetrics.io"
    },
    {
      "@type": "ListItem",
      "position": 2,
      "name": "Archive",
      "item": "https://tech-blog.cymetrics.io/archive/"
    },
    {
      "@type": "ListItem",
      "position": 3,
      "name": "在做跳轉功能時應該注意的問題：Open Redirect",
      "item": "https://tech-blog.cymetrics.io/posts/huli/open-redirect/"
    }
  ]
}</script></article></main><footer><div class=footer-logos><a href=https://www.facebook.com/Cymetrics-100957872049641 rel="noopener noreferrer" target=_blank><img alt=facebook src="/img/icons/icon_social media_facebook.svg" height=30 width=30></a><a href=https://www.linkedin.com/company/onedegree-hk rel="noopener noreferrer" target=_blank><img alt=linkedin src="/img/icons/icon_social media_linkedln.svg" height=30 width=30></a><a href=https://tech-blog.cymetrics.io/feed/feed.xml rel="noreferrer noopener" target=_blank><img alt="rss feed" src=/img/icons/rss-feed.svg height=30 width=30></a></div><div class=copyright>© 2021 Cymetrics Tech Blog</div></footer><script>// light/dark theme switch
      // disable dark mode for now
      const menuBtn = document.querySelector('.menu__btn')
      menuBtn.addEventListener('click', function() {
        document.querySelector('body').classList.toggle('lock')
        menuBtn.classList.toggle('menu__btn--close');
        document.querySelector('.nav__links').classList.toggle('nav__links--open')
      })
      

      /*
      const toggleEl = document.querySelector('#color-scheme-toggle')
      const bodyEl = document.querySelector('body');
      const DARK = 'dark';
      const LIGHT = 'light';
      const currentTheme = localStorage.getItem("theme") ||
            (window.matchMedia('(prefers-color-scheme: dark)').matches ? DARK : LIGHT);
      setTheme(currentTheme)

      toggleEl.addEventListener("click", handleToggleEvent)

      function handleToggleEvent(){
        const isDark = bodyEl.classList.toggle(DARK);
        const theme = isDark ? DARK : LIGHT;
        setTheme(theme)
        localStorage.setItem('theme', theme);
      }
      function setTheme(theme){
        if (theme === DARK) {
          setUtterancesTheme(DARK)
          bodyEl.classList.add(DARK);
          toggleEl.src = toggleEl.src.replace(DARK, LIGHT);
        }else{
          setUtterancesTheme(LIGHT)
          toggleEl.src = toggleEl.src.replace(LIGHT, DARK);
        }
      }

      var isUtterancesLoaded = false
      window.addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') {
          return;
        }
        isUtterancesLoaded = true
      });

      function setUtterancesTheme(theme) {
        let utterancesIframe = document.querySelector('.utterances iframe')
        if (!isUtterancesLoaded) {
          return requestAnimationFrame(() => setUtterancesTheme(theme))
        }

        utterancesIframe.contentWindow.postMessage({
          type: 'set-theme',
          theme: theme === DARK ? 'github-dark-orange' : 'github-light'
        }, 'https://utteranc.es');
      }
    */</script></body></html>